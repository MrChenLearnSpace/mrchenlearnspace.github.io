<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>搭建博客</title>
    <url>/2021/11/01/Hollow/</url>
    <content><![CDATA[<h1 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h1><p>文档格式<br><strong>需要git，Node.js，npm</strong></p>
<h2 id="做好准备"><a href="#做好准备" class="headerlink" title="做好准备"></a>做好准备</h2><p>安装好软件，配置好相关的环境</p>
<p>建立一个github仓库，由于在部署时未设置配置建议改成 用户名.github.io,方便网站进入导致只打开一个html，与整个页面脱节的情况</p>
<h2 id="寻找材料"><a href="#寻找材料" class="headerlink" title="寻找材料"></a>寻找材料</h2><p>到Hexo中找相关喜欢的主题，并找到相应的开源的GitHub，先hexo init在空文件夹中初始化，导入相关主题，修改全局中的theme变量</p>
<h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p><a href="https://hexo.io/zh-cn/docs/configuration">https://hexo.io/zh-cn/docs/configuration</a><br>具体配置连接</p>
<p><strong>网站</strong></p>
<p>参数  ||    描述</p>
<p>title ||    网站标题</p>
<p>subtitle ||    网站副标题</p>
<p>description ||    网站描述</p>
<p>keywords ||    网站的关键词。支持多个关键词。</p>
<p>author ||    您的名字</p>
<p>language  ||    网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 zh-Hans和 zh-CN。</p>
<p>timezone ||    网站时区。Hexo 默认使用您电脑的时区。请参考 时区列表 进行设置，如 America/New_York, Japan, 和 UTC 。一般的，对于中国大陆地区可以使用 Asia/Shanghai。</p>
<p><strong>网址</strong></p>
<p>url    || 网址, 必须以 http:// 或 https:// 开头    </p>
<p>root ||    网站根目录    url’s pathname</p>
<p>permalink ||    文章的 永久链接 格式    :year/:month/:day/:title/</p>
<p>permalink_defaults ||     永久链接中各部分的默认值    </p>
<p>pretty_urls ||    改写 permalink 的值来美化 URL    </p>
<p>pretty_urls.trailing_index ||    是否在永久链接中保留尾部的index.html，设置为 false 时去除    true</p>
<p>pretty_urls.trailing_html    是否在永久链接中保留尾部的 .html, 设置为 false 时去除 (对尾部的 index.html无效)</p>
<p><em>网站存放在子目录<br>如果您的网站存放在子目录中，例如 <a href="http://example.com/blog%EF%BC%8C%E5%88%99%E8%AF%B7%E5%B0%86%E6%82%A8%E7%9A%84">http://example.com/blog，则请将您的</a> url 设为 <a href="http://example.com/blog">http://example.com/blog</a> 并把 root 设为 /blog/。</em><br><em>例如：# 比如，一个页面的永久链接是 <a href="http://example.com/foo/bar/index.html">http://example.com/foo/bar/index.html</a><br>pretty_urls:<br>  trailing_index: false<br>此时页面的永久链接会变为 <a href="http://example.com/foo/bar/">http://example.com/foo/bar/</a></em></p>
<p><strong>目录</strong><br>参数  ||    描述  ||    默认值</p>
<p>source_dir ||    资源文件夹，这个文件夹用来存放内容。||    source</p>
<p>public_dir ||    公共文件夹，这个文件夹用于存放生成的站点文件。||    public</p>
<p>tag_dir  ||    标签文件夹 ||    tags</p>
<p>archive_dir    归档文件夹    archives</p>
<p>category_dir    分类文件夹    categories</p>
<p>code_dir    Include code 文件夹，source_dir 下的子目录    downloads/code</p>
<p>i18n_dir    国际化（i18n）文件夹    :lang</p>
<p>skip_render    跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 public 目录中。您可使用 glob 表达式来匹配路径。</p>
<p><strong>文章</strong><br>参数    描述    默认值</p>
<p>new_post_name    新文章的文件名称    :title.md</p>
<p>default_layout    预设布局    post</p>
<p>auto_spacing    在中文和英文之间加入空格    false</p>
<p>titlecase    把标题转换为 title case    false</p>
<p>external_link    在新标签中打开链接    true</p>
<p>external_link.enable    在新标签中打开链接    true</p>
<p>external_link.field    对整个网站（site）生效或仅对文章（post）生效    site</p>
<p>external_link.exclude    需要排除的域名。主域名和子域名如 www 需分别配置    []</p>
<p>filename_case    把文件名称转换为 (1) 小写或 (2) 大写    0</p>
<p>render_drafts    显示草稿    false</p>
<p>post_asset_folder    启动 Asset 文件夹    false</p>
<p>relative_link    把链接改为与根目录的相对位址    false</p>
<p>future    显示未来的文章    true</p>
<p>highlight    代码块的设置, 请参考 Highlight.js 进行设置    </p>
<p>prismjs    代码块的设置, 请参考 PrismJS 进行设置</p>
<p><em>默认情况下，Hexo 生成的超链接都是绝对地址。例如，如果您的网站域名为 example.com,您有一篇文章名为 hello，那么绝对链接可能像这样：<a href="http://example.com/hello.html%EF%BC%8C%E5%AE%83%E6%98%AF%E7%BB%9D%E5%AF%B9%E4%BA%8E%E5%9F%9F%E5%90%8D%E7%9A%84%E3%80%82%E7%9B%B8%E5%AF%B9%E9%93%BE%E6%8E%A5%E5%83%8F%E8%BF%99%E6%A0%B7%EF%BC%9A/hello.html%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%EF%BC%8C%E6%97%A0%E8%AE%BA%E7%94%A8%E4%BB%80%E4%B9%88%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE%E8%AF%A5%E7%AB%99%E7%82%B9%EF%BC%8C%E9%83%BD%E6%B2%A1%E6%9C%89%E5%85%B3%E7%B3%BB%EF%BC%8C%E8%BF%99%E5%9C%A8%E8%BF%9B%E8%A1%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%97%B6%E5%8F%AF%E8%83%BD%E7%94%A8%E5%88%B0%E3%80%82%E9%80%9A%E5%B8%B8%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E7%BB%9D%E5%AF%B9%E5%9C%B0%E5%9D%80%E3%80%82">http://example.com/hello.html，它是绝对于域名的。相对链接像这样：/hello.html，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。</a></em></p>
<p><strong>分类 &amp; 标签</strong></p>
<p>参数    描述    默认值</p>
<p>default_category    默认分类    uncategorized</p>
<p>category_map    分类别名    </p>
<p>tag_map    标签别名    </p>
<p><strong>日期 / 时间格式</strong></p>
<p>参数    描述    默认值</p>
<p>date_format    日期格式    YYYY-MM-DD</p>
<p>time_format    时间格式    HH:mm:ss</p>
<p>updated_option    当 Front Matter 中没有指定 updated 时 updated 的取值    mtime</p>
<p>updated_option<br><em>updated_option 控制了当 Front Matter 中没有指定 updated 时，updated 如何取值：</em></p>
<p><em>mtime: 使用文件的最后修改时间。这是从 Hexo 3.0.0 开始的默认行为。</em><br><em>date: 使用 date 作为 updated 的值。可被用于 Git 工作流之中，因为使用 Git 管理站点时，文件的最后修改日期常常会发生改变</em><br><em>empty: 直接删除 updated。使用这一选项可能会导致大部分主题和插件无法正常工作。</em><br><em>use_date_for_updated 选项已经被废弃，将会在下个重大版本发布时去除。请改为使用 updated_option: ‘date’。</em></p>
<p><em>use_date_for_updated | 启用以后，如果 Front Matter 中没有指定 updated， post.updated 将会使用 date 的值而不是文件的创建时间。在 Git 工作流中这个选项会很有用 | true</em></p>
<p><strong>分页</strong></p>
<p>参数    描述    默认值</p>
<p>per_page    每页显示的文章量 (0 = 关闭分页功能)    10</p>
<p>pagination_dir    分页目录    page</p>
<p><strong>扩展</strong><br>参数    描述</p>
<p>theme    当前主题名称。值为false时禁用主题</p>
<p>theme_config    主题的配置文件。在这里放置的配置会覆盖主题目录下的 _config.yml 中的配置</p>
<p>deploy    部署部分的设置</p>
<p>meta_generator    Meta generator 标签。 值为 false 时 Hexo 不会在头部插入该标签</p>
<ul>
<li>*<h3 id="特别注意，记得修改配置中的连接和主题"><a href="#特别注意，记得修改配置中的连接和主题" class="headerlink" title="特别注意，记得修改配置中的连接和主题"></a>特别注意，记得修改配置中的连接和主题</h3></li>
<li>*</li>
</ul>
<h2 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h2><p>配置好配置中的部署部分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/MrChenLreanSpace/MrChenLreanSpace.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure>
<p>用 npm 安装好hexo-deployer-git.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git </span><br></pre></td></tr></table></figure>
<p>有些加入搜索功能，需要插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>配置hexo全局配置文件（请将生成的索引文件放在网站根目录或修改主题js文件的path值）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>
<p>在主题配置文件启用本地搜索</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#本地搜索,请将索引文件放在网站根目录</span><br><span class="line">local_search:</span><br><span class="line">    #是否启用</span><br><span class="line">    enable: true</span><br></pre></td></tr></table></figure>
<p>开始生成本地站点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<p>本地测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s 或者 hexo serve</span><br></pre></td></tr></table></figure>
<p>完成之后，连上github，需要GitHub的令牌，令牌生成后记得记住密钥，之后会看不到<br>令牌在设置的开发者选项中第三个第一次上传需要登入和用用户名和令牌连上账户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean&amp;&amp;hexo d</span><br></pre></td></tr></table></figure>
<p>清除本地文件且部署到GitHub上</p>
]]></content>
      <categories>
        <category>博客开始</category>
      </categories>
      <tags>
        <tag>标签和分类可以多个</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL学习之路之窗口的建立</title>
    <url>/2021/11/02/OpenGL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E7%AA%97%E5%8F%A3%E7%9A%84%E5%BB%BA%E7%AB%8B/</url>
    <content><![CDATA[<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>先建立一个空项目，建立一个c++文件，然后设置解决方案的属性设置三个位置<br><strong>第一是c&#x2F;c++\常规\附加包含目录加入include的文件夹，glfw和glew都需要，第二，链接器\常规\附加库目录，lib文件夹，第三，链接器\输入\附加依赖库，opengl32.lib glfw3.lib glew32s.lib</strong></p>
<h1 id="创建自己的引擎"><a href="#创建自己的引擎" class="headerlink" title="创建自己的引擎"></a>创建自己的引擎</h1><p>将文件修改为main作为主函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GLEW_STATIC</span></span><br></pre></td></tr></table></figure>
<p>这个注意小心拼写错误，本人搞了几小时</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="声明版本号"><a href="#声明版本号" class="headerlink" title="声明版本号"></a>声明版本号</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glfwInit</span>();</span><br><span class="line">  <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span><br></pre></td></tr></table></figure>
<p>MacOSX系统加上这一句<br>以上是初始化Glfw，说明我们要使用的OPENGL版本是3.3，我们同样明确告诉GLFW我们使用的是核心模式(Core-profile)。明确告诉GLFW我们需要使用核心模式意味着我们只能使用OpenGL功能的一个子集。</p>
<h3 id="创建窗口指针"><a href="#创建窗口指针" class="headerlink" title="创建窗口指针"></a>创建窗口指针</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;LearnOPENGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//前两个参数代表生成窗口大小</span></span><br></pre></td></tr></table></figure>
<h3 id="接下来进行GLFW的初始化"><a href="#接下来进行GLFW的初始化" class="headerlink" title="接下来进行GLFW的初始化"></a>接下来进行GLFW的初始化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;GLFW窗口初始化失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();<span class="comment">//程序终止函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(window);</span><br></pre></td></tr></table></figure>
<h3 id="然后是GLEW的初始化"><a href="#然后是GLEW的初始化" class="headerlink" title="然后是GLEW的初始化"></a>然后是GLEW的初始化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">glewExperimental = GL_TRUE;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;GLEW初始化失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="确定渲染窗口"><a href="#确定渲染窗口" class="headerlink" title="确定渲染窗口"></a>确定渲染窗口</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>);<span class="comment">//渲染窗口大小</span></span><br><span class="line"><span class="built_in">glfwSetFramebufferSizeCallback</span>(window,framebuffer_size_callback);<span class="comment">//注册函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>framebuffer_size_callback自定义函数注册到当窗口大小改变的事件中能及时反映</p>
<h3 id="确定基本架构"><a href="#确定基本架构" class="headerlink" title="确定基本架构"></a>确定基本架构</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(!<span class="built_in">glfwWindowShouldClose</span>(window))&#123;</span><br><span class="line">    <span class="comment">//输入</span></span><br><span class="line">    <span class="comment">//渲染指令</span></span><br><span class="line">    <span class="comment">//检查并调用事件，交换缓冲</span></span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);<span class="comment">//进行屏幕缓冲</span></span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();<span class="comment">//检查函数有没有触发事件	</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="清理缓冲区颜色"><a href="#清理缓冲区颜色" class="headerlink" title="清理缓冲区颜色"></a>清理缓冲区颜色</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);<span class="comment">//来设置清空屏幕所用的颜色,表示清除板的颜色</span></span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);<span class="comment">//清除颜色缓冲之后</span></span><br></pre></td></tr></table></figure>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">processInput</span>(window)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//输入</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) &#123;</span><br><span class="line">    <span class="built_in">glfwSetWindowShouldClose</span>(window, GLFW_TRUE);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GLEW_STATIC</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">glfwInit</span>();</span><br><span class="line">  <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line">  <span class="comment">//glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);MacOSX系统加上这一句</span></span><br><span class="line">  <span class="comment">//以上是初始化Glfw，说明我们要使用的OPENGL版本是3.3，我们同样明确告诉GLFW我们使用的是核心模式(Core-profile)。明确告诉GLFW我们需要使用核心模式意味着我们只能使用OpenGL功能的一个子集。</span></span><br><span class="line"></span><br><span class="line">  GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;LearnOPENGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//前两个参数代表生成窗口大小</span></span><br><span class="line">  <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;GLFW窗口初始化失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();<span class="comment">//程序终止函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">  <span class="comment">//GLFW初始化</span></span><br><span class="line">  glewExperimental = GL_TRUE;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;GLEW初始化失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//Glew的初始化</span></span><br><span class="line">  <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>);<span class="comment">//渲染窗口大小</span></span><br><span class="line">  <span class="built_in">glfwSetFramebufferSizeCallback</span>(window,framebuffer_size_callback);<span class="comment">//注册函数</span></span><br><span class="line">  <span class="keyword">while</span>(!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//输入</span></span><br><span class="line">    <span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//渲染指令</span></span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);<span class="comment">//来设置清空屏幕所用的颜色,表示清除板的颜色</span></span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);<span class="comment">//清除颜色缓冲之后</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查并调用事件，交换缓冲</span></span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);<span class="comment">//进行屏幕缓冲</span></span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();<span class="comment">//检查函数有没有触发事件</span></span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">glfwTerminate</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//输入</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) &#123;</span><br><span class="line">    <span class="built_in">glfwSetWindowShouldClose</span>(window, GLFW_TRUE);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL学习之路之三角形绘制</title>
    <url>/2021/11/02/OpenGL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E4%B8%89%E8%A7%92%E5%BD%A2%E7%BB%98%E5%88%B6/</url>
    <content><![CDATA[<p><strong>先从几何阶段取出顶点转换成vbo转到vao如果有重复顶点可以转到EBo<br>openGL是一个状态机只能运行context的状态只能放一个vao<br>状态机中必须要一个vao</strong></p>
<h3 id="VAO"><a href="#VAO" class="headerlink" title="VAO"></a>VAO</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> VAO;</span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);<span class="comment">//注意</span></span><br></pre></td></tr></table></figure>
<h3 id="VBO"><a href="#VBO" class="headerlink" title="VBO"></a>VBO</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> VBO;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);<span class="comment">//一个缓冲ID生成一个VBO对象建立顶点缓冲对象</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);<span class="comment">//新创建的缓冲绑定到GL_ARRAY_BUFFER目标</span></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);<span class="comment">//它会把之前定义的顶点数据复制到缓冲的内存中</span></span><br></pre></td></tr></table></figure>
<p>一定要绑定顶点数组</p>
<h3 id="shader"><a href="#shader" class="headerlink" title="shader"></a>shader</h3><p>顶点着色器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> vertexShader;</span><br><span class="line">vertexShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);<span class="comment">//由于我们正在创建一个顶点着色器，传递的参数是GL_VERTEX_SHADER</span></span><br><span class="line"><span class="built_in">glShaderSource</span>(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);<span class="comment">//这个着色器源码附加到着色器对象上</span></span><br><span class="line"><span class="built_in">glCompileShader</span>(vertexShader);<span class="comment">//编译着色器</span></span><br></pre></td></tr></table></figure>
<p>片段着色器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> fragmentShader;</span><br><span class="line">fragmentShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line"><span class="built_in">glShaderSource</span>(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glCompileShader</span>(fragmentShader);</span><br></pre></td></tr></table></figure>
<p>着色器程序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> shaderProgram;</span><br><span class="line">shaderProgram = <span class="built_in">glCreateProgram</span>();<span class="comment">//建立着色器程序对象</span></span><br><span class="line"><span class="built_in">glAttachShader</span>(shaderProgram, vertexShader);</span><br><span class="line"><span class="built_in">glAttachShader</span>(shaderProgram, fragmentShader);<span class="comment">//附加着色器</span></span><br><span class="line"><span class="built_in">glLinkProgram</span>(shaderProgram);<span class="comment">//连接着色器</span></span><br><span class="line"><span class="built_in">glDeleteShader</span>(vertexShader);<span class="comment">//着色器对象链接到程序对象以后，记得删除着色器对象，我们不再需要它们了</span></span><br><span class="line"><span class="built_in">glDeleteShader</span>(fragmentShader);</span><br></pre></td></tr></table></figure>
<p>序列化数据，可以得到数据的属性，是uv图片还是顶点信息</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>


<p>EBO的使用<br>需要加人索引<br>unsigned int indices[] &#x3D; { &#x2F;&#x2F; 注意索引从0开始!<br>    0, 1, 3, &#x2F;&#x2F; 第一个三角形<br>    1, 2, 3  &#x2F;&#x2F; 第二个三角形<br>};来确定三角形<br>放发与VBO类似当有点点区别<br>绑定缓存时GL_ELEMENT_ARRAY_BUFFER，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br></pre></td></tr></table></figure>
<p>绑定缓存数据的是索引值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure>
<p>在具体绘画过程中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);<span class="comment">//这是vao没有的</span></span><br></pre></td></tr></table></figure>
<p>用的函数也是和VAO绘制有区别的<br>三角形不用EBO的代码</p>
<p>四边形代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GLEW_STATIC</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CheckCompileShaderSuccess</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> vertexShader)</span></span>;<span class="comment">//检查着色器是否编译成功</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CheckLinkShaderSuccess</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> shaderProgram)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//float vertices[] = &#123;</span></span><br><span class="line"><span class="comment">//  -0.5f, -0.5f, 0.0f,</span></span><br><span class="line"><span class="comment">//   0.5f, -0.5f, 0.0f,</span></span><br><span class="line"><span class="comment">//   0.0f,  0.5f, 0.0f</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">  <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右上角</span></span><br><span class="line">  <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">  <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下角</span></span><br><span class="line">  <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// 左上角</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> indices[] = &#123; <span class="comment">// 注意索引从0开始! </span></span><br><span class="line">  <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="comment">// 第一个三角形</span></span><br><span class="line">  <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment">// 第二个三角形</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* vertexShaderSource =</span><br><span class="line"><span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="string">&quot;layout(location = 0) in vec3 aPos;\n&quot;</span></span><br><span class="line"><span class="string">&quot;void main()&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);&#125;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* fragmentShaderSource =</span><br><span class="line"><span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="string">&quot;out vec4 FragColor;\n;&quot;</span></span><br><span class="line"><span class="string">&quot;void main()&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;    FragColor=vec4(1.0f,0.5f,0.2f,1.0f);&#125;\n&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">glfwInit</span>();</span><br><span class="line">  <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line">  <span class="comment">//glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);MacOSX系统加上这一句</span></span><br><span class="line">  <span class="comment">//以上是初始化Glfw，说明我们要使用的OPENGL版本是3.3，我们同样明确告诉GLFW我们使用的是核心模式(Core-profile)。明确告诉GLFW我们需要使用核心模式意味着我们只能使用OpenGL功能的一个子集。</span></span><br><span class="line"></span><br><span class="line">  GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;LearnOPENGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//前两个参数代表生成窗口大小</span></span><br><span class="line">  <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;GLFW窗口初始化失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();<span class="comment">//程序终止函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">  <span class="comment">//GLFW初始化</span></span><br><span class="line">  glewExperimental = GL_TRUE;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;GLEW初始化失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//Glew的初始化</span></span><br><span class="line">  <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>);<span class="comment">//渲染窗口大小</span></span><br><span class="line">  <span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);<span class="comment">//注册函数</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> VAO;</span><br><span class="line">  <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">  <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">  <span class="comment">//顶点数据绑定</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> VBO;</span><br><span class="line">  <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);<span class="comment">//一个缓冲ID生成一个VBO对象建立顶点缓冲对象</span></span><br><span class="line">  <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);<span class="comment">//新创建的缓冲绑定到GL_ARRAY_BUFFER目标</span></span><br><span class="line">  <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);<span class="comment">//它会把之前定义的顶点数据复制到缓冲的内存中</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">unsigned</span> EBO;</span><br><span class="line">  <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;EBO);</span><br><span class="line">  <span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">  <span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//顶点着色器</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> vertexShader;</span><br><span class="line">  vertexShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);<span class="comment">//由于我们正在创建一个顶点着色器，传递的参数是GL_VERTEX_SHADER</span></span><br><span class="line">  <span class="built_in">glShaderSource</span>(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);<span class="comment">//这个着色器源码附加到着色器对象上</span></span><br><span class="line">  <span class="built_in">glCompileShader</span>(vertexShader);<span class="comment">//编译着色器</span></span><br><span class="line">  <span class="built_in">CheckCompileShaderSuccess</span>(vertexShader);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//片段着色器</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> fragmentShader;</span><br><span class="line">  fragmentShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line">  <span class="built_in">glShaderSource</span>(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">glCompileShader</span>(fragmentShader);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//着色器程序</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> shaderProgram;</span><br><span class="line">  shaderProgram = <span class="built_in">glCreateProgram</span>();<span class="comment">//建立着色器程序对象</span></span><br><span class="line">  <span class="built_in">glAttachShader</span>(shaderProgram, vertexShader);</span><br><span class="line">  <span class="built_in">glAttachShader</span>(shaderProgram, fragmentShader);<span class="comment">//附加着色器</span></span><br><span class="line">  <span class="built_in">glLinkProgram</span>(shaderProgram);<span class="comment">//连接着色器</span></span><br><span class="line">  <span class="built_in">CheckLinkShaderSuccess</span>(shaderProgram);</span><br><span class="line">  <span class="built_in">glDeleteShader</span>(vertexShader);<span class="comment">//着色器对象链接到程序对象以后，记得删除着色器对象，我们不再需要它们了</span></span><br><span class="line">  <span class="built_in">glDeleteShader</span>(fragmentShader);</span><br><span class="line">  <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//输入</span></span><br><span class="line">    <span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//渲染指令</span></span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);<span class="comment">//来设置清空屏幕所用的颜色,表示清除板的颜色</span></span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);<span class="comment">//清除颜色缓冲之后</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">glUseProgram</span>(shaderProgram);<span class="comment">//调用着色器</span></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">    <span class="comment">//glDrawArrays(GL_TRIANGLES, 0, 3);</span></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(EBO);</span><br><span class="line">    <span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);<span class="comment">//这是vao没有的</span></span><br><span class="line">    <span class="comment">//检查并调用事件，交换缓冲</span></span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);<span class="comment">//进行屏幕缓冲</span></span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();<span class="comment">//检查函数有没有触发事件</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">glfwTerminate</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//输入</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) &#123;</span><br><span class="line">    <span class="built_in">glfwSetWindowShouldClose</span>(window, GLFW_TRUE);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CheckCompileShaderSuccess</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> vertexShader)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//检查着色器是否编译成功</span></span><br><span class="line">  <span class="type">int</span> success;</span><br><span class="line">  <span class="type">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">  <span class="built_in">glGetShaderiv</span>(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">  <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">    <span class="built_in">glGetShaderInfoLog</span>(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CheckLinkShaderSuccess</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> shaderProgram)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//检查shaderProgram连接成功</span></span><br><span class="line">  <span class="type">int</span> success;</span><br><span class="line">  <span class="type">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">  <span class="built_in">glGetProgramiv</span>(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line">  <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">    <span class="built_in">glGetProgramInfoLog</span>(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::Program::Link_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/11/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>全景图传输</title>
    <url>/2022/03/21/%E5%85%A8%E6%99%AF%E5%9B%BE%E4%BC%A0%E8%BE%93/</url>
    <content><![CDATA[<h1 id="全景图"><a href="#全景图" class="headerlink" title="全景图"></a>全景图</h1><h2 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h2><h3 id="将全景图转变为Byte数组"><a href="#将全景图转变为Byte数组" class="headerlink" title="将全景图转变为Byte数组"></a>将全景图转变为Byte数组</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Camera.main.RenderToCubemap(cm);</span><br><span class="line">texture2D = <span class="keyword">new</span> Texture2D(width, hight);</span><br><span class="line">texture2D.SetPixels(cm.GetPixels(CubemapFace.NegativeZ));</span><br><span class="line">texture2D.Apply();</span><br><span class="line">byt = texture2D.EncodeToPNG();</span><br></pre></td></tr></table></figure>

<h3 id="将Byte数组变成全景图"><a href="#将Byte数组变成全景图" class="headerlink" title="将Byte数组变成全景图"></a>将Byte数组变成全景图</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">texture2DFix.LoadImage(byt);</span><br><span class="line">texture2DFix.Apply</span><br><span class="line">cm1.SetPixels(texture2DFix.GetPixels(), CubemapFace.PositiveZ);</span><br><span class="line">cm1.Apply();</span><br></pre></td></tr></table></figure>

<h3 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a>网络传输</h3><p>名字设为 I P 地址名</p>
<p>1.发送连接信号并在服务器创建位置</p>
<h3 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; width + <span class="number">1</span>; i++) Array.Copy(cmmcolors, width * (width - i), ReCmmcolors, width * (i - <span class="number">1</span>), width);<span class="comment">//上下翻转</span></span><br></pre></td></tr></table></figure>

<h3 id="协议处理"><a href="#协议处理" class="headerlink" title="协议处理"></a>协议处理</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">print(point.Right.Length);</span><br><span class="line">      <span class="built_in">string</span> str = pos.x.ToString() + <span class="string">&quot; &quot;</span> + pos.y.ToString() + <span class="string">&quot; &quot;</span> + pos.z.ToString() + <span class="string">&quot; &quot;</span> + <span class="string">&quot;PX &quot;</span>;</span><br><span class="line">      <span class="built_in">byte</span>[] bytstr= System.Text.Encoding.UTF8.GetBytes(str);<span class="comment">//单独编译</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">byte</span>[] sendByt = <span class="keyword">new</span> <span class="built_in">byte</span>[point.Right.Length+ bytstr.Length];</span><br><span class="line">      bytstr.CopyTo(sendByt, <span class="number">0</span>);</span><br><span class="line">      point.Right.CopyTo(sendByt, bytstr.Length);<span class="comment">//合并编码</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"> Texture2D = <span class="keyword">new</span> Texture2D(width, width);</span><br><span class="line"> <span class="built_in">byte</span>[] image = sendByt.Skip(bytstr.Length).ToArray();<span class="comment">//需要using System.Linq;//截取字节</span></span><br><span class="line"> print(image.Length);</span><br><span class="line"><span class="comment">// Array.Reverse(image);//可以使图像旋转180度</span></span><br><span class="line"> print(Texture2D.LoadImage(image));</span><br><span class="line"> Texture2D.Apply();<span class="number">5.4</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>

<h3 id="获取本地-I-P-地址"><a href="#获取本地-I-P-地址" class="headerlink" title="获取本地 I P 地址"></a>获取本地 I P 地址</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetLocalIp</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment"><span class="doctag">///</span>获取本地的IP地址</span></span><br><span class="line">       <span class="built_in">string</span> AddressIP = <span class="built_in">string</span>.Empty;</span><br><span class="line">       <span class="keyword">foreach</span> (IPAddress _IPAddress <span class="keyword">in</span> Dns.GetHostEntry(Dns.GetHostName()).AddressList)</span><br><span class="line">       &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (_IPAddress.AddressFamily.ToString() == <span class="string">&quot;InterNetwork&quot;</span>)</span><br><span class="line">           &#123;</span><br><span class="line"></span><br><span class="line">               AddressIP = _IPAddress.ToString();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> AddressIP;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="基本网络架构"><a href="#基本网络架构" class="headerlink" title="基本网络架构"></a>基本网络架构</h2><h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><p><img src="https://pica.zhimg.com/80/v2-e5925782976fc81a36cca0f889cec93a_720w.png"></p>
<h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CloudService</span>()</span> &#123;</span><br><span class="line">       msgHandle = <span class="keyword">new</span> MsgHandle();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">NewIndex</span>()</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (conns == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; conns.Length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (conns[i] == <span class="literal">null</span>) &#123;</span><br><span class="line">               conns[i] = <span class="keyword">new</span> Conn();</span><br><span class="line">               <span class="keyword">return</span> i;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (conns[i].isUse == <span class="literal">false</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> i;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ServiceStart</span>(<span class="params"><span class="built_in">string</span> host, <span class="built_in">int</span> port</span>)</span> &#123;</span><br><span class="line">       conns = <span class="keyword">new</span> Conn[maxConn];</span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; maxConn; i++) &#123;</span><br><span class="line">           conns[i] = <span class="keyword">new</span> Conn();</span><br><span class="line">       &#125;</span><br><span class="line">       Listerfd = <span class="keyword">new</span> Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);</span><br><span class="line">       IPAddress ipAdr = IPAddress.Parse(host);</span><br><span class="line">       IPEndPoint ipEp = <span class="keyword">new</span> IPEndPoint(ipAdr, port);</span><br><span class="line">       Listerfd.Bind(ipEp);</span><br><span class="line">       Listerfd.Listen(maxConn);</span><br><span class="line">       Listerfd.BeginAccept(AcceptCb, <span class="literal">null</span>);</span><br><span class="line">       status = <span class="literal">true</span>;</span><br><span class="line">       NetCloudServerManager.instance.debug.text+=(<span class="string">&quot;\n&quot;</span>+<span class="string">&quot;[服务器]启动成功&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Accept-Cb-异步监听"><a href="#Accept-Cb-异步监听" class="headerlink" title="Accept Cb 异步监听"></a>Accept Cb 异步监听</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AcceptCb</span>(<span class="params">IAsyncResult ar</span>)</span> &#123;</span><br><span class="line">        Socket socket = Listerfd.EndAccept(ar);<span class="comment">//要放在try外面</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//接收客户端</span></span><br><span class="line">            <span class="built_in">int</span> index = NewIndex();</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                socket.Close();</span><br><span class="line">                Debug.Log(<span class="string">&quot;[警告]连接已满&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Conn conn = conns[index];</span><br><span class="line">                conn.Init(socket);</span><br><span class="line">                <span class="built_in">string</span> host = conn.GetAdress();</span><br><span class="line">                Debug.Log(<span class="string">&quot;客户端连接:[&quot;</span> + host + <span class="string">&quot;] conn池ID:&quot;</span> + index);</span><br><span class="line">                conn.socket.BeginReceive(conn.readBuff, conn.buffCount, conn.BuffRemain(), SocketFlags.None, ReciveCb, conn);<span class="comment">//接收的同时调用ReciveCb回调函数</span></span><br><span class="line">            &#125;</span><br><span class="line">            Listerfd.BeginAccept(AcceptCb, <span class="literal">null</span>);<span class="comment">//再次调用AcceprCb回调函数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;AccpetCb 失败:&quot;</span> + e.Message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>出现莫名其妙的问题，等待异步需要放在 try 外面，不然会抛出 AcceptCb只能在主线程调用，要我放在awake和start中</p>
<h3 id="Recive-Cb异步接收"><a href="#Recive-Cb异步接收" class="headerlink" title="Recive Cb异步接收"></a>Recive Cb异步接收</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReciveCb</span>(<span class="params">IAsyncResult ar</span>)</span> &#123;</span><br><span class="line">        Conn conn = (Conn)ar.AsyncState;<span class="comment">//这个AsyncState就是上面那个BeginRecive函数里面最后一个参数</span></span><br><span class="line">        <span class="keyword">lock</span> (conn) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">int</span> count = conn.socket.EndReceive(ar);<span class="comment">//返回接收的字节数</span></span><br><span class="line">                                                       <span class="comment">//没有信息就关闭</span></span><br><span class="line">                <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    Debug.Log(<span class="string">&quot;收到[&quot;</span> + conn.GetAdress() + <span class="string">&quot;] 断开连接&quot;</span>);</span><br><span class="line">                    conn.Close();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                conn.buffCount += count;</span><br><span class="line">                ProcessData(conn);</span><br><span class="line">               </span><br><span class="line">                <span class="comment">//继续接收</span></span><br><span class="line">                conn.socket.BeginReceive(conn.readBuff, conn.buffCount, conn.BuffRemain(), SocketFlags.None, ReciveCb, conn);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Debug.Log(<span class="string">&quot;Recive失败&quot;</span> + e.Message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ProcessData</span>(<span class="params">Conn conn</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//小于字节长度</span></span><br><span class="line">        <span class="keyword">if</span> (conn.buffCount &lt; <span class="keyword">sizeof</span>(Int32)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Debug.Log(<span class="string">&quot;接收到了 &quot;</span> + conn.buffCount + <span class="string">&quot; 个字节&quot;</span>);</span><br><span class="line">        Array.Copy(conn.readBuff, conn.lenByte, <span class="keyword">sizeof</span>(Int32));</span><br><span class="line">        conn.msgLength = BitConverter.ToInt32(conn.lenByte, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//小于最小要求长度则返回表示未接收完全</span></span><br><span class="line">        <span class="keyword">if</span> (conn.buffCount &lt; conn.msgLength + <span class="keyword">sizeof</span>(Int32)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里接收信息有个细节，因为之前发送回来的信息又被加了一次长度，相当于要把他所有的信息接收完了</span></span><br><span class="line">        <span class="comment">//才算接收成功，然后再把前面的sizeof(Int32)去掉，剩下的就是带长度的信息了</span></span><br><span class="line">        ProtocolByte proto = <span class="keyword">new</span> ProtocolByte();</span><br><span class="line">        ProtocolByte protoStr = <span class="keyword">new</span> ProtocolByte();</span><br><span class="line">        ProtocolByte protocol = proto.Decode(conn.readBuff, <span class="keyword">sizeof</span>(Int32), conn.msgLength) <span class="keyword">as</span> ProtocolByte;</span><br><span class="line">        protoStr.AddString(conn.GetAdress());</span><br><span class="line">        protocol.bytes = protoStr.bytes.Concat(protocol.bytes).ToArray();</span><br><span class="line">        <span class="keyword">lock</span>(msgHandle.msgList) &#123;</span><br><span class="line">            msgHandle.msgList.Add(protocol);</span><br><span class="line">        &#125;</span><br><span class="line">        Debug.Log( protocol.GetDesc());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//清除已处理的消息</span></span><br><span class="line">        <span class="built_in">int</span> count = conn.buffCount - conn.msgLength - <span class="keyword">sizeof</span>(Int32);</span><br><span class="line">        Array.Copy(conn.readBuff, <span class="keyword">sizeof</span>(Int32) + conn.msgLength, conn.readBuff, <span class="number">0</span>, count);</span><br><span class="line">        conn.buffCount = count;</span><br><span class="line">        <span class="comment">//如果还有多余信息就继续处理</span></span><br><span class="line">        <span class="keyword">if</span> (conn.buffCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ProcessData(conn);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Conn类"><a href="#Conn类" class="headerlink" title="Conn类"></a>Conn类</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Conn</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">int</span> BUFFER_SIZE = <span class="number">16384</span>;</span><br><span class="line">    <span class="keyword">public</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isUse = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">byte</span>[] readBuff = <span class="keyword">new</span> <span class="built_in">byte</span>[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> buffCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> Int32 msgLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">byte</span>[] lenByte = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="keyword">sizeof</span>(Int32)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ProtocolByte assistProtolByte;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Conn</span>()</span> &#123;</span><br><span class="line">        readBuff = <span class="keyword">new</span> <span class="built_in">byte</span>[BUFFER_SIZE];</span><br><span class="line">        assistProtolByte = <span class="keyword">new</span> ProtocolByte();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params">Socket socket</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        isUse = <span class="literal">true</span>;</span><br><span class="line">        buffCount = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">BuffRemain</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BUFFER_SIZE - buffCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetAdress</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isUse) &#123; <span class="keyword">return</span> <span class="string">&quot;无法获取地址&quot;</span>; &#125;</span><br><span class="line">        <span class="keyword">return</span> socket.RemoteEndPoint.ToString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Close</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isUse) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;[断开连接]&quot;</span> + GetAdress());</span><br><span class="line">        socket.Close();</span><br><span class="line">        isUse = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">SendMsg</span>(<span class="params">ProtocolBase protol</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> proName = protol.GetName(); ;</span><br><span class="line">        <span class="keyword">return</span> SendMsg(protol, proName);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">SendMsg</span>(<span class="params">ProtocolBase protol, <span class="built_in">string</span> protolName</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        ProtocolByte protocolByte1 = <span class="keyword">new</span> ProtocolByte();</span><br><span class="line">        protocolByte1.AddString(protolName);</span><br><span class="line">        <span class="built_in">byte</span>[] protolNameByte = protocolByte1.bytes;</span><br><span class="line">        <span class="built_in">byte</span>[] b = protol.Encode();</span><br><span class="line">        <span class="built_in">byte</span>[] len1 = BitConverter.GetBytes(protolNameByte.Length + b.Length);</span><br><span class="line">        <span class="built_in">byte</span>[] sendByte = len1.Concat(protolNameByte).Concat(b).ToArray();</span><br><span class="line">        socket.Send(sendByte);</span><br><span class="line">        Debug.Log(<span class="string">&quot;sendByte &quot;</span> + sendByte.Length);</span><br><span class="line">        Debug.Log(<span class="string">&quot;sendBytes &quot;</span> + GetDesc(sendByte));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="built_in">string</span> <span class="title">GetDesc</span>(<span class="params"><span class="built_in">byte</span>[] bytes</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="literal">null</span>) <span class="keyword">return</span> str;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; bytes.Length; i++) &#123;</span><br><span class="line">            <span class="built_in">int</span> b = (<span class="built_in">int</span>)bytes[i];</span><br><span class="line">            str += b.ToString() + <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消息处理类"><a href="#消息处理类" class="headerlink" title="消息处理类"></a>消息处理类</h3><p>区别于客户端消息类，处理消息时，需要在接收的消息中加入传来的消息IP地址防止找不到回溯玩家。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MsgHandle</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> num = NetCloudServerManager.instance.HandleMsgNum;</span><br><span class="line">    Dictionary&lt;<span class="built_in">string</span>, ProtocolBase&gt; oneMessager = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, ProtocolBase&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;ProtocolBase&gt; msgList = <span class="keyword">new</span> List&lt;ProtocolBase&gt;();</span><br><span class="line"></span><br><span class="line">    ProtocolByte assistProtocol;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Running</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(msgList.Count&gt;<span class="number">0</span>&amp;&amp;num&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            num--;</span><br><span class="line">            <span class="comment">//处理长度和将协议分开</span></span><br><span class="line">            assistProtocol = msgList[<span class="number">0</span>] <span class="keyword">as</span> ProtocolByte;</span><br><span class="line">            <span class="keyword">if</span>(assistProtocol==<span class="literal">null</span>) &#123;</span><br><span class="line">                Debug.Log(<span class="string">&quot;消息转化失败&quot;</span>);</span><br><span class="line">                <span class="keyword">lock</span> (msgList) &#123;</span><br><span class="line">                    msgList.RemoveAt(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">int</span> start = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">string</span> IpAddress = assistProtocol.GetString(start, <span class="keyword">ref</span> start);</span><br><span class="line">            <span class="built_in">string</span> protocolName=assistProtocol.GetString(start, <span class="keyword">ref</span> start);</span><br><span class="line">            <span class="comment">//int protocolNameLen=System.Text.Encoding.UTF8.GetBytes(protocolName).Length + sizeof(Int32);</span></span><br><span class="line">            <span class="keyword">switch</span> (protocolName) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;ProtocolCubeTexture&quot;</span>:</span><br><span class="line">                    ProtocolCubeTexture protocolCubeTexture = <span class="keyword">new</span> ProtocolCubeTexture();</span><br><span class="line">                    ProtocolCubeTexture aprotocol = protocolCubeTexture.Decode(assistProtocol.bytes, start, assistProtocol.bytes.Length) <span class="keyword">as</span> ProtocolCubeTexture;</span><br><span class="line">                    <span class="keyword">if</span> (aprotocol == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">                    PointMessage point = <span class="keyword">new</span> PointMessage();</span><br><span class="line">                    point.ResolveToPointMessage(aprotocol.Coord, aprotocol.CubemapFace, aprotocol.srcTexture);</span><br><span class="line">                    NetCloudServerManager.instance.PM.Add(point);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;Start&quot;</span>:</span><br><span class="line">                    StartProcessData(assistProtocol, start, IpAddress);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">lock</span>(msgList) &#123;</span><br><span class="line">                msgList.RemoveAt(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//ProtocolCubeTexture protocol = msgList[0] as ProtocolCubeTexture;</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        num = NetCloudServerManager.instance.HandleMsgNum;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">StartProcessData</span>(<span class="params">ProtocolByte protocol,<span class="built_in">int</span> start,<span class="built_in">string</span> SendIPAddress</span>)</span> &#123;</span><br><span class="line">        ProtocolStr protocolStr = <span class="keyword">new</span> ProtocolStr();</span><br><span class="line">        Debug.Log(<span class="string">&quot;start&quot;</span> + start + <span class="string">&quot; lenth&quot;</span> + assistProtocol.bytes.Length);</span><br><span class="line">        ProtocolStr protocolstr = protocolStr.Decode(assistProtocol.bytes, start, assistProtocol.bytes.Length-start) <span class="keyword">as</span> ProtocolStr;</span><br><span class="line">        NetCloudServerManager.instance.debug.text += (<span class="string">&quot;\n&quot;</span> + protocolstr.str);</span><br><span class="line">        <span class="built_in">string</span>[] CoordStrs = protocolstr.str.Split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        <span class="built_in">float</span>[] Coord = <span class="keyword">new</span> <span class="built_in">float</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">            Coord[i] = <span class="built_in">float</span>.Parse(CoordStrs[i]);</span><br><span class="line">        Camera camm = NetCloudServerManager.instance.cam;</span><br><span class="line">        camm.transform.position = <span class="keyword">new</span> Vector3( Coord[<span class="number">0</span>], Coord[<span class="number">1</span>], Coord[<span class="number">2</span>]);</span><br><span class="line">        PointMessage point = <span class="keyword">new</span> PointMessage();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ( camm.RenderToCubemap(point.cubemap)) &#123;</span><br><span class="line">            <span class="built_in">int</span> index = <span class="number">-1</span>;</span><br><span class="line">            Conn[] conns = NetCloudServerManager.cs.conns;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; conns.Length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (conns[i] == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (!conns[i].isUse)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(conns[i].GetAdress()==SendIPAddress) &#123;</span><br><span class="line">                    index = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//print(&quot; 将消息传播&quot; + conns[i].GetAdress());</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="built_in">int</span> width = NetCloudServerManager.instance.width;</span><br><span class="line">            ProtocolCubeTexture protocolCube = <span class="keyword">new</span> ProtocolCubeTexture();</span><br><span class="line">            protocolCube.srcTexture = <span class="keyword">new</span> Texture2D(width, width);</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">                protocolCube.Coord[i] = <span class="built_in">int</span>.Parse(CoordStrs[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++) &#123;</span><br><span class="line">                protocolCube.CubemapFace = i;</span><br><span class="line">                protocolCube.srcTexture.SetPixels(point.cubemap.GetPixels((CubemapFace)i));</span><br><span class="line">                protocolCube.srcTexture.Apply();</span><br><span class="line">                conns[index].SendMsg(protocolCube);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            NetCloudServerManager.instance.debug.text+= (<span class="string">&quot;\n&quot;</span> + protocolstr.str+<span class="string">&quot;渲染失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PointMessage-点消息类"><a href="#PointMessage-点消息类" class="headerlink" title="PointMessage 点消息类"></a>PointMessage 点消息类</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PointMessage</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Vector3 pos;</span><br><span class="line">    <span class="keyword">public</span> Cubemap cubemap;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">int</span> width;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PointMessage</span>()</span> &#123;</span><br><span class="line">        pos = Vector3.zero;</span><br><span class="line">        width = NetCloudServerManager.instance.width;</span><br><span class="line"></span><br><span class="line">        cubemap = <span class="keyword">new</span> Cubemap(width, TextureFormat.RGBA32, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="Connect-类"><a href="#Connect-类" class="headerlink" title="Connect 类"></a>Connect 类</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Connect</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Socket socket;</span><br><span class="line">    <span class="built_in">int</span> BUFFER_SIZE = NetCloudClientManager.instance.BUFFER_SIZE;</span><br><span class="line">    <span class="built_in">byte</span>[] readBuff ;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> buffCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Int32 msgLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">byte</span>[] lenByte = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="keyword">sizeof</span>(Int32)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ProtocolByte assistProtolByte;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MsgHandle msgHandle = <span class="keyword">new</span> MsgHandle();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">enum</span> Status &#123;</span><br><span class="line">        None,Connect</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> Status status = Status.None;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> width = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span>  <span class="title">Connect</span>()</span> &#123;</span><br><span class="line">        readBuff = <span class="keyword">new</span> <span class="built_in">byte</span>[BUFFER_SIZE];</span><br><span class="line">        assistProtolByte = <span class="keyword">new</span> ProtocolByte();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Connetion</span>(<span class="params"><span class="built_in">string</span> host, <span class="built_in">int</span> port</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//清理text</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Socket</span></span><br><span class="line">            socket = <span class="keyword">new</span> Socket(AddressFamily.InterNetwork,</span><br><span class="line">            SocketType.Stream, ProtocolType.Tcp);</span><br><span class="line">            <span class="keyword">if</span> (host.Length == <span class="number">0</span>) &#123;</span><br><span class="line">                host = <span class="string">&quot;192.168.50.142&quot;</span>;</span><br><span class="line">                port = <span class="number">1234</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            socket.Connect(host, port);</span><br><span class="line">            status = Status.Connect;</span><br><span class="line">            NetCloudClientManager.instance.debug.text += (<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;客户端地址&quot;</span> + socket.LocalEndPoint.ToString());</span><br><span class="line">            socket.BeginReceive(readBuff, buffCount, BUFFER_SIZE - buffCount, SocketFlags.None, ReceiveCb, readBuff);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            NetCloudClientManager.instance.debug.text += (<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;客户端失败&quot;</span>+e.Message );</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// clientText.text = &quot;客户端地址&quot; + socket.LocalEndPoint.ToString();</span></span><br><span class="line">        <span class="comment">//Recv</span></span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ReceiveCb</span>(<span class="params">IAsyncResult ar</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//count是接收数据的大小</span></span><br><span class="line">            <span class="built_in">int</span> count = socket.EndReceive(ar);</span><br><span class="line">            buffCount += count;</span><br><span class="line">            ProcessData();</span><br><span class="line">            socket.BeginReceive(readBuff,buffCount , BUFFER_SIZE-buffCount, SocketFlags.None, ReceiveCb, readBuff);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           <span class="comment">// recvText.text += &quot;连接已断开&quot;;</span></span><br><span class="line">            socket.Close();</span><br><span class="line">            status = Status.None;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ProcessData</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (buffCount &lt; <span class="keyword">sizeof</span>(Int32))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Array.Copy(readBuff, lenByte, <span class="keyword">sizeof</span>(Int32));</span><br><span class="line">        msgLength = BitConverter.ToInt32(lenByte, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (buffCount &lt; msgLength + <span class="keyword">sizeof</span>(Int32))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        ProtocolBase protocol = assistProtolByte.Decode(readBuff, <span class="keyword">sizeof</span>(Int32), msgLength);</span><br><span class="line">        <span class="keyword">lock</span>(msgHandle.msgList) &#123;</span><br><span class="line">            msgHandle.msgList.Add(protocol);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> count = buffCount - msgLength - <span class="keyword">sizeof</span>(Int32);</span><br><span class="line">        Array.Copy(readBuff, <span class="keyword">sizeof</span>(Int32) + msgLength, readBuff, <span class="number">0</span>, count);</span><br><span class="line">        buffCount = count;</span><br><span class="line">        <span class="keyword">if</span> (buffCount &gt; <span class="number">0</span>)</span><br><span class="line">            ProcessData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Close</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket.Close();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;关闭失败:&quot;</span> + e.Message);</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span>  <span class="title">SendMsg</span>(<span class="params"> ProtocolBase protol</span>)</span> &#123;    </span><br><span class="line">        <span class="built_in">string</span> proName = protol.GetName();  ;</span><br><span class="line">        <span class="keyword">return</span> SendMsg(protol, proName);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">SendMsg</span>(<span class="params">ProtocolBase protol,<span class="built_in">string</span> protolName</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (status != Status.Connect) &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;404 Not Found&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ProtocolByte protocolByte1 = <span class="keyword">new</span> ProtocolByte();</span><br><span class="line">        protocolByte1.AddString(protolName);</span><br><span class="line">        <span class="built_in">byte</span>[] protolNameByte = protocolByte1.bytes;</span><br><span class="line">        <span class="built_in">byte</span>[] b = protol.Encode();</span><br><span class="line">        <span class="built_in">byte</span>[] len1 = BitConverter.GetBytes(protolNameByte.Length + b.Length);</span><br><span class="line">        <span class="built_in">byte</span>[] sendByte = len1.Concat(protolNameByte).Concat(b).ToArray();</span><br><span class="line">        socket.Send(sendByte);</span><br><span class="line">        Debug.Log(GetStr(sendByte));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="built_in">string</span> <span class="title">GetStr</span>(<span class="params"><span class="built_in">byte</span>[] bytes</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="literal">null</span>) <span class="keyword">return</span> str;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; bytes.Length; i++) &#123;</span><br><span class="line">            <span class="built_in">int</span> b = (<span class="built_in">int</span>)bytes[i];</span><br><span class="line">            str += b.ToString() + <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 地址辅助方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetClientAddress</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> socket.LocalEndPoint.ToString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetLocalIp</span>()</span> &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span>获取本地的IP地址</span></span><br><span class="line">        <span class="built_in">string</span> AddressIP = <span class="built_in">string</span>.Empty;</span><br><span class="line">        <span class="keyword">foreach</span> (IPAddress _IPAddress <span class="keyword">in</span> Dns.GetHostEntry(Dns.GetHostName()).AddressList) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_IPAddress.AddressFamily.ToString() == <span class="string">&quot;InterNetwork&quot;</span>) &#123;</span><br><span class="line"></span><br><span class="line">                AddressIP = _IPAddress.ToString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> AddressIP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消息处理类-1"><a href="#消息处理类-1" class="headerlink" title="消息处理类"></a>消息处理类</h3><p>在处理消息队列时一定需要上lock</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MsgHandle</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> num = NetCloudClientManager.instance.HandleMsgNum;</span><br><span class="line">    <span class="keyword">public</span> List&lt;ProtocolBase&gt; msgList = <span class="keyword">new</span> List&lt;ProtocolBase&gt;();</span><br><span class="line"></span><br><span class="line">    ProtocolByte assistProtocol;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Running</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(msgList.Count&gt;<span class="number">0</span>&amp;&amp;num&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            num--;</span><br><span class="line">            <span class="comment">//处理长度和将协议分开</span></span><br><span class="line">            assistProtocol = msgList[<span class="number">0</span>] <span class="keyword">as</span> ProtocolByte;</span><br><span class="line">            <span class="keyword">if</span>(assistProtocol==<span class="literal">null</span>) &#123;</span><br><span class="line">                Debug.Log(<span class="string">&quot;消息转化失败&quot;</span>);</span><br><span class="line">                <span class="keyword">lock</span> (msgList) &#123;</span><br><span class="line">                    msgList.RemoveAt(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">string</span> protocolName=assistProtocol.GetName();</span><br><span class="line">            <span class="built_in">int</span> protocolNameLen=System.Text.Encoding.UTF8.GetBytes(protocolName).Length + <span class="keyword">sizeof</span>(Int32);</span><br><span class="line">            <span class="keyword">switch</span> (protocolName) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;ProtocolCubeTexture&quot;</span>:</span><br><span class="line">                    ProtocolCubeTexture protocolCubeTexture = <span class="keyword">new</span> ProtocolCubeTexture();</span><br><span class="line">                    ProtocolCubeTexture aprotocol = protocolCubeTexture.Decode(assistProtocol.bytes, protocolNameLen, assistProtocol.bytes.Length) <span class="keyword">as</span> ProtocolCubeTexture;</span><br><span class="line">                    <span class="keyword">if</span> (aprotocol == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">                    Vector3 pos = <span class="keyword">new</span> Vector3(aprotocol.Coord[<span class="number">0</span>], aprotocol.Coord[<span class="number">1</span>], aprotocol.Coord[<span class="number">2</span>]);</span><br><span class="line">                    PointMessage point = NetCloudClientManager.instance.PM.Find((PointMessage p) =&gt; p.pos.Equals(pos));</span><br><span class="line">                    <span class="keyword">if</span>(point==<span class="literal">null</span>) point = <span class="keyword">new</span> PointMessage();</span><br><span class="line">                    </span><br><span class="line">                    point.ResolveToPointMessage(aprotocol.Coord, aprotocol.CubemapFace, aprotocol.srcTexture);</span><br><span class="line">                    </span><br><span class="line">                    NetCloudClientManager.instance.PM.Add(point);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;Start&quot;</span>:</span><br><span class="line">                    ProtocolStr protocolStr = <span class="keyword">new</span> ProtocolStr();</span><br><span class="line">                    ProtocolStr protocolstr = protocolStr.Decode(assistProtocol.bytes, protocolNameLen, assistProtocol.bytes.Length) <span class="keyword">as</span> ProtocolStr;</span><br><span class="line">                    NetCloudClientManager.instance.debug.text += (<span class="string">&quot;\n&quot;</span> + protocolstr.str);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">lock</span>(msgList) &#123;</span><br><span class="line">                msgList.RemoveAt(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//ProtocolCubeTexture protocol = msgList[0] as ProtocolCubeTexture;</span></span><br><span class="line">        &#125;</span><br><span class="line">        num = NetCloudClientManager.instance.HandleMsgNum;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="PointMessage-点消息类-1"><a href="#PointMessage-点消息类-1" class="headerlink" title="PointMessage 点消息类"></a>PointMessage 点消息类</h3><p>区别于服务端，需要把相应的字节流变成texture，并将其贴到点消息的CubeMap上</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PointMessage</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Vector3 pos;</span><br><span class="line">    <span class="keyword">public</span> Cubemap cubemap;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">int</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span>[] FaceFlags ;</span><br><span class="line">    <span class="built_in">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PointMessage</span>()</span> &#123;</span><br><span class="line">        pos = Vector3.zero;</span><br><span class="line">        width = NetCloudClientManager.instance.width;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        FaceFlags = <span class="keyword">new</span> <span class="built_in">bool</span>[] &#123; <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span> &#125;;</span><br><span class="line">        cubemap = <span class="keyword">new</span> Cubemap(width, TextureFormat.RGBA32, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ResolveToPointMessage</span>(<span class="params"><span class="built_in">byte</span>[] byt </span>)</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> str = System.Text.Encoding.UTF8.GetString(byt);</span><br><span class="line">        <span class="built_in">string</span>[] strs = str.Split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        pos.x = <span class="built_in">float</span>.Parse(strs[<span class="number">0</span>]);</span><br><span class="line">        pos.y = <span class="built_in">float</span>.Parse(strs[<span class="number">1</span>]);</span><br><span class="line">        pos.z = <span class="built_in">float</span>.Parse(strs[<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">string</span> CF = strs[<span class="number">3</span>]; </span><br><span class="line">        <span class="built_in">int</span> bytCount = System.Text.Encoding.UTF8.GetBytes(pos.x.ToString() + <span class="string">&quot; &quot;</span> + pos.y.ToString() + <span class="string">&quot; &quot;</span> + pos.z.ToString() + <span class="string">&quot; &quot;</span> + CF + <span class="string">&quot; &quot;</span>).Length;</span><br><span class="line">        <span class="built_in">byte</span>[] image = byt.Skip(bytCount).ToArray();</span><br><span class="line">        <span class="keyword">switch</span> (CF) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;PX&quot;</span>: cubemap.SetPixels(ColorToCubemap(image), CubemapFace.PositiveX); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;NX&quot;</span>: cubemap.SetPixels(ColorToCubemap(image), CubemapFace.NegativeX); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;PY&quot;</span>: cubemap.SetPixels(ColorToCubemap(image), CubemapFace.PositiveY); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;NY&quot;</span>: cubemap.SetPixels(ColorToCubemap(image), CubemapFace.NegativeY); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;PZ&quot;</span>: cubemap.SetPixels(ColorToCubemap(image), CubemapFace.PositiveZ); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;NZ&quot;</span>: cubemap.SetPixels(ColorToCubemap(image), CubemapFace.NegativeZ); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cubemap.Apply();</span><br><span class="line">        size++;</span><br><span class="line">        <span class="comment">//Texture2DClient.LoadImage(image);</span></span><br><span class="line">        <span class="comment">//Texture2DClient.Apply();</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ResolveToPointMessage</span>(<span class="params"><span class="built_in">int</span>[] Coord,<span class="built_in">int</span> CubeMapFace,Texture2D texture</span>)</span> &#123;</span><br><span class="line">        pos.x = Coord[<span class="number">0</span>];</span><br><span class="line">        pos.y = Coord[<span class="number">1</span>];</span><br><span class="line">        pos.z = Coord[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">switch</span> (CubeMapFace) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: cubemap.SetPixels( texture.GetPixels(), CubemapFace.PositiveX); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: cubemap.SetPixels( texture.GetPixels(), CubemapFace.NegativeX); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: cubemap.SetPixels( texture.GetPixels(), CubemapFace.PositiveY); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: cubemap.SetPixels( texture.GetPixels(), CubemapFace.NegativeY); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>: cubemap.SetPixels( texture.GetPixels(), CubemapFace.PositiveZ); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>: cubemap.SetPixels( texture.GetPixels(), CubemapFace.NegativeZ); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Debug.Log(<span class="string">&quot;cubeface &quot;</span> + CubeMapFace);</span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">        FaceFlags[CubeMapFace] = <span class="literal">true</span>;</span><br><span class="line">        cubemap.Apply();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Color[] <span class="title">ColorToCubemap</span>(<span class="params"><span class="built_in">byte</span>[] byt</span>)</span> &#123;</span><br><span class="line">        Texture2D textureTest = <span class="keyword">new</span> Texture2D(width, width);</span><br><span class="line">        textureTest.LoadImage(byt);</span><br><span class="line">        textureTest.Apply();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> textureTest.GetPixels() ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="built_in">int</span>  <span class="title">GetSize</span>()</span> &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;FaceFlags.Length;i++) &#123; <span class="keyword">if</span> (FaceFlags[i]) size++; &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aa</span>()</span> &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;aaaaa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>个人理解：字节流协议和字符串流协议算是中间层协议，其他协议类可以聚合两个中间层协议进行编写。</p>
<h3 id="协议基类"><a href="#协议基类" class="headerlink" title="协议基类"></a>协议基类</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProtocolBase</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//解码器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> ProtocolBase <span class="title">Decode</span>(<span class="params"><span class="built_in">byte</span>[] readBuff,<span class="built_in">int</span> start,<span class="built_in">int</span> length</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProtocolBase();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//编码器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">byte</span>[] <span class="title">Encode</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">byte</span>[] &#123; &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">GetName</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Base&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">GetDesc</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字节流协议"><a href="#字节流协议" class="headerlink" title="字节流协议"></a>字节流协议</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProtocolByte</span> : <span class="title">ProtocolBase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">byte</span>[] bytes;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> ProtocolBase <span class="title">Decode</span>(<span class="params"><span class="built_in">byte</span>[] readBuff, <span class="built_in">int</span> start, <span class="built_in">int</span> length</span>)</span> &#123;</span><br><span class="line">        ProtocolByte proByte = <span class="keyword">new</span> ProtocolByte();</span><br><span class="line">        proByte.bytes = <span class="keyword">new</span> <span class="built_in">byte</span>[length];</span><br><span class="line">        Array.Copy(readBuff, start, proByte.bytes, <span class="number">0</span>, length);</span><br><span class="line">        <span class="keyword">return</span> (ProtocolBase)proByte;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">byte</span>[] <span class="title">Encode</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">GetName</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> GetString(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">GetDesc</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="literal">null</span>) <span class="keyword">return</span> str;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;bytes.Length;i++) &#123;</span><br><span class="line">            <span class="built_in">int</span> b = (<span class="built_in">int</span>)bytes[i];</span><br><span class="line">            str += b.ToString() + <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 字节辅助流</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddString</span>(<span class="params"><span class="built_in">string</span> str</span>)</span> &#123;</span><br><span class="line">        Int32 len = str.Length;</span><br><span class="line">        <span class="built_in">byte</span>[] lenBytes = BitConverter.GetBytes(len);</span><br><span class="line">        <span class="built_in">byte</span>[] strBytes = System.Text.Encoding.UTF8.GetBytes(str);</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="literal">null</span>)</span><br><span class="line">            bytes = lenBytes.Concat(strBytes).ToArray();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            bytes = bytes.Concat(lenBytes).Concat(strBytes).ToArray();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetString</span>(<span class="params"><span class="built_in">int</span> start, <span class="keyword">ref</span> <span class="built_in">int</span> end</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (bytes.Length &lt; start + <span class="keyword">sizeof</span>(Int32))</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        Int32 strLen = BitConverter.ToInt32(bytes, start);</span><br><span class="line">        <span class="keyword">if</span> (bytes.Length &lt; start + <span class="keyword">sizeof</span>(Int32) + strLen)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> str = System.Text.Encoding.UTF8.GetString(bytes, start + <span class="keyword">sizeof</span>(Int32) , strLen);</span><br><span class="line">        end = start + <span class="keyword">sizeof</span>(Int32) + strLen;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetString</span>(<span class="params"><span class="built_in">int</span> start</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> GetString(start,<span class="keyword">ref</span> end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddInt</span>(<span class="params"><span class="built_in">int</span> num</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">byte</span>[] numBytes = BitConverter.GetBytes(num);</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="literal">null</span>)</span><br><span class="line">            bytes = numBytes;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            bytes = bytes.Concat(numBytes).ToArray();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetInt</span>(<span class="params"><span class="built_in">int</span> start,<span class="keyword">ref</span> <span class="built_in">int</span> end</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (bytes.Length &lt; start + <span class="keyword">sizeof</span>(Int32))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        end = start + <span class="keyword">sizeof</span>(Int32);</span><br><span class="line">        <span class="keyword">return</span> BitConverter.ToInt32(bytes, start);</span><br><span class="line">    &#125;<span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetInt</span>(<span class="params"><span class="built_in">int</span> start</span>)</span> &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="built_in">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> GetInt(start,<span class="keyword">ref</span> end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddFloat</span>(<span class="params"><span class="built_in">float</span> num</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">byte</span>[] numBytes = BitConverter.GetBytes(num);</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="literal">null</span>)</span><br><span class="line">            bytes = numBytes;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            bytes = bytes.Concat(numBytes).ToArray();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">float</span> <span class="title">GetFloat</span>(<span class="params"><span class="built_in">int</span> start, <span class="keyword">ref</span> <span class="built_in">int</span> end</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (bytes.Length &lt; start + <span class="keyword">sizeof</span>(<span class="built_in">float</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        end = start + <span class="keyword">sizeof</span>(<span class="built_in">float</span>);</span><br><span class="line">        <span class="keyword">return</span> BitConverter.ToSingle(bytes, start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">float</span> <span class="title">GetFloat</span>(<span class="params"><span class="built_in">int</span> start</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> GetFloat(start, <span class="keyword">ref</span> end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串协议"><a href="#字符串协议" class="headerlink" title="字符串协议"></a>字符串协议</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProtocolStr</span> : <span class="title">ProtocolBase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> str;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> ProtocolBase <span class="title">Decode</span>(<span class="params"><span class="built_in">byte</span>[] readBuff, <span class="built_in">int</span> start, <span class="built_in">int</span> length</span>)</span> &#123;</span><br><span class="line">        ProtocolStr proStr = <span class="keyword">new</span> ProtocolStr();    </span><br><span class="line">        proStr.str = System.Text.Encoding.UTF8.GetString(readBuff, start, length);</span><br><span class="line">        <span class="keyword">return</span> (ProtocolBase) proStr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">byte</span>[] <span class="title">Encode</span>()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> System.Text.Encoding.UTF8.GetBytes(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">GetName</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.Length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> str.Split(<span class="string">&#x27;,&#x27;</span>)[<span class="number">0</span>];  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">GetDesc</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ProtocolCubeTexture-协议"><a href="#ProtocolCubeTexture-协议" class="headerlink" title="ProtocolCubeTexture 协议"></a>ProtocolCubeTexture 协议</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProtocolCubeTexture</span> : <span class="title">ProtocolBase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> width = NetCloudClientManager.instance.width;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[] Coord = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">public</span> Texture2D srcTexture;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> CubemapFace = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//解码器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> ProtocolBase <span class="title">Decode</span>(<span class="params"><span class="built_in">byte</span>[] readBuff, <span class="built_in">int</span> start, <span class="built_in">int</span> length</span>)</span> &#123;</span><br><span class="line">        ProtocolCubeTexture proTexture = <span class="keyword">new</span> ProtocolCubeTexture();</span><br><span class="line">        ProtocolByte proByte = <span class="keyword">new</span> ProtocolByte();</span><br><span class="line">        proByte.bytes = readBuff;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) &#123;</span><br><span class="line">            proTexture.Coord[i] = proByte.GetInt(start, <span class="keyword">ref</span> start);</span><br><span class="line">        &#125;</span><br><span class="line">        proTexture.CubemapFace = proByte.GetInt(start, <span class="keyword">ref</span> start);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//图片解析</span></span><br><span class="line">        <span class="built_in">int</span> srcStart = start;</span><br><span class="line">        <span class="built_in">int</span> srcLength = readBuff.Length-start;</span><br><span class="line">        <span class="built_in">byte</span>[] srcbyte = <span class="keyword">new</span> <span class="built_in">byte</span>[srcLength];</span><br><span class="line">        Array.Copy(readBuff, srcStart, srcbyte, <span class="number">0</span>, srcLength);</span><br><span class="line">        proTexture.srcTexture = <span class="keyword">new</span> Texture2D(width,width);</span><br><span class="line">        proTexture.srcTexture.LoadImage(srcbyte);</span><br><span class="line">        proTexture.srcTexture.Apply();</span><br><span class="line">        <span class="comment">//NetCloudClientManager.instance.tex[proTexture.CubemapFace] = proTexture.srcTexture;</span></span><br><span class="line">        <span class="keyword">return</span> (ProtocolBase) proTexture;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//编码器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">byte</span>[] <span class="title">Encode</span>()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//立方体面编译</span></span><br><span class="line">        </span><br><span class="line">        ProtocolByte proByte = <span class="keyword">new</span> ProtocolByte();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) &#123;</span><br><span class="line">            proByte.AddInt(Coord[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        proByte.AddInt(CubemapFace);</span><br><span class="line">        <span class="built_in">byte</span>[] cubeFaceBytes = proByte.Encode();</span><br><span class="line">        <span class="comment">//图片编译</span></span><br><span class="line">        <span class="keyword">if</span> (srcTexture == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">byte</span>[] srcTextureByte = srcTexture.EncodeToJPG();</span><br><span class="line">        <span class="comment">//byte[] lenByte = BitConverter.GetBytes(srcTextureByte.Length + cubeFaceBytes.Length);</span></span><br><span class="line">        <span class="built_in">byte</span>[] byt = cubeFaceBytes.Concat(srcTextureByte).ToArray();</span><br><span class="line">        <span class="keyword">return</span> byt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">GetName</span>()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ProtocolCubeTexture&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">GetDesc</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">byte</span>[] srcTextureByte = srcTexture.EncodeToJPG();</span><br><span class="line">        <span class="keyword">if</span> (srcTextureByte == <span class="literal">null</span>) <span class="keyword">return</span> str;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; srcTextureByte.Length; i++) &#123;</span><br><span class="line">            <span class="built_in">int</span> b = (<span class="built_in">int</span>)srcTextureByte[i];</span><br><span class="line">            str += b.ToString() + <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>全景图</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL学习之路之光照贴图</title>
    <url>/2021/12/07/OpenGL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E5%85%89%E7%85%A7%E8%B4%B4%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="冯光照模型"><a href="#冯光照模型" class="headerlink" title="冯光照模型"></a>冯光照模型</h1><p>效果混合相加：diffuse + ambient + specular</p>
<p>图片混和相乘：(diffuse + ambient + specular) * objColor</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FragColor =vec4((diffuse + ambient + specular) * objColor,<span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure>

<h1 id="环境光–ambient"><a href="#环境光–ambient" class="headerlink" title="环境光–ambient"></a>环境光–ambient</h1><p>ambient具体能表现无光照区域的颜色，在物体较暗的部分加上漫反射贴图会更真实</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vec3 ambient=texture(material.diffuse, TexCoord).rgb * ambientColor;</span><br></pre></td></tr></table></figure>

<h1 id="漫反射贴图—diffuse"><a href="#漫反射贴图—diffuse" class="headerlink" title="漫反射贴图—diffuse"></a>漫反射贴图—diffuse</h1><p>出现的大概像表面的纹理像木箱的表面，相当于简单反射到眼睛的获得的颜色</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vec3 diffuse=texture(material.diffuse,TexCoord).rgb * max( dot( lightDir, Normal), <span class="number">0</span>) * lightColor;</span><br><span class="line">    <span class="comment">//vec3 diffuse=texture(material.diffuse,TexCoord).rgb;</span></span><br></pre></td></tr></table></figure>
<h1 id="镜面反射—specular"><a href="#镜面反射—specular" class="headerlink" title="镜面反射—specular"></a>镜面反射—specular</h1><p>可以将光照和高光进行反射，提高真实度</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vec3 reflectVec=reflect(-lightDir,Normal);</span><br><span class="line"><span class="keyword">float</span> specularAmount=<span class="built_in">pow</span>(max(dot(reflectVec,cameraVec),<span class="number">0</span>),material.shininess); <span class="comment">//高光的集中度，倍数越高，同一视角高光点越小</span></span><br><span class="line">vec3 specular=texture(material.specular,TexCoord).rgb * specularAmount * lightColor;<span class="comment">//镜面反射图中为数值0或者为黑色表示不需要镜面反射，木块和铁最好对比</span></span><br></pre></td></tr></table></figure>

<h1 id="发射光贴图—emission"><a href="#发射光贴图—emission" class="headerlink" title="发射光贴图—emission"></a>发射光贴图—emission</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vec3 emission=texture(material.emission,TexCoord).rgb;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL学习之路之光源大总结</title>
    <url>/2021/12/19/OpenGL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E5%85%89%E6%BA%90%E5%A4%A7%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="光源所需条件"><a href="#光源所需条件" class="headerlink" title="光源所需条件"></a>光源所需条件</h1><h4 id="1-光照信息"><a href="#1-光照信息" class="headerlink" title="1.光照信息"></a>1.光照信息</h4><p>定向光 点光源 聚光灯的属性</p>
<h4 id="2-法线向量"><a href="#2-法线向量" class="headerlink" title="2.法线向量"></a>2.法线向量</h4><p>将顶点着色器的法线信息接收，并进行标准化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vec3 uNormal=<span class="built_in">normalize</span>(Normal);</span><br></pre></td></tr></table></figure>

<h4 id="3-片元到摄像头的位置"><a href="#3-片元到摄像头的位置" class="headerlink" title="3.片元到摄像头的位置"></a>3.片元到摄像头的位置</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vec3 dirToCamera=<span class="built_in">normalize</span>(cameraPos-FragPos);</span><br></pre></td></tr></table></figure>

<h2 id="定向光"><a href="#定向光" class="headerlink" title="定向光"></a>定向光</h2><h4 id="主要光照信息"><a href="#主要光照信息" class="headerlink" title="主要光照信息"></a>主要光照信息</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LightDirectional</span>&#123;</span><br><span class="line">  vec3 pos;<span class="comment">//光源坐标</span></span><br><span class="line">  vec3 color;<span class="comment">//光颜色</span></span><br><span class="line">  vec3 dirToLight;<span class="comment">//光照角度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>不需要光照衰弱，光照与位置无关</p>
<h4 id="diffuse"><a href="#diffuse" class="headerlink" title="diffuse"></a>diffuse</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">diffuseIntersity=<span class="built_in">max</span>(<span class="built_in">dot</span>(light.dirToLight,Normal),<span class="number">0</span>);</span><br><span class="line">diffuse=diffuseIntersity*light.color*<span class="built_in">texture</span>(material.diffuse,TexCoord).rgb;</span><br></pre></td></tr></table></figure>

<h4 id="specular"><a href="#specular" class="headerlink" title="specular"></a>specular</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">specularIntersity=<span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(<span class="built_in">normalize</span>(<span class="built_in">reflect</span>(-light.dirToLight,Normal)),dirToCamera),<span class="number">0</span>),material.shininess);</span><br><span class="line">vec3 specular=specularIntersity*light.color*<span class="built_in">texture</span>(material.specular,TexCoord).rgb;</span><br></pre></td></tr></table></figure>

<h2 id="点光源"><a href="#点光源" class="headerlink" title="点光源"></a>点光源</h2><h4 id="主要光照信息-1"><a href="#主要光照信息-1" class="headerlink" title="主要光照信息"></a>主要光照信息</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LightPoint</span>&#123;</span><br><span class="line">  vec3 pos;</span><br><span class="line">  vec3 color;</span><br><span class="line">  vec3 dirToLight;<span class="comment">//用不上</span></span><br><span class="line">    <span class="type">float</span> constant;<span class="comment">//1.0f</span></span><br><span class="line">    <span class="type">float</span> linear;<span class="comment">//0.09f</span></span><br><span class="line">    <span class="type">float</span> quadratic;<span class="comment">//0.032f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>与光照方向无关</p>
<h4 id="attenuation"><a href="#attenuation" class="headerlink" title="attenuation"></a>attenuation</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> distantes=<span class="built_in">length</span>(light.pos-FragPos);</span><br><span class="line"><span class="type">float</span> attenuation=<span class="number">1.0f</span>/light.constant+light.linear*distantes+light.quadratic*distantes*distantes;</span><br></pre></td></tr></table></figure>



<h4 id="diffuse-1"><a href="#diffuse-1" class="headerlink" title="diffuse"></a>diffuse</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">diffuseInyersity=<span class="built_in">max</span>(<span class="built_in">dot</span>(<span class="built_in">normalize</span>(light.pos-FragPos),Normal),<span class="number">0</span>);</span><br><span class="line">vec3 diffuse=diffuseIntensity*<span class="built_in">texture</span>(material.diffuse,TexCoord).rgb*light.color;</span><br></pre></td></tr></table></figure>

<h4 id="specular-1"><a href="#specular-1" class="headerlink" title="specular"></a>specular</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> specularIntersity=<span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(<span class="built_in">normalize</span>(<span class="built_in">reflect</span>(-<span class="built_in">normalize</span>(light.pos-FragPos),uNormal)),dirToCamera),<span class="number">0</span>),material.shininess);</span><br><span class="line">  vec3 specular=specularIntersity*light.color*<span class="built_in">texture</span>(material.specular,TexCoord).rgb;</span><br></pre></td></tr></table></figure>

<h2 id="聚光灯"><a href="#聚光灯" class="headerlink" title="聚光灯"></a>聚光灯</h2><h4 id="主要光照信息-2"><a href="#主要光照信息-2" class="headerlink" title="主要光照信息"></a>主要光照信息</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LightSpot</span>&#123;</span><br><span class="line">  vec3 pos;</span><br><span class="line">  vec3 color;</span><br><span class="line">  vec3 dirToLight;<span class="comment">//有用</span></span><br><span class="line">    <span class="type">float</span> constant;</span><br><span class="line">    <span class="type">float</span> linear;</span><br><span class="line">    <span class="type">float</span> quadratic;</span><br><span class="line">  <span class="type">float</span> cosPhyInner;</span><br><span class="line">  <span class="type">float</span> cosPhyOutter;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><p>边缘模糊化，对比点光源需要会受角度影响</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vec3 result=<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//attenuation</span></span><br><span class="line"><span class="type">float</span> distances= <span class="built_in">length</span>(light.pos - FragPos);</span><br><span class="line"><span class="type">float</span> attenuation=<span class="number">1.0f</span>/(light.constant+light.linear*distances+light.quadratic*distances*distances);</span><br><span class="line"><span class="type">float</span> spotRatio=<span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> cosTheta=<span class="built_in">dot</span>(<span class="built_in">normalize</span>(FragPos-light.pos),<span class="number">-1.0f</span>*light.dirToLight);</span><br><span class="line"><span class="comment">//cosTheta=1;</span></span><br><span class="line"><span class="keyword">if</span>(cosTheta &gt; light.cosPhyInner)</span><br><span class="line">&#123;</span><br><span class="line">  spotRatio=<span class="number">1.0f</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(cosTheta &gt; light.cosPhyOutter)&#123;</span><br><span class="line">  <span class="comment">//spotRatio=1.0f-(cosTheta-light.cosPhyInner)/(light.cosPhyOutter-light.cosPhyInner);</span></span><br><span class="line">  spotRatio=(light.cosPhyOutter-cosTheta)/(light.cosPhyOutter - light.cosPhyInner);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">  spotRatio=<span class="number">0.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line">attenuation*=spotRatio;</span><br><span class="line"><span class="comment">//diffuse</span></span><br><span class="line"><span class="type">float</span> diffuseIntensity=<span class="built_in">max</span>(<span class="built_in">dot</span>(<span class="built_in">normalize</span>(light.pos-FragPos),uNormal),<span class="number">0</span>);</span><br><span class="line">vec3 diffuse=<span class="built_in">texture</span>(material.diffuse,TexCoord).rgb*light.color*diffuseIntensity;</span><br><span class="line">result+=diffuse;</span><br><span class="line"></span><br><span class="line"><span class="comment">//specular</span></span><br><span class="line"><span class="type">float</span> specularIntersity=<span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(<span class="built_in">normalize</span>(<span class="built_in">reflect</span>(-<span class="built_in">normalize</span>(light.pos-FragPos),uNormal)),dirToCamera),<span class="number">0</span>),material.shininess);</span><br><span class="line">vec3 specular = specularIntersity*<span class="built_in">texture</span>(material.specular,TexCoord).rgb*light.color;</span><br><span class="line">result+=specular;</span><br><span class="line"><span class="comment">//result*=attenuation;</span></span><br><span class="line">result*=spotRatio;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity升级管线的注意事项</title>
    <url>/2022/01/18/Unity%E5%8D%87%E7%BA%A7%E7%AE%A1%E7%BA%BF%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<blockquote>
<h1 id="升级渲染管线在PM中下载-Universal-RP"><a href="#升级渲染管线在PM中下载-Universal-RP" class="headerlink" title="升级渲染管线在PM中下载 Universal RP"></a>升级渲染管线在PM中下载 Universal RP</h1></blockquote>
<p>材质记得替，不如会出现洋红色</p>
<blockquote>
<h1 id="使用的简单的建模工具"><a href="#使用的简单的建模工具" class="headerlink" title="使用的简单的建模工具"></a>使用的简单的建模工具</h1></blockquote>
<h3 id="在pm包中有不错的东西"><a href="#在pm包中有不错的东西" class="headerlink" title="在pm包中有不错的东西"></a>在pm包中有不错的东西</h3><h3 id="在游戏中进行简单的建模可以用ProBuilder和Polybrush这两个包进行修改地形的顶点"><a href="#在游戏中进行简单的建模可以用ProBuilder和Polybrush这两个包进行修改地形的顶点" class="headerlink" title="在游戏中进行简单的建模可以用ProBuilder和Polybrush这两个包进行修改地形的顶点"></a>在游戏中进行简单的建模可以用ProBuilder和Polybrush这两个包进行修改地形的顶点</h3><h3 id="ProGrids做方格的校准"><a href="#ProGrids做方格的校准" class="headerlink" title="ProGrids做方格的校准"></a>ProGrids做方格的校准</h3>]]></content>
      <categories>
        <category>升级渲染管线</category>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>TA1.3人物扫光</title>
    <url>/2022/01/21/TA1.3%E4%BA%BA%E7%89%A9%E6%89%AB%E5%85%89/</url>
    <content><![CDATA[<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="边缘光"><a href="#边缘光" class="headerlink" title="边缘光"></a>边缘光</h2><p><img src="https://img-blog.csdnimg.cn/ae5ddfb6e8464ec0aa7ffeb6c7f1bf90.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">    </p>
<h2 id="流光"><a href="#流光" class="headerlink" title="流光"></a>流光</h2><p><img src="https://img-blog.csdnimg.cn/1ee1c9a1e9ad45809bdd840452952c77.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当一个三维向量补全为四维向量的时候，如果是点的话最后需要补成1.0，如果是向量的话需要补0.0</p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>TA1.2UnityShader入门</title>
    <url>/2022/01/10/TA1.2UnityShader%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h4 id="平铺和偏移"><a href="#平铺和偏移" class="headerlink" title="平铺和偏移"></a>平铺和偏移</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//properties</span></span><br><span class="line">_Texture(<span class="string">&quot;Texture&quot;</span>,<span class="number">2</span>D)=<span class="string">&quot;white&quot;</span>&#123;&#125;</span><br><span class="line"><span class="comment">//SubPass/Pass</span></span><br><span class="line">sampler2D _Texture;</span><br><span class="line">float4 _Texture_ST;	</span><br><span class="line">o.uv=v.uv*_Texture_ST.xy+_Texture_ST.zw;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="顶点坐标系MVP转换"><a href="#顶点坐标系MVP转换" class="headerlink" title="顶点坐标系MVP转换"></a>顶点坐标系MVP转换</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">float4 pos_world = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">float4 pos_view = mul(UNITY_MATRIX_V,pos_world);</span><br><span class="line">float4 pos_clip = mul(UNITY_MATRIX_P,pos_view);</span><br><span class="line">o.pos=pos_clip;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">o.pos=UnityObjectToClipPos(v.vertex);</span><br></pre></td></tr></table></figure>

<h4 id="CG变量用法"><a href="#CG变量用法" class="headerlink" title="CG变量用法"></a>CG变量用法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> = <span class="number">32</span><span class="comment">//坐标</span></span><br><span class="line">half = <span class="number">16</span><span class="comment">//uv，大部分向量</span></span><br><span class="line">fixed =<span class="number">8</span><span class="comment">//颜色</span></span><br></pre></td></tr></table></figure>

<h2 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h2><h3 id="面剔除"><a href="#面剔除" class="headerlink" title="面剔除"></a>面剔除</h3><h4 id="单独写死"><a href="#单独写死" class="headerlink" title="单独写死"></a>单独写死</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Cull off</span><br></pre></td></tr></table></figure>

<h4 id="在面板上显示"><a href="#在面板上显示" class="headerlink" title="在面板上显示"></a>在面板上显示</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[Enum(UnityEngine.Rendering.CullMode)]_CullMode(<span class="string">&quot;CullMode&quot;</span>,Float)=<span class="number">2</span><span class="comment">//Properties</span></span><br><span class="line">Cull [_CullMode]<span class="comment">//SubPass/Pass</span></span><br></pre></td></tr></table></figure>

<h3 id="图片铺在模型上"><a href="#图片铺在模型上" class="headerlink" title="图片铺在模型上"></a>图片铺在模型上</h3><p>图片将平铺到x与y组成的平面上</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">o.uv=v.vertex.xy*_Texture_ST.xy+_Texture_ST.zw;</span><br></pre></td></tr></table></figure>

<p>xy变成yx时</p>
<p>相当与x轴旋转180度y轴旋转-90度</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">o.uv=v.vertex.yx*_Texture_ST.xy+_Texture_ST.zw;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">float4 pos_world = mul(unity_ObjectToWorld, v.vertex);</span><br></pre></td></tr></table></figure>



<p>加面解决圆面失真的问题</p>
<h2 id="水波的制作"><a href="#水波的制作" class="headerlink" title="水波的制作"></a>水波的制作</h2><h3 id="先制作动态圆盘"><a href="#先制作动态圆盘" class="headerlink" title="先制作动态圆盘"></a>先制作动态圆盘</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_Float(<span class="string">&quot;Float&quot;</span>,Float)=<span class="number">0.0</span></span><br><span class="line">_Vector(<span class="string">&quot;Vector&quot;</span>,Vector)=(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">_Texture(<span class="string">&quot;Texture&quot;</span>,<span class="number">2</span>D)=<span class="string">&quot;white&quot;</span>&#123;&#125;<span class="comment">//Properties</span></span><br><span class="line">half gradient=tex2D(_Texture,i.uv+_Time.y*_Vector.xy).x;</span><br><span class="line">clip(gradient-_Float);</span><br><span class="line"><span class="keyword">return</span> gradient.xxxx;<span class="comment">//fragment</span></span><br></pre></td></tr></table></figure>

<h3 id="噪声"><a href="#噪声" class="headerlink" title="噪声"></a>噪声</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_NoiseTex(<span class="string">&quot;NoiseTex&quot;</span>,<span class="number">2</span>D)=<span class="string">&quot;white&quot;</span>&#123;&#125;<span class="comment">//Properties</span></span><br><span class="line">half noise=<span class="number">1.0f</span>-tex2D(_NoiseTex,i.uv+_Time.y*_Vector.wz).x;</span><br><span class="line">clip(gradient-_Float-noise);<span class="comment">//fragment</span></span><br></pre></td></tr></table></figure>

<h3 id="完善颜色-完整代码"><a href="#完善颜色-完整代码" class="headerlink" title="完善颜色,完整代码"></a>完善颜色,完整代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Shader<span class="string">&quot;MyShader/03shader&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties&#123;</span><br><span class="line">        _Float(<span class="string">&quot;Float&quot;</span>,Float)=<span class="number">0.0</span></span><br><span class="line">        _Range(<span class="string">&quot;Range&quot;</span>,Range(<span class="number">0</span>,<span class="number">1</span>))=<span class="number">0.0</span></span><br><span class="line">        _Vector(<span class="string">&quot;Vector&quot;</span>,Vector)=(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _Color(<span class="string">&quot;Color&quot;</span>,Color)=(<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>)</span><br><span class="line">        _Texture(<span class="string">&quot;Texture&quot;</span>,<span class="number">2</span>D)=<span class="string">&quot;white&quot;</span>&#123;&#125;</span><br><span class="line">        _NoiseTex(<span class="string">&quot;NoiseTex&quot;</span>,<span class="number">2</span>D)=<span class="string">&quot;white&quot;</span>&#123;&#125;</span><br><span class="line">        [Enum(UnityEngine.Rendering.CullMode)]_CullMode(<span class="string">&quot;CullMode&quot;</span>,Float)=<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        Pass&#123;</span><br><span class="line">            Cull [_CullMode]</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">            struct appdata&#123;</span><br><span class="line">                float4 vertex:POSITION;</span><br><span class="line">                float2 uv:TEXCOORD0;</span><br><span class="line">             <span class="comment">//   float4 color:COLOR;</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">                float4 pos:SV_POSITION;</span><br><span class="line">                float2 uv:TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            sampler2D _Texture;</span><br><span class="line">            float4 _Texture_ST;</span><br><span class="line">            <span class="keyword">float</span> _Float;</span><br><span class="line">            float4 _Vector;</span><br><span class="line">            sampler2D _NoiseTex;</span><br><span class="line">            float2 _NoiseTex_ST;</span><br><span class="line">            fixed4 _Color;</span><br><span class="line"></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                float4 pos_world = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">                float4 pos_view = mul(UNITY_MATRIX_V,pos_world);</span><br><span class="line">                float4 pos_clip = mul(UNITY_MATRIX_P,pos_view);</span><br><span class="line">                <span class="comment">//o.pos=pos_clip;</span></span><br><span class="line">                o.pos=UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv=v.uv.xy*_Texture_ST.xy+_Texture_ST.zw;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="function">half4 <span class="title">frag</span><span class="params">(v2f i)</span>:SV_Target</span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                half gradient=tex2D(_Texture,i.uv+_Time.y*_Vector.xy).x;</span><br><span class="line">                half noise=<span class="number">1.0f</span>-tex2D(_NoiseTex,i.uv+_Time.y*_Vector.wz).x;</span><br><span class="line">                clip(gradient-_Float-noise);</span><br><span class="line">                <span class="keyword">return</span> _Color;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="半透明混合"><a href="#半透明混合" class="headerlink" title="半透明混合"></a>半透明混合</h2><h3 id="参数意思"><a href="#参数意思" class="headerlink" title="参数意思"></a>参数意思</h3><table>
<thead>
<tr>
<th></th>
<th>one</th>
<th>此输入的值是 one。该值用于使用源或目标的颜色的值。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><code>Zero</code></td>
<td>此输入的值是 zero。该值用于删除源或目标值。</td>
</tr>
<tr>
<td></td>
<td><code>SrcColor</code></td>
<td>GPU 将此输入的值乘以源颜色值。</td>
</tr>
<tr>
<td></td>
<td><code>SrcAlpha</code></td>
<td>GPU 将此输入的值乘以源 Alpha 值。</td>
</tr>
<tr>
<td></td>
<td><code>DstColor</code></td>
<td>GPU 将此输入的值乘以帧缓冲区的源颜色值。</td>
</tr>
<tr>
<td></td>
<td><code>DstAlpha</code></td>
<td>GPU 将此输入的值乘以帧缓冲区的源 Alpha 值。</td>
</tr>
<tr>
<td></td>
<td><code>OneMinusSrcColor</code></td>
<td>GPU 将此输入的值乘以（1 - 源颜色）。</td>
</tr>
<tr>
<td></td>
<td><code>OneMinusSrcAlpha</code></td>
<td>GPU 将此输入的值乘以（1 - 源 Alpha）。</td>
</tr>
<tr>
<td></td>
<td><code>OneMinusDstColor</code></td>
<td>GPU 将此输入的值乘以（1 - 目标颜色）。</td>
</tr>
<tr>
<td></td>
<td><code>OneMinusDstAlpha</code></td>
<td>GPU 将此输入的值乘以（1 - 目标 Alpha）。</td>
</tr>
</tbody></table>
<h3 id="常见混合类型"><a href="#常见混合类型" class="headerlink" title="常见混合类型"></a>常见混合类型</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Blend SrcAlpha OneMinusSrcAlpha <span class="comment">// 传统透明度</span></span><br><span class="line">Blend SrcAlpha One</span><br><span class="line"><span class="comment">//以上两种常用</span></span><br><span class="line">Blend One OneMinusSrcAlpha <span class="comment">// 预乘透明度</span></span><br><span class="line">Blend One One <span class="comment">// 加法</span></span><br><span class="line">Blend OneMinusDstColor One <span class="comment">// 软加法</span></span><br><span class="line">Blend DstColor Zero <span class="comment">// 乘法</span></span><br><span class="line">Blend DstColor SrcColor <span class="comment">// 2x 乘法</span></span><br></pre></td></tr></table></figure>

<h3 id="代码修改"><a href="#代码修改" class="headerlink" title="代码修改"></a>代码修改</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Tags &#123; <span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;Transparent&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ZWrite Off</span><br><span class="line">Blend SrcAlpha One<span class="comment">//预乘透明度</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">half3 col=_Color.xyz*_Float;</span><br><span class="line">half alpha=saturate(tex2D(_Texture,i.uv).r*_Color.a*_Float);</span><br><span class="line"><span class="keyword">return</span> half4(col,alpha);</span><br></pre></td></tr></table></figure>

<h2 id="边缘光-fresnel-简版的菲涅尔方程"><a href="#边缘光-fresnel-简版的菲涅尔方程" class="headerlink" title="边缘光(fresnel)简版的菲涅尔方程"></a>边缘光(fresnel)简版的菲涅尔方程</h2><h3 id="菲涅尔边缘光实现"><a href="#菲涅尔边缘光实现" class="headerlink" title="菲涅尔边缘光实现"></a>菲涅尔边缘光实现</h3><p>口述： 菲涅耳系数=pow (1.0f-saturate(dot(世界坐标到局部坐标的法线向量,世界坐标的顶点到摄像头的单位向量)) ,梯度系数)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">o.normal_world=normalize( mul(float4(v.normal,<span class="number">0</span>),unity_WorldToObject));<span class="comment">//世界坐标到局部坐标的法线向量</span></span><br><span class="line">float4 pos_world = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">o.view_world=normalize(_WorldSpaceCameraPos.xyz-pos_world);<span class="comment">//世界坐标的顶点到摄像头的单位向量</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">float3 normal_world=normalize(i.normal_world);</span><br><span class="line">float3 view_world=normalize(i.view_world);<span class="comment">//光栅化后向量需要标准化</span></span><br><span class="line"><span class="keyword">float</span> NdotV=saturate(dot(normal_world,view_world));</span><br><span class="line">half3 col=_Color.xyz*_Float;</span><br><span class="line"><span class="keyword">float</span> fresnel=<span class="built_in">pow</span>(<span class="number">1.0f</span>-NdotV,_Rim);<span class="comment">//菲涅尔系数</span></span><br><span class="line">half alpha=saturate(_Float*fresnel);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> half4(col,alpha);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Pass&#123;</span><br><span class="line">    ZWrite Off</span><br><span class="line">    Blend SrcAlpha One<span class="comment">//预乘透明度</span></span><br><span class="line">    Cull [_CullMode]</span><br><span class="line">    CGPROGRAM</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">        float4 vertex:POSITION;</span><br><span class="line">        float2 uv:TEXCOORD0;</span><br><span class="line">        float3 normal:NORMAL;</span><br><span class="line">     <span class="comment">//   float4 color:COLOR;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">        float4 pos:SV_POSITION;</span><br><span class="line">        float2 uv:TEXCOORD0;</span><br><span class="line">        float3 normal_world:TEXCOORD1;</span><br><span class="line">        float3 view_world:TEXCOORD2;</span><br><span class="line">    &#125;;</span><br><span class="line">    sampler2D _Texture;</span><br><span class="line">    float4 _Texture_ST;</span><br><span class="line">    fixed4 _Color;</span><br><span class="line">    <span class="keyword">float</span> _Float;</span><br><span class="line">    <span class="keyword">float</span> _Rim;</span><br><span class="line">    <span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        v2f o;</span><br><span class="line">        o.pos=UnityObjectToClipPos(v.vertex);</span><br><span class="line">        o.normal_world=normalize( mul(float4(v.normal,<span class="number">0</span>),unity_WorldToObject));</span><br><span class="line">        float4 pos_world = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">        o.view_world=normalize(_WorldSpaceCameraPos.xyz-pos_world);</span><br><span class="line">        o.uv=v.uv*_Texture_ST.xy+_Texture_ST.zw;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">half4 <span class="title">frag</span><span class="params">(v2f i)</span>:SV_Target</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        float3 normal_world=normalize(i.normal_world);</span><br><span class="line">        float3 view_world=normalize(i.view_world);</span><br><span class="line">        <span class="keyword">float</span> NdotV=saturate(dot(normal_world,view_world));</span><br><span class="line">        half3 col=_Color.xyz*_Float;</span><br><span class="line">        <span class="keyword">float</span> fresnel=<span class="built_in">pow</span>(<span class="number">1.0f</span>-NdotV,_Rim);</span><br><span class="line">        half alpha=saturate(_Float*fresnel);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> half4(col,alpha);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="预先写深度"><a href="#预先写深度" class="headerlink" title="预先写深度"></a>预先写深度</h3><p><strong>修除内部透明小Bug，预先将前面的深度写入，但不写入颜色信息，用上面的pass第二遍时将后面的透明的给剔除掉，</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line">   	Cull Off </span><br><span class="line">   	ZWrite On <span class="comment">//深度写入</span></span><br><span class="line">   	ColorMask <span class="number">0</span><span class="comment">//不写颜色信息</span></span><br><span class="line">   	CGPROGRAM</span><br><span class="line">   	float4 _Color;</span><br><span class="line">   	<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert </span></span><br><span class="line">   	<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">   	<span class="function">float4 <span class="title">vert</span><span class="params">(float4 vertexPos : POSITION)</span> : SV_POSITION</span></span><br><span class="line"><span class="function">   	</span>&#123;</span><br><span class="line">   		<span class="keyword">return</span> UnityObjectToClipPos(vertexPos);</span><br><span class="line">   	&#125;</span><br><span class="line"></span><br><span class="line">   	<span class="function">float4 <span class="title">frag</span><span class="params">(<span class="keyword">void</span>)</span> : COLOR</span></span><br><span class="line"><span class="function">   	</span>&#123;</span><br><span class="line">   		<span class="keyword">return</span> _Color;</span><br><span class="line">   	&#125;</span><br><span class="line">   	ENDCG</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>计算机图形学</category>
        <category>Unity</category>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>TA1.4薄膜干涉效果</title>
    <url>/2022/01/22/TA1.4%E8%96%84%E8%86%9C%E5%B9%B2%E6%B6%89%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<blockquote>
<h1 id="薄膜干涉"><a href="#薄膜干涉" class="headerlink" title="薄膜干涉"></a>薄膜干涉</h1></blockquote>
<h2 id="材质捕捉效果（Material-Capture）"><a href="#材质捕捉效果（Material-Capture）" class="headerlink" title="材质捕捉效果（Material Capture）"></a>材质捕捉效果（Material Capture）</h2><p><strong>预览效果</strong></p>
<p><img src="https://img-blog.csdnimg.cn/56c243af89ed49898a5ee5130e2a0507.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_16,color_FFFFFF,t_70,g_se,x_16" alt="预览效果"></p>
<p><strong>ASE图</strong></p>
<p><img src="https://img-blog.csdnimg.cn/d923225abd084649b13c00901cb87279.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>将观察坐标系的顶点法线xy当作材质的uv，将材质图片根据坐标平埔视角坐标系下的模型上，缺点当模型处于视野边缘时会有破绽。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>Properties</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_MainTex (<span class="string">&quot;diffuse&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">  _MatCatAddTex (<span class="string">&quot;MatCatAdd&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">  _MatCatAddIntensity (<span class="string">&quot;MatCatAddIntensity&quot;</span>, Float) = <span class="number">0.35</span></span><br><span class="line"></span><br><span class="line">  _MatCatTex (<span class="string">&quot;MatCat&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">  _MatCatIntensity (<span class="string">&quot;MatCatIntensity&quot;</span>, Float) = <span class="number">5.0</span></span><br></pre></td></tr></table></figure>

<p>Pass</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sampler2D _MatCatAddTex;</span><br><span class="line">float4 _MatCatAddTex_ST;</span><br><span class="line"><span class="keyword">float</span> _MatCatAddIntensity;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sampler2D _MatCatTex;</span><br><span class="line">float4 _MatCatTex_ST;</span><br><span class="line"><span class="keyword">float</span> _MatCatIntensity;</span><br></pre></td></tr></table></figure>

<p>vert</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">o.normal_world = mul(float4(v.normal,<span class="number">0.0</span>) ,unity_WorldToObject);<span class="comment">//获取worldnormal</span></span><br></pre></td></tr></table></figure>

<p>frag</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fixed4 col_diffuse = tex2D(_MainTex, i.uv);</span><br><span class="line">half2 MatCat_uv = (mul(UNITY_MATRIX_V, half4(normal_world, <span class="number">0.0</span>)).xy + <span class="number">1.0f</span>) * <span class="number">0.5f</span>;</span><br><span class="line">fixed4 col_MatCatAdd = tex2D(_MatCatAddTex, MatCat_uv) * _MatCatAddIntensity;</span><br><span class="line">fixed4 col_MatCat = tex2D(_MatCatTex, MatCat_uv) * _MatCatIntensity;</span><br></pre></td></tr></table></figure>

<h2 id="Ramp填充里面的颜色"><a href="#Ramp填充里面的颜色" class="headerlink" title="Ramp填充里面的颜色"></a>Ramp填充里面的颜色</h2><p><strong>预览效果</strong></p>
<p><img src="https://img-blog.csdnimg.cn/4de55293ebc148d28909c8690ad9a1a9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><strong>过度颜色图</strong></p>
<p><img src="https://img-blog.csdnimg.cn/1e311d3cf2474411a1c39505009b610d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p><strong>ASE图</strong></p>
<p><img src="https://img-blog.csdnimg.cn/7d0955cba77744b8be275fa6c1b9f080.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>利用菲涅尔方程的经验，1.0f - saturate(dot(normal_world, view_dir))在x和y上得到的是单调连续数值</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>Properties</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_RampTex(<span class="string">&quot;Ramp&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>vart</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">float3 pos_world = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">o.view_world = normalize( _WorldSpaceCameraPos - pos_world );</span><br></pre></td></tr></table></figure>



<p>frag</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">half3 view_dir = normalize(i.view_world);</span><br><span class="line">half fresnel = <span class="number">1.0f</span> - saturate(dot(normal_world, view_dir));</span><br><span class="line">fixed4 col_Ramp = tex2D(_RampTex, half2(fresnel, <span class="number">0.5f</span>));</span><br></pre></td></tr></table></figure>



<h2 id="合并效果"><a href="#合并效果" class="headerlink" title="合并效果"></a>合并效果</h2><h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p><img src="https://img-blog.csdnimg.cn/6683c0fd1e1d4027be543f06e8e47de8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/89d2e4d09575407c9e6ea4d33677e259.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="ASE图"><a href="#ASE图" class="headerlink" title="ASE图"></a>ASE图</h3><p><img src="https://img-blog.csdnimg.cn/dc3628555216403f82d24ccc9a88feb6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unlit/MatCat1_Code&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;diffuse&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _MatCatAddTex (<span class="string">&quot;MatCatAdd&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _MatCatAddIntensity (<span class="string">&quot;MatCatAddIntensity&quot;</span>, Float) = <span class="number">0.35</span></span><br><span class="line"></span><br><span class="line">        _MatCatTex (<span class="string">&quot;MatCat&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _MatCatIntensity (<span class="string">&quot;MatCatIntensity&quot;</span>, Float) = <span class="number">5.0</span></span><br><span class="line">        _RampTex(<span class="string">&quot;Ramp&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 normal_world : TEXCOORD1;</span><br><span class="line">                float3 view_world : TEXCOORD2;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">            sampler2D _MatCatAddTex;</span><br><span class="line">            float4 _MatCatAddTex_ST;</span><br><span class="line">            <span class="keyword">float</span> _MatCatAddIntensity;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            sampler2D _MatCatTex;</span><br><span class="line">            float4 _MatCatTex_ST;</span><br><span class="line">            <span class="keyword">float</span> _MatCatIntensity;</span><br><span class="line">            </span><br><span class="line">            sampler2D _RampTex;</span><br><span class="line">            float4 _RampTex_ST;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span> <span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">                o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">                o.normal_world = mul(float4(v.normal,<span class="number">0.0</span>) ,unity_WorldToObject);</span><br><span class="line">                float3 pos_world = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">                o.view_world = normalize( _WorldSpaceCameraPos - pos_world );</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_Target</span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                half3 normal_world = normalize(i.normal_world);</span><br><span class="line">                fixed4 col;</span><br><span class="line">                <span class="comment">// MatCap</span></span><br><span class="line">                fixed4 col_diffuse = tex2D(_MainTex, i.uv);</span><br><span class="line">                half2 MatCat_uv = (mul(UNITY_MATRIX_V, half4(normal_world, <span class="number">0.0</span>)).xy + <span class="number">1.0f</span>) * <span class="number">0.5f</span>;</span><br><span class="line">                fixed4 col_MatCatAdd = tex2D(_MatCatAddTex, MatCat_uv) * _MatCatAddIntensity;</span><br><span class="line">                fixed4 col_MatCat = tex2D(_MatCatTex, MatCat_uv) * _MatCatIntensity;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">//Ramp</span></span><br><span class="line">                half3 view_dir = normalize(i.view_world);</span><br><span class="line">                half fresnel = <span class="number">1.0f</span> - saturate(dot(normal_world, view_dir));</span><br><span class="line">                fixed4 col_Ramp = tex2D(_RampTex, half2(fresnel, <span class="number">0.5f</span>));</span><br><span class="line"></span><br><span class="line">                col = col_diffuse * col_MatCat * col_Ramp;</span><br><span class="line">                col += col_MatCatAdd ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">               <span class="comment">// return fixed4(i.normal_world,0.0);</span></span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>TA1.5藤曼生长</title>
    <url>/2022/02/10/TA1.5%E8%97%A4%E6%9B%BC%E7%94%9F%E9%95%BF/</url>
    <content><![CDATA[<h1 id="藤曼生长"><a href="#藤曼生长" class="headerlink" title="藤曼生长"></a>藤曼生长</h1><p><strong>预览视图</strong></p>
<p><img src="https://img-blog.csdnimg.cn/239148c16c944873b02c02d3147cd67d.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/4606bf1634494bfb9d0af5015ae90502.png" alt="在这里插入图片描述"></p>
<p><strong>PBR材质下的效果</strong></p>
<p>显示更好看上ASE</p>
<p><img src="https://img-blog.csdnimg.cn/ba9a3e2dbcfc4bfdbb6771696810b7e0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/d1ea5f1eab5a4091b0baf36a3495df95.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/34ccd229561748c192f020f3b60c88c8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="简化版"><a href="#简化版" class="headerlink" title="简化版"></a>简化版</h2><p>可以乘以顶点法线向量可以实现物体的缩放，用一个UV图的权重控制不同位置缩放部分，可以形成藤曼的样子</p>
<h3 id="ASE"><a href="#ASE" class="headerlink" title="ASE"></a>ASE</h3><p><img src="https://img-blog.csdnimg.cn/cd32f8d0755c44bcb1671ecc6d91b26b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">_Grow(<span class="string">&quot;Grow&quot;</span>,Range(<span class="number">-1.0</span>,<span class="number">1.0</span>)) = <span class="number">0.0</span></span><br><span class="line">_Expend(<span class="string">&quot;Expend&quot;</span>,Float) = <span class="number">0.0</span></span><br><span class="line">_Scale(<span class="string">&quot;Scale&quot;</span>,Float) = <span class="number">0.0</span></span><br><span class="line">_GrowMin(<span class="string">&quot;GrowMin&quot;</span>, Range(<span class="number">0</span>,<span class="number">1.0</span>)) = <span class="number">0.6</span></span><br><span class="line">_GrowMax(<span class="string">&quot;GrowMax&quot;</span>, Range(<span class="number">0</span>,<span class="number">1.5</span>)) = <span class="number">1.0</span></span><br><span class="line">_EndMin(<span class="string">&quot;EndMin&quot;</span>, Range(<span class="number">0</span>,<span class="number">1.0</span>)) = <span class="number">0.6</span></span><br><span class="line">_EndMax(<span class="string">&quot;EndMax&quot;</span>, Range(<span class="number">0</span>,<span class="number">1.5</span>)) = <span class="number">1.0</span> </span><br></pre></td></tr></table></figure>

<h4 id="appdata"><a href="#appdata" class="headerlink" title="appdata"></a>appdata</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">appdata</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 normal:NORMAL;</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="vert"><a href="#vert" class="headerlink" title="vert"></a>vert</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">v2f <span class="title">vert</span> <span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    half weight = max(smoothstep( _GrowMin, _GrowMax, v.uv.y - _Grow), smoothstep(_EndMin, _EndMax,v.uv.y ));</span><br><span class="line">    half3 weight_combine = weight * _Expend * <span class="number">0.01f</span>*v.normal;</span><br><span class="line">    half3 scale_combine = _Scale * <span class="number">0.01f</span> * v.normal;</span><br><span class="line">    half3 normal_combine = weight_combine + scale_combine;</span><br><span class="line">    v.vertex.xyz = v.vertex.xyz+ normal_combine;</span><br><span class="line">    o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="frag"><a href="#frag" class="headerlink" title="frag"></a>frag</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_Target</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    clip(<span class="number">1</span> - (i.uv.y - _Grow));</span><br><span class="line">    <span class="comment">// sample the texture</span></span><br><span class="line">    fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unlit/Vice1_Code&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Grow(<span class="string">&quot;Grow&quot;</span>,Range(<span class="number">-1.0</span>,<span class="number">1.0</span>)) = <span class="number">0.0</span></span><br><span class="line">        _Expend(<span class="string">&quot;Expend&quot;</span>,Float) = <span class="number">0.0</span></span><br><span class="line">        _Scale(<span class="string">&quot;Scale&quot;</span>,Float) = <span class="number">0.0</span></span><br><span class="line">        _GrowMin(<span class="string">&quot;GrowMin&quot;</span>, Range(<span class="number">0</span>,<span class="number">1.0</span>)) = <span class="number">0.6</span></span><br><span class="line">        _GrowMax(<span class="string">&quot;GrowMax&quot;</span>, Range(<span class="number">0</span>,<span class="number">1.5</span>)) = <span class="number">1.0</span></span><br><span class="line">        _EndMin(<span class="string">&quot;EndMin&quot;</span>, Range(<span class="number">0</span>,<span class="number">1.0</span>)) = <span class="number">0.6</span></span><br><span class="line">        _EndMax(<span class="string">&quot;EndMax&quot;</span>, Range(<span class="number">0</span>,<span class="number">1.5</span>)) = <span class="number">1.0</span> </span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line">            <span class="comment">// make fog work</span></span><br><span class="line">           </span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 normal:NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float2 uv : TEXCOORD0; </span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="keyword">float</span> _Grow;</span><br><span class="line">            <span class="keyword">float</span> _Expend;</span><br><span class="line">            <span class="keyword">float</span> _GrowMin;</span><br><span class="line">            <span class="keyword">float</span> _GrowMax;</span><br><span class="line">            <span class="keyword">float</span> _EndMin;</span><br><span class="line">            <span class="keyword">float</span> _EndMax;</span><br><span class="line">            <span class="keyword">float</span> _Scale;</span><br><span class="line">            <span class="function">v2f <span class="title">vert</span> <span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                half weight = max(smoothstep( _GrowMin, _GrowMax, v.uv.y - _Grow), smoothstep(_EndMin, _EndMax,v.uv.y ));</span><br><span class="line">                half3 weight_combine = weight * _Expend * <span class="number">0.01f</span>*v.normal;</span><br><span class="line">                half3 scale_combine = _Scale * <span class="number">0.01f</span> * v.normal;</span><br><span class="line">                half3 normal_combine = weight_combine + scale_combine;</span><br><span class="line">                v.vertex.xyz = v.vertex.xyz+ normal_combine;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_Target</span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                clip(<span class="number">1</span> - (i.uv.y - _Grow));</span><br><span class="line">                <span class="comment">// sample the texture</span></span><br><span class="line">                fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最近有一点偷懒，更新有点慢，新年快乐，新的一年，冲冲冲；</p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>TA1.6魔镜世界</title>
    <url>/2022/02/13/TA1.6%E9%AD%94%E9%95%9C%E4%B8%96%E7%95%8C/</url>
    <content><![CDATA[<h1 id="魔镜世界"><a href="#魔镜世界" class="headerlink" title="魔镜世界"></a>魔镜世界</h1><p><img src="https://img-blog.csdnimg.cn/708f8e4dc58e4eebb462a598386feb4b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/60384ee277de4032bb962961f62b6cce.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="渲染队列和颜色遮罩"><a href="#渲染队列和颜色遮罩" class="headerlink" title="渲染队列和颜色遮罩"></a>渲染队列和颜色遮罩</h2><h3 id="Rendering-Queue"><a href="#Rendering-Queue" class="headerlink" title="Rendering Queue"></a>Rendering Queue</h3><p>从小到大进行排序</p>
<p>几何体 2000</p>
<p>Alpha Test 2450</p>
<p>Transparent 3000</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;AlphaTest+10&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="Color-Mask"><a href="#Color-Mask" class="headerlink" title="Color Mask"></a>Color Mask</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ColorMask <span class="number">0</span></span><br><span class="line">ColorMask 相应的颜色通道</span><br></pre></td></tr></table></figure>



<h2 id="模板测试（Stencil）"><a href="#模板测试（Stencil）" class="headerlink" title="模板测试（Stencil）"></a>模板测试（Stencil）</h2><p>Reference 参数便于判端和筛选</p>
<p>Comparison 判断方式‘</p>
<p>Pass 面 通过之后的进行操作，图中是替换的意思</p>
<p>Fail 失败之后的操作</p>
<p>ZFail 深度测试失败的操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Stencil</span><br><span class="line">&#123;</span><br><span class="line">	Ref <span class="number">1</span></span><br><span class="line">	Comp always</span><br><span class="line">	Pass Replace</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="深度测试（Depth）"><a href="#深度测试（Depth）" class="headerlink" title="深度测试（Depth）"></a>深度测试（Depth）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ZWrite Off<span class="comment">//深度测试的开关</span></span><br><span class="line">ZTest Less<span class="comment">//深度小于当前缓存则通过</span></span><br><span class="line">ZTest Greater<span class="comment">//深度大于当前缓存则通过</span></span><br><span class="line">ZTest LEqual<span class="comment">//深度小于等于当前缓存则通过</span></span><br><span class="line">ZTest GEqual<span class="comment">//深度大于等于当前缓存则通过</span></span><br><span class="line">ZTest Equal<span class="comment">//深度等于当前缓存则通过</span></span><br><span class="line">ZTest NotEqual<span class="comment">//深度不等于当前缓存则通过</span></span><br><span class="line">ZTest Always<span class="comment">//不论如何都通过</span></span><br></pre></td></tr></table></figure>

<h2 id="制作过程"><a href="#制作过程" class="headerlink" title="制作过程"></a>制作过程</h2><h3 id="将材质导入dome"><a href="#将材质导入dome" class="headerlink" title="将材质导入dome"></a>将材质导入dome</h3><p>课程材料略</p>
<h3 id="制作镜子Shader"><a href="#制作镜子Shader" class="headerlink" title="制作镜子Shader"></a>制作镜子Shader</h3><h4 id="ASE图"><a href="#ASE图" class="headerlink" title="ASE图"></a>ASE图</h4><p><img src="https://img-blog.csdnimg.cn/24690538c7d74427947ec214b96eb3e9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/930c5704723d4d62824f52fb74543c7a.png" alt="在这里插入图片描述"></p>
<h4 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Tags &#123; <span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;AlphaTest+10&quot;</span>  &#125;</span><br><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">    ColorMask <span class="number">0</span></span><br><span class="line">    Stencil&#123;</span><br><span class="line">    Ref <span class="number">1</span></span><br><span class="line">    Comp always</span><br><span class="line">    Pass Replace</span><br><span class="line">    &#125;</span><br><span class="line">    ZWrite Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="制作镜内世界"><a href="#制作镜内世界" class="headerlink" title="制作镜内世界"></a>制作镜内世界</h3><h4 id="ASE图-1"><a href="#ASE图-1" class="headerlink" title="ASE图"></a>ASE图</h4><p><img src="https://img-blog.csdnimg.cn/846f665faf02464f9294ff2fc1919ac4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_10,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="核心代码-1"><a href="#核心代码-1" class="headerlink" title="核心代码"></a>核心代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Tags &#123; <span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;AlphaTest+20&quot;</span> &#125;</span><br><span class="line">Stencil&#123;</span><br><span class="line">	Ref <span class="number">1</span></span><br><span class="line">	Comp equal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="制作深度测试球"><a href="#制作深度测试球" class="headerlink" title="制作深度测试球"></a>制作深度测试球</h3><p>这一步是为了当模板测试未通过物体出现在魔镜后会出现在魔镜中的情况</p>
<p><img src="https://img-blog.csdnimg.cn/dfa1f68f67744d619a251839ec766106.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_13,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="ASE图-2"><a href="#ASE图-2" class="headerlink" title="ASE图"></a>ASE图</h4><p><img src="https://img-blog.csdnimg.cn/61e98110db744bd2afe357319cde1f6a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/1e5541da483f41b592e50bd9957dc801.png" alt="在这里插入图片描述"></p>
<h4 id="核心代码-2"><a href="#核心代码-2" class="headerlink" title="核心代码"></a>核心代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Tags &#123; <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;AlphaTest+15&quot;</span> &#125;</span><br><span class="line">	 LOD <span class="number">100</span></span><br><span class="line">	 Stencil&#123;</span><br><span class="line">	     Ref <span class="number">1</span></span><br><span class="line">	     Comp equal</span><br><span class="line">	 &#125;</span><br><span class="line">	 ZTest always</span><br></pre></td></tr></table></figure>

<h2 id="完成效果"><a href="#完成效果" class="headerlink" title="完成效果"></a>完成效果</h2><p><img src="https://img-blog.csdnimg.cn/ae35f733fb66487d8d5cbf13168e3b6f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>Shader的主要节点介绍</title>
    <url>/2022/02/20/Shader%E7%9A%84%E4%B8%BB%E8%A6%81%E8%8A%82%E7%82%B9%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>虽然学习很久了，但没有好好总结过shader用到的数学，以至于在用的过程中总是忘记，然后花时间去找，裂开，没有搞完的发现后后续补充。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="长度length-a"><a href="#长度length-a" class="headerlink" title="长度length(a)"></a>长度length(a)</h2><p>简单的欧式距离，根号下平方的那个。</p>
<h2 id="点乘dot（-a，b）"><a href="#点乘dot（-a，b）" class="headerlink" title="点乘dot（ a，b）"></a>点乘dot（ a，b）</h2><p>点乘是通过将对应分量逐个相乘，然后再把所得积相加来计算的。就是高中学的向量的乘法</p>
<p>v¯⋅k¯=||v¯||⋅||k¯||⋅cosθ</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(a1,a2,a3)⋅(b1,b2,b3)=a1*b1+a2* b2+a3*b3</span><br></pre></td></tr></table></figure>

<h3 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h3><p>当两个向量都是单位向量时就是两个向量的夹角的余弦值，常用于计算角度。</p>
<h2 id="叉乘cross（Lhs，Rhs）"><a href="#叉乘cross（Lhs，Rhs）" class="headerlink" title="叉乘cross（Lhs，Rhs）"></a>叉乘cross（Lhs，Rhs）</h2><p>叉乘只在3D空间中有定义，它需要两个不平行向量作为输入，生成一个正交于两个输入向量的第三个向量。如果输入的两个向量也是正交的，那么叉乘之后将会产生3个互相正交的向量。接下来的教程中这会非常有用。下面的图片展示了3D空间中叉乘的样子    ：</p>
<p><img src="https://learnopengl-cn.github.io/img/01/07/vectors_crossproduct.png" alt="叉乘图"></p>
<p><strong>注意：</strong>顺序在此运算符上很重要，因为 <strong>AxB</strong> 输出的结果与 <strong>BxA</strong> 不同（其结果类似于 <strong>-AxB</strong> ）。</p>
<p>c=cross（a,b）</p>
<p>c1=a2b3-a3b2</p>
<p>c2=a3b1-a1b3</p>
<p>c3=a1b2-a2b1</p>
<h3 id="用处-1"><a href="#用处-1" class="headerlink" title="用处"></a>用处</h3><p>得到两个向量做成平面的法向量；</p>
<h2 id="Saturate"><a href="#Saturate" class="headerlink" title="Saturate"></a>Saturate</h2><p>饱和节点输出在其上设置的向量的值或单个分量饱和到[0 1]范围。</p>
<ul>
<li><p><strong>0：</strong>如果输入小于 0，则返回此值</p>
</li>
<li><p><strong>输入：</strong>如果值介于 0 和 1 之间，则返回此值</p>
</li>
<li><p><strong>1：</strong>如果值大于 1，则返回此值</p>
<p><img src="http://amplify.pt/NodeDetail/SaturateGraphicNode.png"></p>
</li>
</ul>
<h2 id="线性插值lerf（a-b-weight）"><a href="#线性插值lerf（a-b-weight）" class="headerlink" title="线性插值lerf（a,b,weight）"></a>线性插值lerf（a,b,weight）</h2><p>公式(1-weight)×a+weight×b比较均匀，比较生硬</p>
<h2 id="clamp（input-min-max）"><a href="#clamp（input-min-max）" class="headerlink" title="clamp（input,min,max）"></a>clamp（input,min,max）</h2><p>Clamp 节点输出其输入值或夹紧在 Min， Max范围之间的矢量的各个分量。</p>
<ul>
<li><strong>最小值：</strong>如果输入值小于 Min，则返回此值</li>
<li><em><strong>输入：</strong></em>如果输入值介于最小值和最大值之间，则返回此值</li>
<li><strong>最大值：</strong>如果输入值大于 Max，则返回此值</li>
</ul>
<h2 id="平滑阶梯smoothstep-min-max-input"><a href="#平滑阶梯smoothstep-min-max-input" class="headerlink" title="平滑阶梯smoothstep(min,max,input)"></a>平滑阶梯smoothstep(min,max,input)</h2><p>Clamp 节点输出其输入值或夹紧在 Min， Max范围之间的矢量的各个分量。</p>
<ul>
<li><strong>最小值：</strong>如果输入值小于 Min，则返回0</li>
<li><em><strong>输入：</strong></em>如果输入值介于最小值和最大值之间，则返回clamp（（input-min）/（max-min），0，1）</li>
<li><strong>最大值：</strong>如果输入值大于 Max，则返回1</li>
</ul>
<p><img src="http://amplify.pt/NodeDetail/SmoothstepGraphicNode.png"></p>
<h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>还在总结中</p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>后处理技术（上）</title>
    <url>/2022/02/20/TA5%E5%90%8E%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF1/</url>
    <content><![CDATA[<h1 id="后处理（上）"><a href="#后处理（上）" class="headerlink" title="后处理（上）"></a>后处理（上）</h1><h2 id="启用后处理"><a href="#启用后处理" class="headerlink" title="启用后处理"></a>启用后处理</h2><p>在摄像头添加脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">[ExecuteInEditMode()]//编辑模式就能看到效果</span><br><span class="line">public class CameraPostPress : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public Material mat;</span><br><span class="line">    // Start is called before the first frame update</span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        if(mat==null||SystemInfo.supportsImageEffects==false||mat.shader==null||mat.shader.isSupported==false) &#123;</span><br><span class="line">            enabled = false;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void OnRenderImage(RenderTexture source, RenderTexture destination) &#123;</span><br><span class="line">        //当渲染图片启用   source是帧处理的图片 0是pass的顺序</span><br><span class="line">        Graphics.Blit(source,destination,mat, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="背景板"><a href="#背景板" class="headerlink" title="背景板"></a>背景板</h2><p><img src="https://img-blog.csdnimg.cn/d5c8641a1ca14b439e5c36b1b84949da.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>只要物体能拓展到屏幕上，就能让图片平铺到图片上，在片源部分做</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">half2 screen_uv = i.screen_pos.xy / (i.screen_pos.w + <span class="number">0.000001</span>);</span><br><span class="line">screen_uv = (screen_uv + <span class="number">1.0</span>) * <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure>

<p>注意的是dx的y轴是反的</p>
<p>有三套解决方案</p>
<h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">v2f <span class="title">vert</span> <span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    o.uv = v.uv;</span><br><span class="line">    o.screen_pos = o.vertex;</span><br><span class="line">    o.screen_pos.y = -o.screen_pos.y;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_Target</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    half2 screen_uv = i.screen_pos.xy / (i.screen_pos.w + <span class="number">0.000001</span>);</span><br><span class="line">    screen_uv = (screen_uv + <span class="number">1.0</span>) * <span class="number">0.5</span>; </span><br><span class="line">    <span class="comment">// sample the texture</span></span><br><span class="line">    fixed4 col = tex2D(_MainTex, screen_uv);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">v2f <span class="title">vert</span> <span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    o.uv = v.uv;</span><br><span class="line">    o.screen_pos = o.vertex;</span><br><span class="line">    o.screen_pos.y = o.screen_pos.y * _ProjectionParams.x;<span class="comment">//改变</span></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_Target</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    half2 screen_uv = i.screen_pos.xy / (i.screen_pos.w + <span class="number">0.000001</span>);</span><br><span class="line">    screen_uv = (screen_uv + <span class="number">1.0</span>) * <span class="number">0.5</span>;</span><br><span class="line">    <span class="comment">// sample the texture</span></span><br><span class="line">    fixed4 col = tex2D(_MainTex, screen_uv);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">v2f <span class="title">vert</span> <span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    o.uv = v.uv;</span><br><span class="line">    o.screen_pos=ComputeScreenPos(o.vertex);<span class="comment">//改变</span></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;<span class="function">c</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_Target</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    half2 screen_uv = i.screen_pos.xy / (i.screen_pos.w + <span class="number">0.000001</span>);</span><br><span class="line">       <span class="comment">//改变</span></span><br><span class="line">    <span class="comment">// sample the texture</span></span><br><span class="line">    fixed4 col = tex2D(_MainTex, screen_uv);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="背景板代码"><a href="#背景板代码" class="headerlink" title="背景板代码"></a>背景板代码</h3><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unlit/Quad&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            <span class="comment">// make fog work</span></span><br><span class="line">           </span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float4 screen_pos:TEXCOORD1;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = v.uv;</span><br><span class="line">                <span class="comment">//o.screen_pos = o.vertex;</span></span><br><span class="line">                <span class="comment">//o.screen_pos.y = -o.screen_pos.y;</span></span><br><span class="line">                o.screen_pos=ComputeScreenPos(o.vertex);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                half2 screen_uv = i.screen_pos.xy / (i.screen_pos.w + <span class="number">0.000001</span>);</span><br><span class="line">                screen_uv = (screen_uv + <span class="number">1.0</span>) * <span class="number">0.5</span>;</span><br><span class="line">                <span class="comment">// sample the texture</span></span><br><span class="line">                fixed4 col = tex2D(_MainTex, screen_uv);</span><br><span class="line">               </span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="调色"><a href="#调色" class="headerlink" title="调色"></a>调色</h2><p><img src="https://img-blog.csdnimg.cn/67f8be49624b4c17be5c5d3a4f3100d7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="ASE"><a href="#ASE" class="headerlink" title="ASE"></a>ASE</h3><p><img src="https://img-blog.csdnimg.cn/68a7f0f72c9645ff8b3eb0c407796880.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><h4 id="色调"><a href="#色调" class="headerlink" title="色调"></a>色调</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">float3 <span class="title">HSVToRGB</span><span class="params">(float3 c)</span> </span>&#123;</span><br><span class="line">    float4 K = float4(<span class="number">1.0</span>, <span class="number">2.0</span> / <span class="number">3.0</span>, <span class="number">1.0</span> / <span class="number">3.0</span>, <span class="number">3.0</span>);</span><br><span class="line">    float3 p = <span class="built_in">abs</span>(frac(c.xxx + K.xyz) * <span class="number">6.0</span> - K.www);</span><br><span class="line">    <span class="keyword">return</span> c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//RGB B*lerp(float3(1.0,1.0,1.0)) frac 取小数部分 色调（H），饱和度（S），明度（V）。</span></span><br><span class="line"><span class="comment">//H=B*lerp(1.0f,saturate(abs(frac(R + 1.0) * 6.0 - 3.0) - 1.0f),G)</span></span><br><span class="line"><span class="comment">//S=B*lerp(1.0f,saturate(abs(frac(R +  2.0 / 3.0) * 6.0 - 3.0) - 1.0f),G)</span></span><br><span class="line"><span class="comment">//V=B*lerp(1.0f,saturate(abs(frac(R +  1.0 / 3.0) * 6.0 - 3.0) - 1.0f),G)</span></span><br><span class="line"><span class="function">float3 <span class="title">RGBToHSV</span><span class="params">(float3 c)</span> </span>&#123;</span><br><span class="line">    float4 K = float4(<span class="number">0.0</span>, <span class="number">-1.0</span> / <span class="number">3.0</span>, <span class="number">2.0</span> / <span class="number">3.0</span>, <span class="number">-1.0</span>);</span><br><span class="line">    float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));</span><br><span class="line">    float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));</span><br><span class="line">    <span class="keyword">float</span> d = q.x - min(q.w, q.y);</span><br><span class="line">    <span class="keyword">float</span> e = <span class="number">1.0e-10</span>;</span><br><span class="line">    <span class="keyword">return</span> float3(<span class="built_in">abs</span>(q.z + (q.w - q.y) / (<span class="number">6.0</span> * d + e)), d / (q.x + e), q.x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="亮度"><a href="#亮度" class="headerlink" title="亮度"></a>亮度</h4><p>简单粗暴直接乘</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">col.rgb=col.rgb*_Brightness;</span><br></pre></td></tr></table></figure>

<h4 id="饱和度"><a href="#饱和度" class="headerlink" title="饱和度"></a>饱和度</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> lumin=dot(col.rgb,float3(<span class="number">0.22</span>,<span class="number">0.707</span>,<span class="number">0.071</span>));</span><br><span class="line">col.rgb=lerp(lumin,col.rgb,_Saturation);</span><br></pre></td></tr></table></figure>

<h4 id="对比度"><a href="#对比度" class="headerlink" title="对比度"></a>对比度</h4><p>float3(0.5,0.5,0.5)是灰色</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">col.rgb=lerp(float3(<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>),col.rgb,_Contrast);</span><br></pre></td></tr></table></figure>

<h4 id="暗角-晕影"><a href="#暗角-晕影" class="headerlink" title="暗角/晕影"></a>暗角/晕影</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">float2 d=<span class="built_in">abs</span>(i.uv<span class="number">-0.5</span>)*_VignetteIntensity;</span><br><span class="line">d=<span class="built_in">pow</span>(saturate(d),_VignetteRoundness);</span><br><span class="line"><span class="keyword">float</span> dist=length(d);</span><br><span class="line">col.rgb=<span class="built_in">pow</span>(saturate(<span class="number">1.0</span>-dist*dist),_VignetteSmoothness)*col.rgb;</span><br></pre></td></tr></table></figure>

<h3 id="调色代码"><a href="#调色代码" class="headerlink" title="调色代码"></a>调色代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Hidden/Color_Code&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Brightness(<span class="string">&quot;Brightness&quot;</span>, Float) = <span class="number">1</span></span><br><span class="line">        _Saturation(<span class="string">&quot;Saturation&quot;</span>,Float) = <span class="number">1</span></span><br><span class="line">        _Contrast(<span class="string">&quot;Contrast&quot;</span>,Float) = <span class="number">1</span></span><br><span class="line">        _VignetteIntensity(<span class="string">&quot;VignetteIntensity&quot;</span>,Range(<span class="number">0.05</span>,<span class="number">3.0</span>)) = <span class="number">1.5</span></span><br><span class="line">        _VignetteRoundness(<span class="string">&quot;VignetteRoundness&quot;</span>,Range(<span class="number">1</span>,<span class="number">6</span>)) = <span class="number">5</span></span><br><span class="line">        _VignetteSmoothness(<span class="string">&quot;VignetteSmoothness&quot;</span>,Range(<span class="number">0.05</span>,<span class="number">5</span>)) = <span class="number">5</span></span><br><span class="line">        _HueShift(<span class="string">&quot;HueShift&quot;</span>,Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// No culling or depth</span></span><br><span class="line">        Cull Off ZWrite Off ZTest Always</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> vertex vert_img</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">            float3 HSVToRGB(float3 c) &#123;</span><br><span class="line">                float4 K = float4(<span class="number">1.0</span>, <span class="number">2.0</span> / <span class="number">3.0</span>, <span class="number">1.0</span> / <span class="number">3.0</span>, <span class="number">3.0</span>);</span><br><span class="line">                float3 p = <span class="built_in">abs</span>(frac(c.xxx + K.xyz) * <span class="number">6.0</span> - K.www);</span><br><span class="line">                <span class="keyword">return</span> c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//RGB B*lerp(float3(1.0,1.0,1.0)) frac 取小数部分 色调（H），饱和度（S），明度（V）。</span></span><br><span class="line">            <span class="comment">//H=B*lerp(1.0f,saturate(abs(frac(R + 1.0) * 6.0 - 3.0) - 1.0f),G)</span></span><br><span class="line">            <span class="comment">//S=B*lerp(1.0f,saturate(abs(frac(R +  2.0 / 3.0) * 6.0 - 3.0) - 1.0f),G)</span></span><br><span class="line">            <span class="comment">//V=B*lerp(1.0f,saturate(abs(frac(R +  1.0 / 3.0) * 6.0 - 3.0) - 1.0f),G)</span></span><br><span class="line">            <span class="function">float3 <span class="title">RGBToHSV</span><span class="params">(float3 c)</span> </span>&#123;</span><br><span class="line">                float4 K = float4(<span class="number">0.0</span>, <span class="number">-1.0</span> / <span class="number">3.0</span>, <span class="number">2.0</span> / <span class="number">3.0</span>, <span class="number">-1.0</span>);</span><br><span class="line">                float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));</span><br><span class="line">                float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));</span><br><span class="line">                <span class="keyword">float</span> d = q.x - min(q.w, q.y);</span><br><span class="line">                <span class="keyword">float</span> e = <span class="number">1.0e-10</span>;</span><br><span class="line">                <span class="keyword">return</span> float3(<span class="built_in">abs</span>(q.z + (q.w - q.y) / (<span class="number">6.0</span> * d + e)), d / (q.x + e), q.x);</span><br><span class="line">            &#125;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            <span class="keyword">float</span> _Brightness;</span><br><span class="line">            <span class="keyword">float</span> _Saturation;</span><br><span class="line">            <span class="keyword">float</span> _Contrast;</span><br><span class="line">            <span class="keyword">float</span> _VignetteIntensity;</span><br><span class="line">            <span class="keyword">float</span> _VignetteRoundness;</span><br><span class="line">            <span class="keyword">float</span> _VignetteSmoothness;</span><br><span class="line">            <span class="keyword">float</span> _HueShift;</span><br><span class="line"></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span> <span class="params">(v2f_img i)</span> : SV_Target</span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                </span><br><span class="line">                fixed4 sourse = tex2D(_MainTex, i.uv);</span><br><span class="line">                fixed4 col=sourse;</span><br><span class="line">                <span class="comment">//色相</span></span><br><span class="line">                fixed3 hsv = RGBToHSV(sourse.rgb);</span><br><span class="line">                hsv.r= hsv.r +_HueShift;</span><br><span class="line">                col.rgb=HSVToRGB(hsv);</span><br><span class="line">                <span class="comment">//亮度</span></span><br><span class="line">                col.rgb=col.rgb*_Brightness;</span><br><span class="line">                <span class="comment">//饱和度</span></span><br><span class="line">                <span class="keyword">float</span> lumin=dot(col.rgb,float3(<span class="number">0.22</span>,<span class="number">0.707</span>,<span class="number">0.071</span>));</span><br><span class="line">                col.rgb=lerp(lumin,col.rgb,_Saturation);</span><br><span class="line">                <span class="comment">//对比度</span></span><br><span class="line">                col.rgb=lerp(float3(<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>),col.rgb,_Contrast);</span><br><span class="line">                <span class="comment">//暗角/晕影</span></span><br><span class="line">                float2 d=<span class="built_in">abs</span>(i.uv<span class="number">-0.5</span>)*_VignetteIntensity;</span><br><span class="line"></span><br><span class="line">                d=<span class="built_in">pow</span>(saturate(d),_VignetteRoundness);</span><br><span class="line">                <span class="keyword">float</span> dist=length(d);</span><br><span class="line">                col.rgb=<span class="built_in">pow</span>(saturate(<span class="number">1.0</span>-dist*dist),_VignetteSmoothness)*col.rgb; </span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="破碎的玻璃"><a href="#破碎的玻璃" class="headerlink" title="破碎的玻璃"></a>破碎的玻璃</h2><p><img src="https://img-blog.csdnimg.cn/bdbfbc20fb5140fa916c22f3d7e11676.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="上玻璃"><a href="#上玻璃" class="headerlink" title="上玻璃"></a>上玻璃</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> aspect = _ScreenParams.x / _ScreenParams.y; <span class="comment">// x = width y = height z = 1 + 1.0/width w = 1 + 1.0/height</span></span><br><span class="line">float2 glass_uv = float2(i.uv.x * aspect, i.uv.y) * _GlassMask_ST.xy + _GlassMask_ST.zw;</span><br><span class="line"></span><br><span class="line">half glass_opacity = tex2D(_GlassMask, glass_uv).r;</span><br><span class="line">finalcolor = lerp(finalcolor, _GlassCrack.xxx, glass_opacity);</span><br></pre></td></tr></table></figure>

<h3 id="上法线"><a href="#上法线" class="headerlink" title="上法线"></a>上法线</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">half3 glass_normal = UnpackNormal(tex2D(_GlassNormal, glass_uv));</span><br></pre></td></tr></table></figure>

<h3 id="解决边缘法线贴图重影"><a href="#解决边缘法线贴图重影" class="headerlink" title="解决边缘法线贴图重影"></a>解决边缘法线贴图重影</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">half2 d = <span class="number">1.0</span> - smoothstep(<span class="number">0.95</span>,<span class="number">1</span>,<span class="built_in">abs</span>(i.uv * <span class="number">2.0</span> - <span class="number">1.0</span>));</span><br><span class="line">half vfactor = d.x * d.y;</span><br></pre></td></tr></table></figure>

<h3 id="解决法线贴图毛玻璃的问题"><a href="#解决法线贴图毛玻璃的问题" class="headerlink" title="解决法线贴图毛玻璃的问题"></a>解决法线贴图毛玻璃的问题</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">float2 d_mask = step(<span class="number">0.005</span>, <span class="built_in">abs</span>(glass_normal.xy));</span><br><span class="line"><span class="keyword">float</span> mask = d_mask.x * d_mask.y;</span><br><span class="line">half2 uv_distort = i.uv + glass_normal.xy * _Distort * vfactor * mask;</span><br><span class="line">half4 col = tex2D(_MainTex, uv_distort);</span><br></pre></td></tr></table></figure>

<h3 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Hidden/BrokenGlass&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">	Properties</span><br><span class="line">	&#123;</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">		_GlassMask(<span class="string">&quot;GlassMask&quot;</span>,<span class="number">2</span>D) = <span class="string">&quot;black&quot;</span>&#123;&#125;</span><br><span class="line">		_GlassCrack(<span class="string">&quot;GlassCrack&quot;</span>,Float) = <span class="number">1</span></span><br><span class="line">		_GlassNormal(<span class="string">&quot;GlassNormal&quot;</span>,<span class="number">2</span>D) = <span class="string">&quot;bump&quot;</span>&#123;&#125;</span><br><span class="line">		_Distort(<span class="string">&quot;Distort&quot;</span>,Float) = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// No culling or depth</span></span><br><span class="line">		Cull Off ZWrite Off ZTest Always</span><br><span class="line"></span><br><span class="line">		Pass</span><br><span class="line">		&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert_img</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">		</span><br><span class="line">			sampler2D _MainTex;</span><br><span class="line">			sampler2D _GlassMask;</span><br><span class="line">			float4 _GlassMask_ST;</span><br><span class="line">			<span class="keyword">float</span> _GlassCrack;</span><br><span class="line">			sampler2D _GlassNormal;</span><br><span class="line">			<span class="keyword">float</span> _Distort;</span><br><span class="line"></span><br><span class="line">			<span class="function">half4 <span class="title">frag</span> <span class="params">(v2f_img i)</span> : SV_Target</span></span><br><span class="line"><span class="function">			</span>&#123;</span><br><span class="line">				<span class="keyword">float</span> aspect = _ScreenParams.x / _ScreenParams.y; <span class="comment">// x = width y = height z = 1 + 1.0/width w = 1 + 1.0/height</span></span><br><span class="line">				float2 glass_uv = float2(i.uv.x * aspect, i.uv.y) * _GlassMask_ST.xy + _GlassMask_ST.zw;</span><br><span class="line"></span><br><span class="line">				half glass_opacity = tex2D(_GlassMask, glass_uv).r;</span><br><span class="line">				half3 glass_normal = UnpackNormal(tex2D(_GlassNormal, glass_uv));</span><br><span class="line"></span><br><span class="line">				half2 d = <span class="number">1.0</span> - smoothstep(<span class="number">0.95</span>,<span class="number">1</span>,<span class="built_in">abs</span>(i.uv * <span class="number">2.0</span> - <span class="number">1.0</span>));</span><br><span class="line">				half vfactor = d.x * d.y;</span><br><span class="line"></span><br><span class="line">				float2 d_mask = step(<span class="number">0.005</span>, <span class="built_in">abs</span>(glass_normal.xy));</span><br><span class="line">				<span class="keyword">float</span> mask = d_mask.x * d_mask.y;</span><br><span class="line"></span><br><span class="line">				half2 uv_distort = i.uv + glass_normal.xy * _Distort * vfactor * mask;</span><br><span class="line">				half4 col = tex2D(_MainTex, uv_distort);</span><br><span class="line">				half3 finalcolor = col.rgb;</span><br><span class="line">				finalcolor = lerp(finalcolor, _GlassCrack.xxx, glass_opacity);</span><br><span class="line">				<span class="keyword">return</span> float4(finalcolor,col.a);</span><br><span class="line">			&#125;</span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>后处理技术（中）</title>
    <url>/2022/02/22/TA5%E5%90%8E%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF2/</url>
    <content><![CDATA[<h1 id="模糊处理"><a href="#模糊处理" class="headerlink" title="模糊处理"></a>模糊处理</h1><p>本文章参考<a href="https://zhuanlan.zhihu.com/p/125744132">毛星云大佬的文章</a>学习，十分推荐看大佬的原文<img src="https://pic3.zhimg.com/80/v2-c2a9906331826e66f66ffda71192411a_720w.jpg"></p>
<p><strong>降采样是常见的优化性能的方法减少中间贴图的尺寸大小</strong></p>
<p><strong>产生的中间贴图一定要记得释放内存，否则造成内存泄漏</strong></p>
<p><strong>在for循环的中间贴图也要记得释放内存</strong></p>
<h1 id="课程的4种常用的模糊算法"><a href="#课程的4种常用的模糊算法" class="headerlink" title="课程的4种常用的模糊算法"></a>课程的4种常用的模糊算法</h1><h2 id="盒状模糊或均值模糊（Box-Blur）"><a href="#盒状模糊或均值模糊（Box-Blur）" class="headerlink" title="盒状模糊或均值模糊（Box Blur）"></a>盒状模糊或均值模糊（Box Blur）</h2><p>最简单的模糊方式，取一个2*2的卷积核，四个数权重都为0.25，取一个像素的四角的像素叠加乘0.25</p>
<p><img src="https://img-blog.csdnimg.cn/b3aa70f8bcb943be9a634b4a5b87acf4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>（-1，-1）（1，-1）（-1，1）（1，1）四个点位叠加除4；</p>
<p>当然卷积核的值可自己调</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="BoxBlur-cs"><a href="#BoxBlur-cs" class="headerlink" title="BoxBlur.cs"></a>BoxBlur.cs</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">[ExecuteInEditMode()]</span><br><span class="line">public class BoxBlur : MonoBehaviour &#123;</span><br><span class="line">    public Material material;</span><br><span class="line">    [Range(0, 10)]</span><br><span class="line">    public int _Iteration = 4;</span><br><span class="line">    [Range(0, 15)]</span><br><span class="line">    public float _BlurRadius = 5.0f;</span><br><span class="line">    [Range(1, 10)]</span><br><span class="line">    public float _DownSample = 2.0f;</span><br><span class="line"></span><br><span class="line">    void Start () &#123;</span><br><span class="line">        if (material == null || SystemInfo.supportsImageEffects == false</span><br><span class="line">            || material.shader == null || material.shader.isSupported == false)</span><br><span class="line">        &#123;</span><br><span class="line">            enabled = false;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void OnRenderImage(RenderTexture source, RenderTexture destination)</span><br><span class="line">    &#123;</span><br><span class="line">        int width = (int)(source.width / _DownSample);</span><br><span class="line">        int height = (int)(source.height / _DownSample);</span><br><span class="line">        RenderTexture RT1 = RenderTexture.GetTemporary(width,height);</span><br><span class="line">        RenderTexture RT2 = RenderTexture.GetTemporary(width, height);</span><br><span class="line"></span><br><span class="line">        Graphics.Blit(source, RT1);</span><br><span class="line"></span><br><span class="line">        material.SetVector(&quot;_BlurOffset&quot;, new Vector4(_BlurRadius / source.width, _BlurRadius / source.height, 0,0));</span><br><span class="line">        for (int i = 0; i &lt; _Iteration; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Graphics.Blit(RT1, RT2, material, 0);</span><br><span class="line">            Graphics.Blit(RT2, RT1, material, 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Graphics.Blit(RT1, destination);</span><br><span class="line"></span><br><span class="line">        //release</span><br><span class="line">        RenderTexture.ReleaseTemporary(RT1);</span><br><span class="line">        RenderTexture.ReleaseTemporary(RT2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="BoxBlur-shader"><a href="#BoxBlur-shader" class="headerlink" title="BoxBlur.shader"></a>BoxBlur.shader</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Hidden/BoxBlur&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">	CGINCLUDE</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">	sampler2D _MainTex;</span><br><span class="line">	float4 _BlurOffset;</span><br><span class="line"></span><br><span class="line">	<span class="function">half4 <span class="title">frag_BoxFilter_4Tap</span><span class="params">(v2f_img i)</span> : SV_Target</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		half4 d = _BlurOffset.xyxy * half4(<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">		half4 s = <span class="number">0</span>;</span><br><span class="line">		s += tex2D(_MainTex, i.uv + d.xy);</span><br><span class="line">		s += tex2D(_MainTex, i.uv + d.zy);</span><br><span class="line">		s += tex2D(_MainTex, i.uv + d.xw);</span><br><span class="line">		s += tex2D(_MainTex, i.uv + d.zw);</span><br><span class="line">		s *= <span class="number">0.25</span>;</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">half4 <span class="title">frag_BoxFilter_9Tap</span><span class="params">(v2f_img i)</span> : SV_Target</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//half4 d = _BlurOffset.xyxy * half4(-1,1,0,0);</span></span><br><span class="line">		half4 d = _BlurOffset.xyxy * half4(<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		half4 s = <span class="number">0</span>;</span><br><span class="line">		s = tex2D(_MainTex, i.uv);</span><br><span class="line"></span><br><span class="line">		s += tex2D(_MainTex, i.uv + d.xy);</span><br><span class="line">		s += tex2D(_MainTex, i.uv + d.zy);</span><br><span class="line">		s += tex2D(_MainTex, i.uv + d.xw);</span><br><span class="line">		s += tex2D(_MainTex, i.uv + d.zw);</span><br><span class="line"></span><br><span class="line">		s += tex2D(_MainTex, i.uv + half2(<span class="number">0.0</span>, d.w)); <span class="comment">// 0 1</span></span><br><span class="line">		s += tex2D(_MainTex, i.uv + half2(<span class="number">0.0</span>, d.y)); <span class="comment">// 0 -1</span></span><br><span class="line">		s += tex2D(_MainTex, i.uv + half2(d.z,<span class="number">0.0</span>)); <span class="comment">// 1 0</span></span><br><span class="line">		s += tex2D(_MainTex, i.uv + half2(d.x, <span class="number">0.0</span>)); <span class="comment">// -1 0</span></span><br><span class="line"></span><br><span class="line">		s = s/ <span class="number">9.0</span>;</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ENDCG</span><br><span class="line"></span><br><span class="line">	Properties</span><br><span class="line">	&#123;</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">		_BlurOffset(<span class="string">&quot;BlurOffset&quot;</span>,Float) = <span class="number">1</span> </span><br><span class="line">	&#125;</span><br><span class="line">	SubShader</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// No culling or depth</span></span><br><span class="line">		Cull Off ZWrite Off ZTest Always</span><br><span class="line">		<span class="comment">//0pass 4tap</span></span><br><span class="line">		Pass</span><br><span class="line">		&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert_img</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag_BoxFilter_4Tap</span></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//1pass 9tap</span></span><br><span class="line">		Pass</span><br><span class="line">		&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert_img</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag_BoxFilter_9Tap</span></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="高斯模糊（Gaussian-Blur）"><a href="#高斯模糊（Gaussian-Blur）" class="headerlink" title="高斯模糊（Gaussian Blur）"></a>高斯模糊（Gaussian Blur）</h2><p>特定的权重，离像素点越远权重越小</p>
<p>下图为高斯函数的3维图示：</p>
<p><img src="https://pic4.zhimg.com/80/v2-d6af23aafa14caec06b3a1790b6d92e3_720w.jpg"></p>
<p>0.05 0.25 0.40 0.25 0.05权值</p>
<p>和盒状模糊差不多，效果会好一点</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><h4 id="GaussianBlur-cs"><a href="#GaussianBlur-cs" class="headerlink" title="GaussianBlur.cs"></a>GaussianBlur.cs</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">[ExecuteInEditMode()]</span><br><span class="line">public class GaussianBlur : MonoBehaviour &#123;</span><br><span class="line">    public Material material;</span><br><span class="line">    [Range(0, 10)]</span><br><span class="line">    public int _Iteration = 4;</span><br><span class="line">    [Range(0, 15)]</span><br><span class="line">    public float _BlurRadius = 5.0f;</span><br><span class="line">    [Range(1, 10)]</span><br><span class="line">    public float _DownSample = 2.0f;</span><br><span class="line"></span><br><span class="line">    void Start () &#123;</span><br><span class="line">        if (material == null || SystemInfo.supportsImageEffects == false</span><br><span class="line">            || material.shader == null || material.shader.isSupported == false)</span><br><span class="line">        &#123;</span><br><span class="line">            enabled = false;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void OnRenderImage(RenderTexture source, RenderTexture destination)</span><br><span class="line">    &#123;</span><br><span class="line">        int width = (int)(source.width / _DownSample);</span><br><span class="line">        int height = (int)(source.height / _DownSample);</span><br><span class="line">        RenderTexture RT1 = RenderTexture.GetTemporary(width,height);</span><br><span class="line">        RenderTexture RT2 = RenderTexture.GetTemporary(width, height);</span><br><span class="line"></span><br><span class="line">        Graphics.Blit(source, RT1);</span><br><span class="line"></span><br><span class="line">        material.SetVector(&quot;_BlurOffset&quot;, new Vector4(_BlurRadius / source.width, _BlurRadius / source.height, 0,0));</span><br><span class="line">        for (int i = 0; i &lt; _Iteration; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Graphics.Blit(RT1, RT2, material, 0); //水平方向</span><br><span class="line">            Graphics.Blit(RT2, RT1, material, 1); //垂直方向</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Graphics.Blit(RT1, destination);</span><br><span class="line"></span><br><span class="line">        //release</span><br><span class="line">        RenderTexture.ReleaseTemporary(RT1);</span><br><span class="line">        RenderTexture.ReleaseTemporary(RT2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="GaussianBlur-shader"><a href="#GaussianBlur-shader" class="headerlink" title="GaussianBlur.shader"></a>GaussianBlur.shader</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Hidden/GaussianBlur&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">	CGINCLUDE</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">	sampler2D _MainTex;</span><br><span class="line">	float4 _BlurOffset;</span><br><span class="line"></span><br><span class="line">	<span class="function">half4 <span class="title">frag_HorizontalBlur</span><span class="params">(v2f_img i)</span> : SV_Target</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		half2 uv1 = i.uv + _BlurOffset.xy * half2(<span class="number">1</span>, <span class="number">0</span>) * <span class="number">-2.0</span>;</span><br><span class="line">		half2 uv2 = i.uv + _BlurOffset.xy * half2(<span class="number">1</span>, <span class="number">0</span>) * <span class="number">-1.0</span>;</span><br><span class="line">		half2 uv3 = i.uv;</span><br><span class="line">		half2 uv4 = i.uv + _BlurOffset.xy * half2(<span class="number">1</span>, <span class="number">0</span>) * <span class="number">1.0</span>;</span><br><span class="line">		half2 uv5 = i.uv + _BlurOffset.xy * half2(<span class="number">1</span>, <span class="number">0</span>) * <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line">		half4 s = <span class="number">0</span>;</span><br><span class="line">		s += tex2D(_MainTex, uv1) * <span class="number">0.05</span>;</span><br><span class="line">		s += tex2D(_MainTex, uv2) * <span class="number">0.25</span>;</span><br><span class="line">		s += tex2D(_MainTex, uv3) * <span class="number">0.40</span>;</span><br><span class="line">		s += tex2D(_MainTex, uv4) * <span class="number">0.25</span>;</span><br><span class="line">		s += tex2D(_MainTex, uv5) * <span class="number">0.05</span>;</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">half4 <span class="title">frag_VerticalBlur</span><span class="params">(v2f_img i)</span> : SV_Target</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		half2 uv1 = i.uv + _BlurOffset.xy * half2(<span class="number">0</span>, <span class="number">1</span>) * <span class="number">-2.0</span>;</span><br><span class="line">		half2 uv2 = i.uv + _BlurOffset.xy * half2(<span class="number">0</span>, <span class="number">1</span>) * <span class="number">-1.0</span>;</span><br><span class="line">		half2 uv3 = i.uv;</span><br><span class="line">		half2 uv4 = i.uv + _BlurOffset.xy * half2(<span class="number">0</span>, <span class="number">1</span>) * <span class="number">1.0</span>;</span><br><span class="line">		half2 uv5 = i.uv + _BlurOffset.xy * half2(<span class="number">0</span>, <span class="number">1</span>) * <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line">		half4 s = <span class="number">0</span>;</span><br><span class="line">		s += tex2D(_MainTex, uv1) * <span class="number">0.05</span>;</span><br><span class="line">		s += tex2D(_MainTex, uv2) * <span class="number">0.25</span>;</span><br><span class="line">		s += tex2D(_MainTex, uv3) * <span class="number">0.40</span>;</span><br><span class="line">		s += tex2D(_MainTex, uv4) * <span class="number">0.25</span>;</span><br><span class="line">		s += tex2D(_MainTex, uv5) * <span class="number">0.05</span>;</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ENDCG</span><br><span class="line"></span><br><span class="line">	Properties</span><br><span class="line">	&#123;</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">		_BlurOffset(<span class="string">&quot;BlurOffset&quot;</span>,Float) = <span class="number">1</span> </span><br><span class="line">	&#125;</span><br><span class="line">	SubShader</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// No culling or depth</span></span><br><span class="line">		Cull Off ZWrite Off ZTest Always</span><br><span class="line">		<span class="comment">//0</span></span><br><span class="line">		Pass</span><br><span class="line">		&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert_img</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag_HorizontalBlur</span></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//1</span></span><br><span class="line">		Pass</span><br><span class="line">		&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert_img</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag_VerticalBlur</span></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="双重模糊"><a href="#双重模糊" class="headerlink" title="双重模糊"></a>双重模糊</h2><p>双重的核心思想是先降采样，然后升采样。</p>
<p>相较于Kawase Blur在两个大小相等的纹理之间进行乒乓blit的的思路，Dual Kawase Blur的核心思路在于blit过程中进行降采样和升采样,即对RT进行了降采样以及升采样。如下图所示：</p>
<p><img src="https://pic4.zhimg.com/80/v2-4226f0fd81e3f2ed61b48995e269328f_720w.jpg"></p>
<h3 id="双重-Kawase-模糊（Dual-Kawase-Blur）"><a href="#双重-Kawase-模糊（Dual-Kawase-Blur）" class="headerlink" title="双重 Kawase 模糊（Dual Kawase Blur）"></a>双重 Kawase 模糊（Dual Kawase Blur）</h3><p>双重 Kawase 模糊和双重盒状模糊模糊是最常用的，前者常用于移动端，后者都行，两个的性能和质量都优于之前两种算法</p>
<h4 id="Kawase模糊"><a href="#Kawase模糊" class="headerlink" title="Kawase模糊"></a>Kawase模糊</h4><p>Kawase Blur的思路是对距离当前像素越来越远的地方对四个角进行采样</p>
<p><img src="https://pic4.zhimg.com/80/v2-5ef03cc98ed2ed9a22dee30ce2915e7f_720w.jpg"></p>
<p>所以中间的权重为4/8，其余四角为1/8；</p>
<p>单独的Kawase算法性能太差了，淘汰。</p>
<h4 id="Dual-Kawase-Blur"><a href="#Dual-Kawase-Blur" class="headerlink" title="Dual Kawase Blur"></a>Dual Kawase Blur</h4><p>Dual Kawase Blur，简称Dual Blur，是SIGGRAPH 2015上ARM团队提出的一种衍生自Kawase Blur的模糊算法。其由两种不同的Blur Kernel构成，如下图所示。<img src="https://pic1.zhimg.com/80/v2-1ae54eb0e154d542ff6acdae06232bdc_720w.jpg"></p>
<p><img src="https://img-blog.csdnimg.cn/e92e5664bde1419f830f6a0e5dc9b91a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>这个贴图怕是只有我看的懂了，图一的1图代表红色的框框，第二个代表整个框框</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><h4 id="DualKawaseBlur-cs"><a href="#DualKawaseBlur-cs" class="headerlink" title="DualKawaseBlur.cs"></a>DualKawaseBlur.cs</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line"></span><br><span class="line">[RequireComponent(typeof(Camera))]</span><br><span class="line">[ExecuteInEditMode]</span><br><span class="line"></span><br><span class="line">public class DualKawaseBlur : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    public Material material;</span><br><span class="line">    [Range(0,15)]</span><br><span class="line">    public float _BlurRadius = 5.0f;</span><br><span class="line">    [Range(0, 10)]</span><br><span class="line">    public int _Iteration = 4;</span><br><span class="line">    [Range(1, 10)]</span><br><span class="line">    public float _DownSample = 2.0f;</span><br><span class="line"></span><br><span class="line">    List&lt;RenderTexture&gt; _tempRTList = new List&lt;RenderTexture&gt;();</span><br><span class="line"></span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        if (!SystemInfo.supportsImageEffects || null == material ||</span><br><span class="line">           null == material.shader || !material.shader.isSupported)</span><br><span class="line">        &#123;</span><br><span class="line">            enabled = false;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void OnRenderImage(RenderTexture source, RenderTexture destination)</span><br><span class="line">    &#123;</span><br><span class="line">        int RTWidth = (int)(source.width / _DownSample);</span><br><span class="line">        int RTHeight = (int)(source.height / _DownSample);</span><br><span class="line">        RenderTexture RT1 = RenderTexture.GetTemporary(RTWidth, RTHeight, 0);</span><br><span class="line">        RenderTexture RT2 = null;</span><br><span class="line">        material.SetFloat(&quot;_Offset&quot;, _BlurRadius);</span><br><span class="line">        Graphics.Blit(source, RT1, material, 0);</span><br><span class="line">//降采样</span><br><span class="line">        for (int i = 0; i &lt; _Iteration; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            RenderTexture.ReleaseTemporary(RT2);</span><br><span class="line">            RTWidth = RTWidth / 2;</span><br><span class="line">            RTHeight = RTHeight / 2;</span><br><span class="line">            RT2 = RenderTexture.GetTemporary(RTWidth, RTHeight);</span><br><span class="line">            Graphics.Blit(RT1, RT2, material, 0);</span><br><span class="line"></span><br><span class="line">            RTWidth = RTWidth / 2;</span><br><span class="line">            RTHeight = RTHeight / 2;</span><br><span class="line">            RenderTexture.ReleaseTemporary(RT1);</span><br><span class="line">            RT1 = RenderTexture.GetTemporary(RTWidth, RTHeight);</span><br><span class="line">            Graphics.Blit(RT2, RT1, material, 0);</span><br><span class="line">        &#125;</span><br><span class="line">//升采样</span><br><span class="line">        for (int i = 0; i &lt; _Iteration; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            RenderTexture.ReleaseTemporary(RT2);</span><br><span class="line">            RTWidth = RTWidth * 2;</span><br><span class="line">            RTHeight = RTHeight * 2;</span><br><span class="line">            RT2 = RenderTexture.GetTemporary(RTWidth, RTHeight);</span><br><span class="line">            Graphics.Blit(RT1, RT2, material, 1);</span><br><span class="line"></span><br><span class="line">            RTWidth = RTWidth * 2;</span><br><span class="line">            RTHeight = RTHeight * 2;</span><br><span class="line">            RenderTexture.ReleaseTemporary(RT1);</span><br><span class="line">            RT1 = RenderTexture.GetTemporary(RTWidth, RTHeight);</span><br><span class="line">            Graphics.Blit(RT2, RT1, material, 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Graphics.Blit(RT1, destination, material, 1);</span><br><span class="line"></span><br><span class="line">        // release</span><br><span class="line">        RenderTexture.ReleaseTemporary(RT1);</span><br><span class="line">        RenderTexture.ReleaseTemporary(RT2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="DualKawaseBlur-shader"><a href="#DualKawaseBlur-shader" class="headerlink" title="DualKawaseBlur.shader"></a>DualKawaseBlur.shader</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Hidden/DualKawaseBlur&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">	CGINCLUDE</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">	uniform sampler2D _MainTex;</span><br><span class="line">	uniform float4 _MainTex_TexelSize;</span><br><span class="line">	uniform half _Offset;</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">v2f_DownSample</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		float4 pos: SV_POSITION;</span><br><span class="line">		float2 uv: TEXCOORD1;</span><br><span class="line">		float4 uv01: TEXCOORD2;</span><br><span class="line">		float4 uv23: TEXCOORD3;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">v2f_UpSample</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		float4 pos: SV_POSITION;</span><br><span class="line">		float4 uv01: TEXCOORD1;</span><br><span class="line">		float4 uv23: TEXCOORD2;</span><br><span class="line">		float4 uv45: TEXCOORD3;</span><br><span class="line">		float4 uv67: TEXCOORD4;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function">v2f_DownSample <span class="title">Vert_DownSample</span><span class="params">(appdata_img v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		v2f_DownSample o;</span><br><span class="line">		o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">		</span><br><span class="line">		_MainTex_TexelSize = <span class="number">0.5</span> * _MainTex_TexelSize;</span><br><span class="line">		float2 uv = v.texcoord;</span><br><span class="line">		o.uv = uv;</span><br><span class="line">		o.uv01.xy = uv - _MainTex_TexelSize * float2(<span class="number">1</span> + _Offset, <span class="number">1</span> + _Offset);<span class="comment">//top right</span></span><br><span class="line">		o.uv01.zw = uv + _MainTex_TexelSize * float2(<span class="number">1</span> + _Offset, <span class="number">1</span> + _Offset);<span class="comment">//bottom left</span></span><br><span class="line">		o.uv23.xy = uv - float2(_MainTex_TexelSize.x, -_MainTex_TexelSize.y) * float2(<span class="number">1</span> + _Offset, <span class="number">1</span> + _Offset);<span class="comment">//top left</span></span><br><span class="line">		o.uv23.zw = uv + float2(_MainTex_TexelSize.x, -_MainTex_TexelSize.y) * float2(<span class="number">1</span> + _Offset, <span class="number">1</span> + _Offset);<span class="comment">//bottom right</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> o;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function">half4 <span class="title">Frag_DownSample</span><span class="params">(v2f_DownSample i)</span>: SV_Target</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		half4 sum = tex2D(_MainTex, i.uv) * <span class="number">4</span>;</span><br><span class="line">		sum += tex2D(_MainTex, i.uv01.xy);</span><br><span class="line">		sum += tex2D(_MainTex, i.uv01.zw);</span><br><span class="line">		sum += tex2D(_MainTex, i.uv23.xy);</span><br><span class="line">		sum += tex2D(_MainTex, i.uv23.zw);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> sum * <span class="number">0.125</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function">v2f_UpSample <span class="title">Vert_UpSample</span><span class="params">(appdata_img v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		v2f_UpSample o;</span><br><span class="line">		o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">	</span><br><span class="line">		float2 uv = v.texcoord;</span><br><span class="line">		</span><br><span class="line">		_MainTex_TexelSize = <span class="number">0.5</span> * _MainTex_TexelSize;</span><br><span class="line">		_Offset = float2(<span class="number">1</span> + _Offset, <span class="number">1</span> + _Offset);</span><br><span class="line">		</span><br><span class="line">		o.uv01.xy = uv + float2(-_MainTex_TexelSize.x * <span class="number">2</span>, <span class="number">0</span>) * _Offset;<span class="comment">//-2,0</span></span><br><span class="line">		o.uv01.zw = uv + float2(-_MainTex_TexelSize.x, _MainTex_TexelSize.y) * _Offset;<span class="comment">//-1 1</span></span><br><span class="line">		o.uv23.xy = uv + float2(<span class="number">0</span>, _MainTex_TexelSize.y * <span class="number">2</span>) * _Offset;<span class="comment">//0 2</span></span><br><span class="line">		o.uv23.zw = uv + _MainTex_TexelSize * _Offset;<span class="comment">//1 1</span></span><br><span class="line">		o.uv45.xy = uv + float2(_MainTex_TexelSize.x * <span class="number">2</span>, <span class="number">0</span>) * _Offset;<span class="comment">//2 0</span></span><br><span class="line">		o.uv45.zw = uv + float2(_MainTex_TexelSize.x, -_MainTex_TexelSize.y) * _Offset;<span class="comment">//1 -1</span></span><br><span class="line">		o.uv67.xy = uv + float2(<span class="number">0</span>, -_MainTex_TexelSize.y * <span class="number">2</span>) * _Offset;<span class="comment">//0 -2</span></span><br><span class="line">		o.uv67.zw = uv - _MainTex_TexelSize * _Offset;<span class="comment">// -1 -1</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> o;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function">half4 <span class="title">Frag_UpSample</span><span class="params">(v2f_UpSample i)</span>: SV_Target</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		half4 sum = <span class="number">0</span>;</span><br><span class="line">		sum += tex2D(_MainTex, i.uv01.xy);</span><br><span class="line">		sum += tex2D(_MainTex, i.uv01.zw) * <span class="number">2</span>;</span><br><span class="line">		sum += tex2D(_MainTex, i.uv23.xy);</span><br><span class="line">		sum += tex2D(_MainTex, i.uv23.zw) * <span class="number">2</span>;</span><br><span class="line">		sum += tex2D(_MainTex, i.uv45.xy);</span><br><span class="line">		sum += tex2D(_MainTex, i.uv45.zw) * <span class="number">2</span>;</span><br><span class="line">		sum += tex2D(_MainTex, i.uv67.xy);</span><br><span class="line">		sum += tex2D(_MainTex, i.uv67.zw) * <span class="number">2</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> sum * <span class="number">0.0833</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	ENDCG</span><br><span class="line">	Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex(<span class="string">&quot;&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	SubShader</span><br><span class="line">	&#123;</span><br><span class="line">		Cull Off ZWrite Off ZTest Always</span><br><span class="line">		</span><br><span class="line">		Pass</span><br><span class="line">		&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex Vert_DownSample</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment Frag_DownSample	</span></span><br><span class="line">			ENDCG		</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Pass</span><br><span class="line">		&#123;</span><br><span class="line">			CGPROGRAM	</span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex Vert_UpSample</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment Frag_UpSample</span></span><br><span class="line">			ENDCG</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双重盒状模糊（Dual-Box-Blur）"><a href="#双重盒状模糊（Dual-Box-Blur）" class="headerlink" title="双重盒状模糊（Dual Box Blur）"></a>双重盒状模糊（Dual Box Blur）</h4><p>对原来的Box进行双重采样就行，最常用的算法。</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><h4 id="DualBoxBlur-cs"><a href="#DualBoxBlur-cs" class="headerlink" title="DualBoxBlur.cs"></a>DualBoxBlur.cs</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">[ExecuteInEditMode()]</span><br><span class="line">public class DualBoxBlur : MonoBehaviour &#123;</span><br><span class="line">    public Material material;</span><br><span class="line">    [Range(0, 10)]</span><br><span class="line">    public int _Iteration = 4;</span><br><span class="line">    [Range(0, 15)]</span><br><span class="line">    public float _BlurRadius = 5.0f;</span><br><span class="line">    [Range(1, 10)]</span><br><span class="line">    public float _DownSample = 2.0f;</span><br><span class="line"></span><br><span class="line">    void Start () &#123;</span><br><span class="line">        if (material == null || SystemInfo.supportsImageEffects == false</span><br><span class="line">            || material.shader == null || material.shader.isSupported == false)</span><br><span class="line">        &#123;</span><br><span class="line">            enabled = false;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void OnRenderImage(RenderTexture source, RenderTexture destination)</span><br><span class="line">    &#123;</span><br><span class="line">        int width = (int)(source.width / _DownSample);</span><br><span class="line">        int height = (int)(source.height / _DownSample);</span><br><span class="line">        RenderTexture RT1 = RenderTexture.GetTemporary(width,height);</span><br><span class="line">        RenderTexture RT2 = RenderTexture.GetTemporary(width, height);</span><br><span class="line"></span><br><span class="line">        Graphics.Blit(source, RT1);</span><br><span class="line"></span><br><span class="line">        material.SetVector(&quot;_BlurOffset&quot;, new Vector4(_BlurRadius / source.width, _BlurRadius / source.height, 0,0));</span><br><span class="line">        //降采样</span><br><span class="line">        for (int i = 0; i &lt; _Iteration; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            RenderTexture.ReleaseTemporary(RT2);</span><br><span class="line">            width = width / 2;</span><br><span class="line">            height = height / 2;</span><br><span class="line">            RT2 = RenderTexture.GetTemporary(width, height);</span><br><span class="line">            Graphics.Blit(RT1, RT2, material, 0);</span><br><span class="line"></span><br><span class="line">            RenderTexture.ReleaseTemporary(RT1);</span><br><span class="line">            width = width / 2;</span><br><span class="line">            height = height / 2;</span><br><span class="line">            RT1 = RenderTexture.GetTemporary(width, height);</span><br><span class="line">            Graphics.Blit(RT2, RT1, material, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        //升采样</span><br><span class="line">        for (int i = 0; i &lt; _Iteration; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            RenderTexture.ReleaseTemporary(RT2);</span><br><span class="line">            width = width * 2;</span><br><span class="line">            height = height * 2;</span><br><span class="line">            RT2 = RenderTexture.GetTemporary(width, height);</span><br><span class="line">            Graphics.Blit(RT1, RT2, material, 0);</span><br><span class="line"></span><br><span class="line">            RenderTexture.ReleaseTemporary(RT1);</span><br><span class="line">            width = width * 2;</span><br><span class="line">            height = height * 2;</span><br><span class="line">            RT1 = RenderTexture.GetTemporary(width, height);</span><br><span class="line">            Graphics.Blit(RT2, RT1, material, 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Graphics.Blit(RT1, destination);</span><br><span class="line"></span><br><span class="line">        //release</span><br><span class="line">        RenderTexture.ReleaseTemporary(RT1);</span><br><span class="line">        RenderTexture.ReleaseTemporary(RT2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>就之前的BoxBlur.shader。</p>
<h1 id="其余算法"><a href="#其余算法" class="headerlink" title="其余算法"></a>其余算法</h1><p>可以参考毛星云大佬的其他算法。</p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>后处理技术（下）</title>
    <url>/2022/02/24/TA5%E5%90%8E%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF3/</url>
    <content><![CDATA[<h1 id="HDRBloom（光晕）"><a href="#HDRBloom（光晕）" class="headerlink" title="HDRBloom（光晕）"></a>HDRBloom（光晕）</h1><p>取亮光部分，进行降采样，在升采样的过程中，叠加降采样对应尺寸的图片，合并效果图和源图片</p>
<h2 id="初处理"><a href="#初处理" class="headerlink" title="初处理"></a>初处理</h2><p>如果放入的是HDR图片，可以在shader里面加float4 _MainTex_HDR;   col.rgb  = DecodeHDR(col,_MainTex_HDR);进行解码。</p>
<h2 id="取光亮部分"><a href="#取光亮部分" class="headerlink" title="取光亮部分"></a>取光亮部分</h2><p>先进行均值模糊，取亮色部分。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float intensity = Mathf.Exp(_Intensity / 10.0f * 0.693f) - 1.0f;</span><br><span class="line"></span><br><span class="line">mat.SetFloat(&quot;_Threshold&quot;, _Threshold);</span><br><span class="line">mat.SetFloat(&quot;_Intensity&quot;, intensity);</span><br><span class="line"></span><br><span class="line">//取亮色</span><br><span class="line">Graphics.Blit(source, RT_Down[0], mat, 0);</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">half4 <span class="title">frag_PreFilter</span><span class="params">(v2f_img i)</span> : SV_Target<span class="comment">//0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    half4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">    half4 d=_MainTex_TexelSize.xyxy*half4(<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">    col.rgb+=tex2D(_MainTex,i.uv+d.xy).rgb;</span><br><span class="line">    col.rgb+=tex2D(_MainTex,i.uv+d.zy).rgb;</span><br><span class="line">    col.rgb+=tex2D(_MainTex,i.uv+d.xw).rgb;</span><br><span class="line">    col.rgb+=tex2D(_MainTex,i.uv+d.zw).rgb;</span><br><span class="line">    col.rgb*=<span class="number">0.25</span>;</span><br><span class="line">    <span class="keyword">float</span> br = max(max(col.r,col.g),col.b);</span><br><span class="line">    br =  max(<span class="number">0</span>,(br - _Threshold))/max(<span class="number">0.00001</span>,br);</span><br><span class="line">    col.rgb*=br;</span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="降采样"><a href="#降采样" class="headerlink" title="降采样"></a>降采样</h2><p>用双重盒状模糊的降采样方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//降采样</span><br><span class="line">for(int i=0;i&lt;_Iteration;i++) &#123;//0-i-1</span><br><span class="line">    Graphics.Blit(RT_Down[i], RT_Down[i + 1], mat, 1);</span><br><span class="line">   // print(&quot;downcode &quot; + i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">half4 <span class="title">frag_DownsampleBox</span><span class="params">(v2f_img i)</span> : SV_Target<span class="comment">//1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    half4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">    half4 d=_MainTex_TexelSize.xyxy*half4(<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">    col.rgb+=tex2D(_MainTex,i.uv+d.xy).rgb;</span><br><span class="line">    col.rgb+=tex2D(_MainTex,i.uv+d.zy).rgb;</span><br><span class="line">    col.rgb+=tex2D(_MainTex,i.uv+d.xw).rgb;</span><br><span class="line">    col.rgb+=tex2D(_MainTex,i.uv+d.zw).rgb;</span><br><span class="line">    col.rgb*=<span class="number">0.25</span>;</span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="升采样"><a href="#升采样" class="headerlink" title="升采样"></a>升采样</h2><p>升采样过程中加同尺寸的降采样贴图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Graphics.Blit(RT_Down[_Iteration], RT_Up[_Iteration]);</span><br><span class="line">for(int i=_Iteration;i&gt;0;i--) &#123;</span><br><span class="line">    mat.SetTexture(&quot;_BloomTex&quot;, RT_Down[i-1]);</span><br><span class="line">    Graphics.Blit(RT_Up[i], RT_Up[i-1], mat, 2);</span><br><span class="line">    //print(&quot;upcode &quot; + i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">half4 <span class="title">frag_UpsampleBox</span><span class="params">(v2f_img i)</span> : SV_Target<span class="comment">//2</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    half4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">    half4 d=_MainTex_TexelSize.xyxy*half4(<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">    col.rgb+=tex2D(_MainTex,i.uv+d.xy).rgb;</span><br><span class="line">    col.rgb+=tex2D(_MainTex,i.uv+d.zy).rgb;</span><br><span class="line">    col.rgb+=tex2D(_MainTex,i.uv+d.xw).rgb;</span><br><span class="line">    col.rgb+=tex2D(_MainTex,i.uv+d.zw).rgb;</span><br><span class="line">    col.rgb*=<span class="number">0.25</span>;</span><br><span class="line">    half4 color2 = tex2D(_BloomTex, i.uv);</span><br><span class="line">    <span class="keyword">return</span> col + color2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>把升采样的最后一张图和原图合并,和释放贴图。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mat.SetTexture(&quot;_BloomTex&quot;, RT_Up[0]);</span><br><span class="line">Graphics.Blit(source, destination, mat, 3);</span><br><span class="line">//Release</span><br><span class="line">//RenderTexture.ReleaseTemporary(RT1);</span><br><span class="line">for (int i = 0; i &lt; _Iteration+1; i++) &#123;</span><br><span class="line">   // print(&quot;Release &quot; + i);</span><br><span class="line"></span><br><span class="line">    RenderTexture.ReleaseTemporary(RT_Down[i]);</span><br><span class="line">    RenderTexture.ReleaseTemporary(RT_Up[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">half4 <span class="title">frag_Combine</span><span class="params">(v2f_img i)</span> : SV_Target<span class="comment">//3</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    half4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">    half3 color1 = tex2D(_BloomTex, i.uv).rgb;</span><br><span class="line">    col.rgb+= color1.rgb*_Intensity;</span><br><span class="line">    <span class="keyword">return</span> col ;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h2 id="最后小瑕疵"><a href="#最后小瑕疵" class="headerlink" title="最后小瑕疵"></a>最后小瑕疵</h2><p>在光晕的周围还有点不自然。可用如下解决方案。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">float3 <span class="title">ACES_Tonemapping</span><span class="params">(float3 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> a = <span class="number">2.51f</span>;</span><br><span class="line">	<span class="keyword">float</span> b = <span class="number">0.03f</span>;</span><br><span class="line">	<span class="keyword">float</span> c = <span class="number">2.43f</span>;</span><br><span class="line">	<span class="keyword">float</span> d = <span class="number">0.59f</span>;</span><br><span class="line">	<span class="keyword">float</span> e = <span class="number">0.14f</span>;</span><br><span class="line">	float3 encode_color = saturate((x*(a*x + b)) / (x*(c*x + d) + e));</span><br><span class="line">	<span class="keyword">return</span> encode_color;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">half4 <span class="title">frag</span> <span class="params">(v2f_img i)</span> : SV_Target</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	half4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">	half3 linear_color = <span class="built_in">pow</span>(col.rgb, <span class="number">2.2</span>);</span><br><span class="line">	half3 encode_color = ACES_Tonemapping(linear_color);</span><br><span class="line">	half3 final_color = <span class="built_in">pow</span>(encode_color, <span class="number">1.0</span> / <span class="number">2.2</span>);</span><br><span class="line">	<span class="keyword">return</span> float4(final_color,col.a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="后处理的顺序"><a href="#后处理的顺序" class="headerlink" title="后处理的顺序"></a>后处理的顺序</h1><p><img src="https://img-blog.csdnimg.cn/3c671e3fee7c4999bd942e25acf1ea62.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>调整顺序：Bloom-&gt;Vignette-&gt;Tonemapping-&gt;ColorGrading</p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>TA2.1光照模型与法线贴图</title>
    <url>/2022/02/14/TA2.1%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="渲染路径"><a href="#渲染路径" class="headerlink" title="渲染路径"></a>渲染路径</h1><h2 id="前向渲染"><a href="#前向渲染" class="headerlink" title="前向渲染"></a>前向渲染</h2><p>对每一个物体每一个光源进行渲染，超出范围的灯光以顶点灯光渲染，适用于灯光较少的情况</p>
<h3 id="ForwardBase"><a href="#ForwardBase" class="headerlink" title="ForwardBase"></a>ForwardBase</h3><p>在这个Pass里面，主方向灯以及超出范围的灯光作为顶点灯光传入SH，   LightMap，Reflection， Probe等计算均在这个Pass里面完成。</p>
<h3 id="ForwardAdd"><a href="#ForwardAdd" class="headerlink" title="ForwardAdd"></a>ForwardAdd</h3><p>数量范围内的灯光，每个灯光的计算，均会调用一次这个pass，计算的结果通过Blend one one 叠加起来。</p>
<h2 id="延迟渲染"><a href="#延迟渲染" class="headerlink" title="延迟渲染"></a>延迟渲染</h2><p> 使用MRT技术 ，RT0是物体的颜色，RT1是金属反射的颜色，RT2是法线数据，RT4是深度信息。</p>
<p>光源直接渲染一次。有带宽和设备支持的限制，ue4和HDRP默认。</p>
<h1 id="法线贴图"><a href="#法线贴图" class="headerlink" title="法线贴图"></a>法线贴图</h1><h2 id="法线"><a href="#法线" class="headerlink" title="法线"></a>法线</h2><p>顶点垂直模型的线NORMAL</p>
<h2 id="切线"><a href="#切线" class="headerlink" title="切线"></a>切线</h2><p>UV中u递增的线或者v递增的线，引擎帮我们生成的TANGENT</p>
<h2 id="副切线"><a href="#副切线" class="headerlink" title="副切线"></a>副切线</h2><p> 法线叉乘切线得到的。</p>
<h1 id="unity的无光照shader获得光源信息实战"><a href="#unity的无光照shader获得光源信息实战" class="headerlink" title="unity的无光照shader获得光源信息实战"></a>unity的无光照shader获得光源信息实战</h1><h2 id="ForwardBase-Pass"><a href="#ForwardBase-Pass" class="headerlink" title="ForwardBase Pass"></a>ForwardBase Pass</h2><h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><p>需要将光照模式调为ForwardBase</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>在编写时加入如下引用文件以方便获取光照参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdbase</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AutoLight.cginc&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>appadata</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">appdata</span></span><br><span class="line">       &#123;</span><br><span class="line">           float4 vertex : POSITION;</span><br><span class="line">           float2 uv : TEXCOORD0;</span><br><span class="line">           float3 normal:NORMAL;<span class="comment">//法线</span></span><br><span class="line">           float4 tangent:TANGENT;<span class="comment">//切线注意是四维向量，w用来矫正平台的区别</span></span><br><span class="line">       &#125;;</span><br></pre></td></tr></table></figure>

<p>片元数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">v2f</span></span><br><span class="line">       &#123;</span><br><span class="line">           float2 uv : TEXCOORD0;</span><br><span class="line">           float4 vertex : SV_POSITION;</span><br><span class="line">           float3 normali_dir:TEXCOORD1;</span><br><span class="line">           float3 tangent_dir:TEXCOORD2;</span><br><span class="line">           float3 binormal_dir:TEXCOORD3;</span><br><span class="line">           float3 pos_world:TEXCOORD4;</span><br><span class="line"></span><br><span class="line">       &#125;;</span><br></pre></td></tr></table></figure>

<p>光源数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">half3 light_dir =<span class="built_in">normalize</span>( _WorldSpaceLightPos0.xyz );<span class="comment">//定向光位置无意义所以代表光照方向</span></span><br></pre></td></tr></table></figure>



<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Pass</span><br><span class="line">      &#123;</span><br><span class="line">          Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span>&#125;</span><br><span class="line">          </span><br><span class="line">          CGPROGRAM</span><br><span class="line">          <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">          <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">          <span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdbase</span></span><br><span class="line">          <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">          <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AutoLight.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">struct</span> appdata</span><br><span class="line">          &#123;</span><br><span class="line">              float4 vertex : POSITION;</span><br><span class="line">              float2 uv : TEXCOORD0;</span><br><span class="line">              float3 normal:NORMAL;</span><br><span class="line">              float4 tangent:TANGENT;</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">struct</span> <span class="title class_">v2f</span></span><br><span class="line">          &#123;</span><br><span class="line">              float2 uv : TEXCOORD0;</span><br><span class="line">              float4 vertex : SV_POSITION;</span><br><span class="line">              float3 normali_dir:TEXCOORD1;</span><br><span class="line">              float3 tangent_dir:TEXCOORD2;</span><br><span class="line">              float3 binormal_dir:TEXCOORD3;</span><br><span class="line">              float3 pos_world:TEXCOORD4;</span><br><span class="line"></span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          sampler2D _MainTex;</span><br><span class="line">          float4 _MainTex_ST;</span><br><span class="line">          sampler2D _AOMap;</span><br><span class="line">          float4 _AOMap_ST;</span><br><span class="line">          float4 _LightColor0;</span><br><span class="line">          <span class="type">float</span> _Shininess;</span><br><span class="line">          <span class="type">float</span> _SpecularIntensity;</span><br><span class="line">          float4 _AmbientColor; </span><br><span class="line">          sampler2D _SpecMask;</span><br><span class="line">          <span class="type">float</span> _SpecMask_ST; </span><br><span class="line">          sampler2D _NormalMap;</span><br><span class="line">          float4 _NormalMap_ST; </span><br><span class="line">          <span class="type">float</span> _NormalIntensity;</span><br><span class="line">          <span class="type">float</span> __AmbientIntensity;</span><br><span class="line"></span><br><span class="line">          <span class="function">float3 <span class="title">ACESFilm</span><span class="params">(float3 x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">float</span> a = <span class="number">2.51f</span>;</span><br><span class="line">    <span class="type">float</span> b = <span class="number">0.03f</span>;</span><br><span class="line">    <span class="type">float</span> c = <span class="number">2.43f</span>;</span><br><span class="line">    <span class="type">float</span> d = <span class="number">0.59f</span>;</span><br><span class="line">    <span class="type">float</span> e = <span class="number">0.14f</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">saturate</span>((x*(a*x + b)) / (x*(c*x + d) + e));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">          <span class="function">v2f <span class="title">vert</span> <span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function">          </span>&#123;</span><br><span class="line">              v2f o;</span><br><span class="line">              o.vertex = <span class="built_in">UnityObjectToClipPos</span>(v.vertex);</span><br><span class="line">              o.normali_dir = <span class="built_in">normalize</span>(<span class="built_in">mul</span>(<span class="built_in">float4</span>(v.normal,<span class="number">0.0</span>),unity_WorldToObject).xyz);</span><br><span class="line">              o.tangent_dir = <span class="built_in">normalize</span>(<span class="built_in">mul</span>(<span class="built_in">float4</span>(v.tangent.xyz,<span class="number">0.0</span>),unity_WorldToObject).xyz);</span><br><span class="line">              o.binormal_dir = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(o.normali_dir,o.tangent_dir))* v.tangent.w;</span><br><span class="line">              o.pos_world = <span class="built_in">mul</span>(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line">              o.uv = <span class="built_in">TRANSFORM_TEX</span>(v.uv, _MainTex);</span><br><span class="line">              <span class="keyword">return</span> o;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="function">fixed4 <span class="title">frag</span> <span class="params">(v2f i)</span> : SV_Target</span></span><br><span class="line"><span class="function">          &#123;</span></span><br><span class="line">              fixed4 col=<span class="built_in">fixed4</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">              half3 AO = <span class="built_in">tex2D</span>(_AOMap,i.uv).xyz;</span><br><span class="line">              half3 spec_mask = <span class="built_in">tex2D</span>(_SpecMask,i.uv).xyz;</span><br><span class="line">              half4 normalmap = <span class="built_in">tex2D</span>(_NormalMap,i.uv);</span><br><span class="line"></span><br><span class="line">              half3 view_dir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.pos_world);</span><br><span class="line">              half3 light_dir =<span class="built_in">normalize</span>( _WorldSpaceLightPos0.xyz );</span><br><span class="line"></span><br><span class="line">              <span class="comment">//Normal</span></span><br><span class="line">              half3 normal_dir  =<span class="built_in">normalize</span>(i.normali_dir);</span><br><span class="line">              half3 tangent_dir  =<span class="built_in">normalize</span>(i.tangent_dir)*_NormalIntensity;</span><br><span class="line">              half3 binormal_dir =<span class="built_in">normalize</span>(i.binormal_dir)*_NormalIntensity;</span><br><span class="line">              half3 normal_data = <span class="built_in">UnpackNormal</span>(normalmap);</span><br><span class="line">              float3x3 TBN = <span class="built_in">float3x3</span>(tangent_dir,binormal_dir,normal_dir);</span><br><span class="line">              normal_dir =<span class="built_in">normalize</span>(<span class="built_in">mul</span>(normal_data,TBN));</span><br><span class="line">              <span class="comment">//normal_dir=tangent_dir*normal_data.x*_NormalIntensity+binormal_dir*normal_data.y*_NormalIntensity+normal_dir*normal_data.z ;</span></span><br><span class="line">              </span><br><span class="line">              half NotL = <span class="built_in">max</span>(<span class="built_in">dot</span>(normal_dir,light_dir),<span class="number">0</span>);</span><br><span class="line">              half3 diffuse =  NotL*_LightColor0.xyz;</span><br><span class="line">              half3 specular =  <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(<span class="built_in">reflect</span>(-light_dir,normal_dir),view_dir),<span class="number">0</span>),_Shininess)* _LightColor0.xyz*_SpecularIntensity*spec_mask;</span><br><span class="line">              half3 ambient =  _AmbientColor.xyz*__AmbientIntensity;</span><br><span class="line">              </span><br><span class="line">              <span class="comment">//col.xyz+= AO;</span></span><br><span class="line"></span><br><span class="line">              col.xyz += diffuse;</span><br><span class="line">              col.xyz += specular;</span><br><span class="line">              col.xyz += ambient;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// sample the texture</span></span><br><span class="line">              col.xyz *=<span class="built_in">tex2D</span>(_MainTex, i.uv).xyz;</span><br><span class="line">              col.xyz *=AO;</span><br><span class="line">              <span class="comment">// apply fog</span></span><br><span class="line">              <span class="keyword">return</span> col;</span><br><span class="line">          &#125;</span><br><span class="line">          ENDCG</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h2 id="ForwardAdd-Pass"><a href="#ForwardAdd-Pass" class="headerlink" title="ForwardAdd Pass"></a>ForwardAdd Pass</h2><h3 id="关键点-1"><a href="#关键点-1" class="headerlink" title="关键点"></a>关键点</h3><p>需要将光照模式调为ForwardAdd</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardAdd&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>要加混合模式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Blend One One</span><br></pre></td></tr></table></figure>

<p>在编写时加入如下引用文件以方便获取光照参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdadd</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AutoLight.cginc&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>appadata</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">appdata</span></span><br><span class="line">       &#123;</span><br><span class="line">           float4 vertex : POSITION;</span><br><span class="line">           float2 uv : TEXCOORD0;</span><br><span class="line">           float3 normal:NORMAL;<span class="comment">//法线</span></span><br><span class="line">           float4 tangent:TANGENT;<span class="comment">//切线注意是四维向量，w用来矫正平台的区别</span></span><br><span class="line">       &#125;;</span><br></pre></td></tr></table></figure>

<p>片元数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">v2f</span></span><br><span class="line">       &#123;</span><br><span class="line">           float2 uv : TEXCOORD0;</span><br><span class="line">           float4 vertex : SV_POSITION;</span><br><span class="line">           float3 normali_dir:TEXCOORD1;</span><br><span class="line">           float3 tangent_dir:TEXCOORD2;</span><br><span class="line">           float3 binormal_dir:TEXCOORD3;</span><br><span class="line">           float3 pos_world:TEXCOORD4;</span><br><span class="line"></span><br><span class="line">       &#125;;</span><br></pre></td></tr></table></figure>

<p>光源数据</p>
<p>如果是定向光的话和ForwardBase是一样的，但如果是点光源的话应考虑衰减量和光照方向</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">half3 light_dir =<span class="built_in">normalize</span>( _WorldSpaceLightPos0.xyz-i.pos_world.xyz ); </span><br><span class="line">            half distance=<span class="built_in">length</span>(_WorldSpaceLightPos0.xyz-i.pos_world.xyz);</span><br><span class="line">            <span class="type">float</span> range = <span class="number">1.0</span>/unity_WorldToLight[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            half attuenation =<span class="built_in">saturate</span>((range-distance)/range);</span><br></pre></td></tr></table></figure>

<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">     Pass</span><br><span class="line">     &#123;</span><br><span class="line">         Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardAdd&quot;</span>&#125;</span><br><span class="line">         Blend One One</span><br><span class="line">         CGPROGRAM</span><br><span class="line">         <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">         <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">         <span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdadd</span></span><br><span class="line">         <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">         <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AutoLight.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">struct</span> appdata</span><br><span class="line">         &#123;</span><br><span class="line">             float4 vertex : POSITION;</span><br><span class="line">             float2 uv : TEXCOORD0;</span><br><span class="line">             float3 normal:NORMAL;</span><br><span class="line">             float4 tangent:TANGENT;</span><br><span class="line">         &#125;;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">struct</span> <span class="title class_">v2f</span></span><br><span class="line">         &#123;</span><br><span class="line">             float2 uv : TEXCOORD0;</span><br><span class="line">             float4 vertex : SV_POSITION;</span><br><span class="line">             float3 normali_dir:TEXCOORD1;</span><br><span class="line">             float3 tangent_dir:TEXCOORD2;</span><br><span class="line">             float3 binormal_dir:TEXCOORD3;</span><br><span class="line">             float3 pos_world:TEXCOORD4;</span><br><span class="line"></span><br><span class="line">         &#125;;</span><br><span class="line"></span><br><span class="line">         sampler2D _MainTex;</span><br><span class="line">         float4 _MainTex_ST;</span><br><span class="line">         sampler2D _AOMap;</span><br><span class="line">         float4 _AOMap_ST;</span><br><span class="line">         float4 _LightColor0;</span><br><span class="line">         <span class="type">float</span> _Shininess;</span><br><span class="line">         <span class="type">float</span> _SpecularIntensity;</span><br><span class="line">         float4 _AmbientColor; </span><br><span class="line">         sampler2D _SpecMask;</span><br><span class="line">         <span class="type">float</span> _SpecMask_ST; </span><br><span class="line">         sampler2D _NormalMap;</span><br><span class="line">         float4 _NormalMap_ST; </span><br><span class="line">         <span class="type">float</span> _NormalIntensity;</span><br><span class="line"></span><br><span class="line">         <span class="function">float3 <span class="title">ACESFilm</span><span class="params">(float3 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">float</span> a = <span class="number">2.51f</span>;</span><br><span class="line">  <span class="type">float</span> b = <span class="number">0.03f</span>;</span><br><span class="line">  <span class="type">float</span> c = <span class="number">2.43f</span>;</span><br><span class="line">  <span class="type">float</span> d = <span class="number">0.59f</span>;</span><br><span class="line">  <span class="type">float</span> e = <span class="number">0.14f</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">saturate</span>((x*(a*x + b)) / (x*(c*x + d) + e));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">         <span class="function">v2f <span class="title">vert</span> <span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function">         </span>&#123;</span><br><span class="line">             v2f o;</span><br><span class="line">             o.vertex = <span class="built_in">UnityObjectToClipPos</span>(v.vertex);</span><br><span class="line">             o.normali_dir = <span class="built_in">normalize</span>(<span class="built_in">mul</span>(<span class="built_in">float4</span>(v.normal,<span class="number">0.0</span>),unity_WorldToObject).xyz);</span><br><span class="line">             o.tangent_dir = <span class="built_in">normalize</span>(<span class="built_in">mul</span>(<span class="built_in">float4</span>(v.tangent.xyz,<span class="number">0.0</span>),unity_WorldToObject).xyz);</span><br><span class="line">             o.binormal_dir = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(o.normali_dir,o.tangent_dir))*v.tangent.w;</span><br><span class="line">             o.pos_world = <span class="built_in">mul</span>(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line">             o.uv = <span class="built_in">TRANSFORM_TEX</span>(v.uv, _MainTex);</span><br><span class="line">             <span class="keyword">return</span> o;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function">fixed4 <span class="title">frag</span> <span class="params">(v2f i)</span> : SV_Target</span></span><br><span class="line"><span class="function">         &#123;</span></span><br><span class="line">             fixed4 col=<span class="built_in">fixed4</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">             half3 spec_mask = <span class="built_in">tex2D</span>(_SpecMask,i.uv).xyz;</span><br><span class="line">             half4 normalmap = <span class="built_in">tex2D</span>(_NormalMap,i.uv);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             half3 normal_dir  =<span class="built_in">normalize</span>(i.normali_dir);</span><br><span class="line">             half3 tangent_dir  =<span class="built_in">normalize</span>(i.tangent_dir);</span><br><span class="line">             half3 binormal_dir =<span class="built_in">normalize</span>(i.binormal_dir);</span><br><span class="line">             half3 normal_data = <span class="built_in">UnpackNormal</span>(normalmap);</span><br><span class="line">              normal_dir= tangent_dir*normal_data.x *_NormalIntensity+binormal_dir*normal_data.y*_NormalIntensity+normal_dir*normal_data.z ;</span><br><span class="line">             half3 view_dir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.pos_world);</span><br><span class="line">             <span class="meta">#<span class="keyword">if</span> defined (DIRECTIONAL)</span></span><br><span class="line">             half3 light_dir =<span class="built_in">normalize</span>( _WorldSpaceLightPos0.xyz );</span><br><span class="line">             half attuenation=<span class="number">1.0</span>;</span><br><span class="line">             <span class="meta">#<span class="keyword">elif</span> defined (POINT) </span></span><br><span class="line">             half3 light_dir =<span class="built_in">normalize</span>( _WorldSpaceLightPos0.xyz-i.pos_world.xyz ); </span><br><span class="line">             half distance=<span class="built_in">length</span>(_WorldSpaceLightPos0.xyz-i.pos_world.xyz);</span><br><span class="line">             <span class="type">float</span> range = <span class="number">1.0</span>/unity_WorldToLight[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">             half attuenation =<span class="built_in">saturate</span>((range-distance)/range);</span><br><span class="line">              </span><br><span class="line">             <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">             half NotL = <span class="built_in">max</span>(<span class="built_in">dot</span>(normal_dir,light_dir),<span class="number">0</span>);</span><br><span class="line">             half3 diffuse =  NotL*_LightColor0.xyz;</span><br><span class="line">             half3 specular =  <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(<span class="built_in">reflect</span>(-light_dir,normal_dir),view_dir),<span class="number">0</span>),_Shininess)* _LightColor0.xyz*_SpecularIntensity*spec_mask;</span><br><span class="line">             half3 AO = <span class="built_in">tex2D</span>(_AOMap,i.uv).xyz;</span><br><span class="line">             </span><br><span class="line">             <span class="comment">//col.xyz+= AO;</span></span><br><span class="line"></span><br><span class="line">             col.xyz += diffuse;</span><br><span class="line">             col.xyz += specular;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// sample the texture</span></span><br><span class="line">             col.xyz *=<span class="built_in">tex2D</span>(_MainTex, i.uv).xyz;</span><br><span class="line">             col.xyz *=AO;</span><br><span class="line">             col.xyz *=attuenation;</span><br><span class="line">             <span class="comment">// apply fog</span></span><br><span class="line">             <span class="keyword">return</span> col;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">         ENDCG</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>TA6特效篇火焰</title>
    <url>/2022/03/01/TA6%E7%89%B9%E6%95%88%E7%AF%87%E7%81%AB%E7%84%B0/</url>
    <content><![CDATA[<h1 id="火焰"><a href="#火焰" class="headerlink" title="火焰"></a>火焰</h1><h2 id="制作原理"><a href="#制作原理" class="headerlink" title="制作原理"></a>制作原理</h2><p>利用裁剪方程，将噪点图进行向上流动达到火焰往上升的效果，用一张渐变图和噪点图相乘把上半部分进行裁剪，将颜色的HDR效果打开，现在得到初步的火焰加一点点细节，让火的边缘柔和一点。让噪声图减去一个变量，并钳制在0到1之间，调大变量会使边缘柔和化，接下来是让火焰外焰和内焰效果</p>
<h2 id="噪点值"><a href="#噪点值" class="headerlink" title="噪点值"></a>噪点值</h2><p><img src="https://img-blog.csdnimg.cn/a9f0ed3772e7465785f1f268de05ebd6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>噪点图往上移动取R通道</p>
<h2 id="渐变值和内焰边界"><a href="#渐变值和内焰边界" class="headerlink" title="渐变值和内焰边界"></a>渐变值和内焰边界</h2><p><img src="https://img-blog.csdnimg.cn/a3ecd9c74d574044aed2fc070e609e02.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="火焰边缘柔和"><a href="#火焰边缘柔和" class="headerlink" title="火焰边缘柔和"></a>火焰边缘柔和</h2><p><img src="https://img-blog.csdnimg.cn/62b84b85d65440458541ed1d72f8b0e5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>当Softness变大边缘柔和，注意必须要clamp函数</p>
<h2 id="外焰和内焰"><a href="#外焰和内焰" class="headerlink" title="外焰和内焰"></a>外焰和内焰</h2><p><img src="https://img-blog.csdnimg.cn/6533e690f9c94cdca1192da8e6e0e94f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="火焰的形状"><a href="#火焰的形状" class="headerlink" title="火焰的形状"></a>火焰的形状</h2><p><img src="https://img-blog.csdnimg.cn/d483b0aebd7344f38b4a56ab74ab0838.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p><img src="https://img-blog.csdnimg.cn/4f00d42d98774071b79471a128aaf7f9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉计算观后感</title>
    <url>/2022/03/13/%E8%A7%86%E8%A7%89%E8%AE%A1%E7%AE%97%E8%A7%82%E5%90%8E%E6%84%9F/</url>
    <content><![CDATA[<h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h2 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h2><p>从样本数据提取数据，等距提取就是均匀采样，不等距就是非均匀采样。</p>
<h2 id="噪声"><a href="#噪声" class="headerlink" title="噪声"></a>噪声</h2><p>椒盐噪点可以用中值滤波器消除，有条纹状的噪声可以用陷波滤波器，比较细致模糊的噪点可以用低通滤波器</p>
<h1 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h1><h2 id="线性滤波器"><a href="#线性滤波器" class="headerlink" title="线性滤波器"></a>线性滤波器</h2><h3 id="全通"><a href="#全通" class="headerlink" title="全通"></a>全通</h3><p>没有消除和阻止任何一个频率。作用未知。</p>
<h3 id="低通"><a href="#低通" class="headerlink" title="低通"></a>低通</h3><p>使频率越来越宽，可以让图片变得模糊和达到消除噪点的作用</p>
<h4 id="盒式滤波器"><a href="#盒式滤波器" class="headerlink" title="盒式滤波器"></a>盒式滤波器</h4><p>使用全为1的卷积核。</p>
<h4 id="高斯滤波器"><a href="#高斯滤波器" class="headerlink" title="高斯滤波器"></a>高斯滤波器</h4><p>特定的权重，离像素点越远权重越小</p>
<p>下图为高斯函数的3维图示：</p>
<p><img src="https://pic4.zhimg.com/80/v2-d6af23aafa14caec06b3a1790b6d92e3_720w.jpg"></p>
<p>0.05 0.25 0.40 0.25 0.05权值</p>
<h4 id="降低频率采样"><a href="#降低频率采样" class="headerlink" title="降低频率采样"></a>降低频率采样</h4><p>n层：1 x 1</p>
<p>···</p>
<p>n-1层：pow(2,n-1) x pow(2,n-1)</p>
<p>n层：pow(2,n) x pow(2,n)</p>
<p>高斯金字塔</p>
<p>n-1层的一个网格对应相应的n层的4个网格</p>
<h4 id="卷积细节"><a href="#卷积细节" class="headerlink" title="卷积细节"></a>卷积细节</h4><ol>
<li>将滤波器与图像进行卷积时，要每个像素对齐非常重要，每个卷积的结果要单独保存，否则会影响之后的卷积结果</li>
<li>运算时先转化为浮点数再进行滤波最后滤波取整</li>
<li>如果颜色超过0，255设定最大值和最小值s</li>
</ol>
<h3 id="高通"><a href="#高通" class="headerlink" title="高通"></a>高通</h3><p>留下高频去除低频，能得到图形边缘特征。</p>
<p>如核为 -1&#x2F;3 2&#x2F;3 -1&#x2F;3的卷积核。</p>
<h3 id="带通"><a href="#带通" class="headerlink" title="带通"></a>带通</h3><p>指留下低频和高频之间的信号。</p>
<h2 id="非线性滤波器"><a href="#非线性滤波器" class="headerlink" title="非线性滤波器"></a>非线性滤波器</h2><h3 id="中值滤波器"><a href="#中值滤波器" class="headerlink" title="中值滤波器"></a>中值滤波器</h3><p>去核范围的中值代替像素，去椒盐噪点的，还可以制作腐蚀或膨胀效果。</p>
<h1 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h1><h2 id="平移旋转放缩"><a href="#平移旋转放缩" class="headerlink" title="平移旋转放缩"></a>平移旋转放缩</h2><p><a href="https://learnopengl-cn.github.io/01%20Getting%20started/07%20Transformations/">opengl</a>里面有 就不看了</p>
<h2 id="透视变换"><a href="#透视变换" class="headerlink" title="透视变换"></a>透视变换</h2><p>裁剪距阵的推导<br><img src="https://img-blog.csdnimg.cn/c190892dadc14693a1333ea6a36d8882.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"><br>取用这个坐标系，所以w是0 0 -1 0<br>$$<br>∠theta&#x3D;fov&#x2F;2 ,A&#x3D;  N * tan (theta),B&#x3D;  F * tan (theta) \ A’&#x3D;N&#x3D;ACot(theta),B’&#x3D;F&#x3D;BCot(theta)<br>$$<br>所以Y轴是 0 cot(theta) 0 0。<br><img src="https://img-blog.csdnimg.cn/882a9c5831444a61ab5f8edf4f74d502.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"><br>ASP是宽高比</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">C=A<span class="emphasis">*ASP \\</span></span><br><span class="line"><span class="emphasis">D=B*</span>ASP \\</span><br><span class="line">C&#x27;=N=C<span class="emphasis">*Cot(theta) / ASP \\ </span></span><br><span class="line"><span class="emphasis">D&#x27;=F=D*</span>Cot(theta) / ASP</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>

<p>所以x是&#x3D;Cot(theta)&#x2F;ASP 0  0 0。</p>
<p>假设矩阵是线性的<br>$$<br>f(-N)&#x3D;-N,f(-F)&#x3D;F代入方程y&#x3D;sx+o<br>$$<br>解方程组<br>$$<br>s&#x3D;(f+n)&#x2F;(n-f),o&#x3D;2fn&#x2F;(n-f)<br>$$<br>z是0 0 s o；</p>
<p>得透视矩阵如下</p>
<p> <img src="https://img-blog.csdnimg.cn/fc31696d20124d45ae3f5291895b5e7b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>Games104第2节记录</title>
    <url>/2022/03/22/Games104%E7%AC%AC2%E8%8A%82%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Tool Layer    给予开发者使用的工具</p>
<p>Function Layer </p>
<p>Resource Layer </p>
<p>Core Layer   核心层</p>
<p>Platform Layer 为了适应各种平台</p>
<p>越往上越灵活</p>
<p>越往下越稳定</p>
<p>怎样做一个animation system</p>
<h1 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h1><p>将其他资源转化为引擎的资产，引擎化。</p>
<p>需要加载进入游戏的文件</p>
<p>将文件全局资产编号GUID</p>
<p>Handle管理所有的资源周期</p>
<p>延迟加载</p>
<h1 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h1><p>1.Tick循环</p>
<p><img src="https://img-blog.csdnimg.cn/2dffc93fd10c4dfb9970d5078b6dac01.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>2.多线程</p>
<p><img src="https://img-blog.csdnimg.cn/4d4628dbec9a431a8142490ebdedb01b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="Core核心层"><a href="#Core核心层" class="headerlink" title="Core核心层"></a>Core核心层</h1><p>数学库，基本线代，取决于你系统的效率。</p>
<p>simd，如下四个数据一次性处理。</p>
<p><img src="https://img-blog.csdnimg.cn/722c5c5e526b4502908f0edbda47c868.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_13,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>数据结构，无内存碎片，查找效率高</p>
<p>Memory Management，有点像操作系统，进行更高效率的处理。</p>
<p><img src="https://img-blog.csdnimg.cn/ca185ca9c61c45d8ae83704cefc2d4aa.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="Platforms平台层"><a href="#Platforms平台层" class="headerlink" title="Platforms平台层"></a>Platforms平台层</h1><p>去除平台差异</p>
<p>比如将常用的GraphicsAPI抽象出来，用多态解决不同平台的问题。</p>
<h1 id="Tool工具层"><a href="#Tool工具层" class="headerlink" title="Tool工具层"></a>Tool工具层</h1><p>允许任何人可以创造游戏，开发效率优先。</p>
<p>数据的导入器导出器，能支持其他的3d软件资产</p>
<h1 id="简单ecs框架"><a href="#简单ecs框架" class="headerlink" title="简单ecs框架"></a>简单ecs框架</h1><p><img src="https://img-blog.csdnimg.cn/c9374d62177542dea5f17856cf4146df.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>引擎是分层架构的</p>
<p>越底层越稳定，越上层越灵活</p>
<p>通过Ticks进行驱动虚拟世界</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>引擎制作</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV的边缘计算</title>
    <url>/2022/03/22/OpenCV%E7%9A%84%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h1 id="基于梯度的检测器"><a href="#基于梯度的检测器" class="headerlink" title="基于梯度的检测器"></a>基于梯度的检测器</h1><p><img src="https://img-blog.csdn.net/20160911165855683?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p>
<p>梯边缘，顶边缘，坡边缘</p>
<h2 id="有限差分"><a href="#有限差分" class="headerlink" title="有限差分"></a>有限差分</h2><p>最简单的梯度算子<br>$$<br>gx&#x3D;f(x+1,y)-f(x,y) \<br>gy&#x3D;f(x,y+1)-f(x,y)<br>$$</p>
<h2 id="Sobel算子"><a href="#Sobel算子" class="headerlink" title="Sobel算子"></a>Sobel算子</h2><p>对于具有噪声的图有很好的效果<br>$$<br>gx&#x3D;\frac{1}{8}\left[ \begin{matrix} -1 &amp; 0 &amp; 1 \ -2 &amp; 0 &amp; 2 \ -1 &amp; 0 &amp; 1  \end{matrix} \right]\<br>gy&#x3D;\frac{1}{8}\left[ \begin{matrix} 1 &amp; 2 &amp; 1 \ 0 &amp; 0 &amp; 0 \ -1 &amp; -2 &amp; -1  \end{matrix} \right]<br>$$</p>
<h1 id="基于曲率的检测器"><a href="#基于曲率的检测器" class="headerlink" title="基于曲率的检测器"></a>基于曲率的检测器</h1><p>缺点，对于薄边缘在精准定位边缘没有优势</p>
<h2 id="Marr-Hildreth"><a href="#Marr-Hildreth" class="headerlink" title="Marr-Hildreth"></a>Marr-Hildreth</h2><p>$$<br>gx-g(x-1)&#x3D;f(x+1,y)-f(x,y) -(f(x,y)-f(x-1,y) )&#x3D;f(x+1,y)-f(x-1,y)-2f(x,y)<br>$$</p>
<h2 id="高斯的拉普拉斯滤波器LoG"><a href="#高斯的拉普拉斯滤波器LoG" class="headerlink" title="高斯的拉普拉斯滤波器LoG"></a>高斯的拉普拉斯滤波器LoG</h2><p>考虑四边的核<br>$$<br>\frac{1}{8}\left[ \begin{matrix} 0 &amp; -1 &amp; 0 \ -1 &amp; 4 &amp; -1 \ 0 &amp; -1 &amp; 0  \end{matrix} \right]<br>$$<br>考虑全部八个方向<br>$$<br>\frac{1}{8}\left[ \begin{matrix} -1 &amp; -1 &amp; -1 \ -1 &amp; 8 &amp; -1 \ -1 &amp; -1 &amp; -1  \end{matrix} \right]<br>$$</p>
<h1 id="Canny边缘检测"><a href="#Canny边缘检测" class="headerlink" title="Canny边缘检测"></a>Canny边缘检测</h1><p>canny的四步法</p>
<ol>
<li><p>使用低通滤波器抑制噪声</p>
</li>
<li><p>计算梯度幅度和方向图</p>
</li>
<li><p>对梯度幅度图使用非极大值抑制</p>
</li>
<li><p>运用迟滞和连通分析检测边缘</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Mat srcImage, grayImage;</span><br><span class="line"></span><br><span class="line">  srcImage = <span class="built_in">imread</span>(<span class="string">&quot;Lena.png&quot;</span>);</span><br><span class="line">  <span class="built_in">imshow</span>(<span class="string">&quot;Lena.png&quot;</span>, srcImage);</span><br><span class="line">  Mat srcImage1 = srcImage.<span class="built_in">clone</span>();</span><br><span class="line">  <span class="comment">//图形转换:</span></span><br><span class="line">  <span class="built_in">cvtColor</span>(srcImage, grayImage, COLOR_BGR2GRAY);</span><br><span class="line">  Mat dstImage, edge;</span><br><span class="line">  <span class="comment">//均值滤波</span></span><br><span class="line">  <span class="built_in">blur</span>(srcImage1, grayImage, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">imshow</span>(<span class="string">&quot;grayImage.png&quot;</span>, grayImage);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">GaussianBlur</span>(grayImage, grayImage, <span class="built_in">Size</span>(<span class="number">5</span>, <span class="number">5</span>), <span class="number">0.8</span>);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    边缘检测</span></span><br><span class="line"><span class="comment">    低于阈值1的像素点会被认为不是边缘；</span></span><br><span class="line"><span class="comment">    高于阈值2的像素点会被认为是边缘；</span></span><br><span class="line"><span class="comment">    在阈值1和阈值2之间的像素点,若与第2步得到的边缘像素点相邻，则被认为是边缘，否则被认为不是边缘。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="built_in">Canny</span>(grayImage, edge, <span class="number">150</span>, <span class="number">100</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  dstImage.<span class="built_in">create</span>(srcImage1.<span class="built_in">size</span>(), srcImage1.<span class="built_in">type</span>());</span><br><span class="line">  dstImage = Scalar::<span class="built_in">all</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  image.copyTo(imageROI)。作用是把image的内容复制粘贴到imageROI上；</span></span><br><span class="line"><span class="comment">  image.copyTo(imageROI，mask)。 作用是把mask和image重叠以后把mask中像素值为0（black）的点对应的image中的点变为透明，而保留其他点。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  srcImage1.<span class="built_in">copyTo</span>(dstImage, edge);</span><br><span class="line">  <span class="built_in">imwrite</span>(<span class="string">&quot;canny.jpg&quot;</span>, dstImage);</span><br><span class="line">  <span class="built_in">imshow</span>(<span class="string">&quot;canny.jpg&quot;</span>, dstImage);</span><br><span class="line">  <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="fast算子"><a href="#fast算子" class="headerlink" title="fast算子"></a>fast算子</h1><p><a href="https://blog.csdn.net/ssw_1990/article/details/70569871">参考这个代码</a></p>
<p>计算步骤</p>
<ol>
<li><p>从图片中选取一个坐标点,获取该点的像素值,接下来判定该点是否为特征点.</p>
</li>
<li><p>选取一个以选取点坐标为圆心的半径等于三的Bresenham圆(一个计算圆的轨迹的离散算法,得到整数级的圆的轨迹点),一般来说,这个圆上有16个点</p>
</li>
<li><p>现在选取一个阈值,假设为t,关键步骤,假设这16个点中,有N个连续的像素点,他们的亮度值与中心点的像素值的差大于或者小于t,那么这个点就是一个特征点.(n的取值一般取值12或者9,实验证明9可以取得更好的效果,因为可以获取更多的特征点,后面进行处理时,数据样本额相对多一些).</p>
</li>
<li><p>加入每个轨迹点都需要遍历的话,那么需要的时间比较长,有一种比较简单的方法可以选择,那就是仅仅检查在位置1，9，5和13四个位置的像素，首先检测位置1和位置9，如果它们都比阈值暗或比阈值亮，再检测位置5和位置13,该满足判断条件。如果不满足中心点不可能是一个角点。对于所有点做上面这一部分初步的检测后，符合条件的将成为候选的角点，我们再对候选的角点，做完整的测试，即检测圆上的所有点.</p>
</li>
</ol>
<p>但是,这种检测方法会带来一个问题,就是造成特征点的聚簇效应,多个特征点在图像的某一块重复高频率的出现,FAST算法提出了一种非极大值抑制的办法来消除这种情况,具体办法如下</p>
<ol>
<li><p>对所有检测到的角点构建一个打分函数。就是像素点与周围16个像素点差值的绝对值之和。</p>
</li>
<li><p>考虑两个相邻的角点，并比较它们的值。</p>
</li>
<li><p>值较低的角点将会被删除。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Mat srcImage, grayImage;</span><br><span class="line"></span><br><span class="line">  srcImage = <span class="built_in">imread</span>(<span class="string">&quot;Lena.png&quot;</span>);</span><br><span class="line">  <span class="built_in">imshow</span>(<span class="string">&quot;Lena.png&quot;</span>, srcImage);</span><br><span class="line"></span><br><span class="line">  Mat gray;</span><br><span class="line">  <span class="built_in">cvtColor</span>(srcImage, gray, COLOR_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">  Mat LenaFast;</span><br><span class="line">  vector&lt;KeyPoint&gt;detectKeyPoint;</span><br><span class="line">  Mat keyPointImage1;</span><br><span class="line">  Ptr&lt;FastFeatureDetector&gt; fast = FastFeatureDetector::<span class="built_in">create</span>();</span><br><span class="line">  fast-&gt;<span class="built_in">detect</span>(gray, detectKeyPoint);</span><br><span class="line">  <span class="built_in">drawKeypoints</span>(srcImage, detectKeyPoint, keyPointImage1, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), DrawMatchesFlags::DRAW_RICH_KEYPOINTS);</span><br><span class="line">  <span class="built_in">imshow</span>(<span class="string">&quot;keyPoint image1&quot;</span>, keyPointImage1);</span><br><span class="line">  <span class="comment">//imshow(&quot;keyPoint image2&quot;, keyPointImage2);</span></span><br><span class="line">  <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum struct</span> <span class="title class_">DrawMatchesFlags</span></span><br><span class="line">&#123;</span><br><span class="line">  DEFAULT = <span class="number">0</span>, <span class="comment">//!&lt; 将创建输出图像矩阵(Mat::create),</span></span><br><span class="line">               <span class="comment">//!&lt; i.e. 输出图像的现有内存可以重用.</span></span><br><span class="line">               <span class="comment">//!&lt; 将绘制两个源图像，匹配和单个关键点.</span></span><br><span class="line">               <span class="comment">//!&lt; 对于每个关键点，只有中心点将被绘制(没有带关键点大小和方向的圆点)</span></span><br><span class="line">  DRAW_OVER_OUTIMG = <span class="number">1</span>, <span class="comment">//!&lt; 输出图像矩阵将不会被创建 (Mat::create).</span></span><br><span class="line">                        <span class="comment">//!&lt; 匹配将绘制在输出图像的现有内容上.</span></span><br><span class="line">  NOT_DRAW_SINGLE_POINTS = <span class="number">2</span>, <span class="comment">//!&lt; 不会绘制单个关键点。</span></span><br><span class="line">  DRAW_RICH_KEYPOINTS = <span class="number">4</span> <span class="comment">//!&lt; 对于每个关键点，将绘制具有关键点大小和方向的圆。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Harris算子"><a href="#Harris算子" class="headerlink" title="Harris算子"></a>Harris算子</h1><p>步骤如下：</p>
<ol>
<li><p>生成梯度图像gx，gy</p>
</li>
<li><p>一个颜色块A，A1到A9 3x3，一个颜色块B，B1到B9 3x3 w x（Ai-Bi）的平方。w是权值比如A5到Ai的距离。</p>
</li>
<li><p>得到两个特征值下x，y如果两个值都很小，没有特征。如果一个很大就存在一条边，都很大，这个点有一个角点。</p>
</li>
</ol>
<p>c++的实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Mat srcImage, grayImage;</span><br><span class="line"></span><br><span class="line">  srcImage = <span class="built_in">imread</span>(<span class="string">&quot;Lena.png&quot;</span>);</span><br><span class="line">  <span class="built_in">imshow</span>(<span class="string">&quot;Lena.png&quot;</span>, srcImage);</span><br><span class="line"></span><br><span class="line">  Mat gray;</span><br><span class="line">  <span class="built_in">cvtColor</span>(srcImage, gray, COLOR_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">  Mat LenaHarris;</span><br><span class="line">  <span class="built_in">cornerHarris</span>(gray, LenaHarris, <span class="number">7</span>,<span class="number">7</span>, <span class="number">0.1</span>);</span><br><span class="line">  <span class="built_in">imshow</span>(<span class="string">&quot;LenaHarris.jpg&quot;</span>, LenaHarris);</span><br><span class="line">  <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习记录</title>
    <url>/2020/03/01/C++%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1><h2 id="流操纵算子"><a href="#流操纵算子" class="headerlink" title="流操纵算子"></a>流操纵算子</h2><p>需要头文件<br>#include<iomanip><br>整数dec10，oct8，hex16，setbase<br>小数点setiosflags(ios::fixed)或fixed<br>浮点精度precision，setprecision<br>取消小数点resetiosflags(ios::fixed)<br>科学计数法scientific<br>设置宽域setw，width<br>非负数显示正号showpos()<br>非负数不显示正号noshowpos()<br>填充符号setfill(‘’)<br>数字的位置left，right</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>templatea<class T>&#x2F;&#x2F;T就变成了某个数据类型</p>
<h1 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h1><h2 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h2><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">cout &lt;&lt;s1.<span class="built_in">length</span>()&lt;&lt;endl;<span class="comment">//string类型长度输出</span></span><br><span class="line">cout&lt;&lt;s1&lt;&lt;endl;</span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(<span class="number">8</span>,<span class="string">&#x27;x&#x27;</span>)</span></span>;<span class="comment">//s2是8个x</span></span><br><span class="line">cout&lt;&lt;s2&lt;&lt;endl;</span><br><span class="line">string month=<span class="string">&quot;march&quot;</span>;<span class="comment">//直接赋值</span></span><br><span class="line">cout &lt;&lt; month&lt;&lt;endl;</span><br><span class="line">string s;</span><br><span class="line">s=<span class="string">&#x27;n&#x27;</span>;<span class="comment">//可以单个赋值</span></span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<h3 id="string的复制"><a href="#string的复制" class="headerlink" title="string的复制"></a>string的复制</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span>,s3</span>;<span class="comment">//直接复制</span></span><br><span class="line">  s3.<span class="built_in">assign</span>(s1);</span><br><span class="line">  cout&lt;&lt;s3&lt;&lt;endl;</span><br><span class="line">  <span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span>,s2,s3</span>;</span><br><span class="line">  s3.<span class="built_in">assign</span>(s1,<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//从s1的第2个复制3个字符，2形同下标</span></span><br></pre></td></tr></table></figure>

<h3 id="读取string的字符"><a href="#读取string的字符" class="headerlink" title="读取string的字符"></a>读取string的字符</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s[<span class="number">0</span>]<span class="comment">//不会检测 ，可能会越界</span></span><br><span class="line">s.<span class="built_in">at</span>(<span class="number">0</span>)<span class="comment">//越界编译不会出错，但结果会提示出错</span></span><br></pre></td></tr></table></figure>

<h3 id="string连接"><a href="#string连接" class="headerlink" title="string连接"></a>string连接</h3><p>​    </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span>,<span class="title">s2</span><span class="params">(<span class="string">&quot;morning&quot;</span>)</span></span>;</span><br><span class="line">s1+=s2;<span class="comment">//直接连接</span></span><br><span class="line">cout&lt;&lt;s1&lt;&lt;endl;</span><br><span class="line">s1.<span class="built_in">append</span>(s2);<span class="comment">//append连接</span></span><br><span class="line">cout&lt;&lt;s1&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">s2.<span class="built_in">append</span>(s1,<span class="number">3</span>,s1.<span class="built_in">size</span>());<span class="comment">//从s1的第3个复制s1.size()在s2的尾部</span></span><br></pre></td></tr></table></figure>
<h3 id="比较string"><a href="#比较string" class="headerlink" title="比较string"></a>比较string</h3><p>可以直接比较用bool类型记录结果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span>,<span class="title">s2</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span>,<span class="title">s3</span><span class="params">(<span class="string">&quot;hell&quot;</span>)</span></span>;</span><br><span class="line">   <span class="type">int</span> f1=s1.<span class="built_in">compare</span>(s2);<span class="comment">//0   hello==hello</span></span><br><span class="line">   <span class="type">int</span> f2=s1.<span class="built_in">compare</span>(s3);<span class="comment">//1   hello&gt;hell</span></span><br><span class="line">   <span class="type">int</span> f3=s3.<span class="built_in">compare</span>(s1);<span class="comment">//-1 hell&lt;hello</span></span><br><span class="line">   <span class="type">int</span> f4=s1.<span class="built_in">compare</span>(<span class="number">1</span>,<span class="number">2</span>,s3,<span class="number">0</span>,<span class="number">3</span>);<span class="comment">//-1el&lt;hell   数字是代表下标</span></span><br><span class="line">   <span class="type">int</span> f5=s1.<span class="built_in">compare</span>(<span class="number">0</span>,s1.<span class="built_in">size</span>(),s3);<span class="comment">//1  hello&gt;hell第一个数是下标，第二个数字是s1比较的数量</span></span><br></pre></td></tr></table></figure>

<h3 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span>,s2</span>;</span><br><span class="line">s2=s1.<span class="built_in">substr</span>(<span class="number">4</span>,<span class="number">5</span>);<span class="comment">//下标4开始的5个字符</span></span><br><span class="line">cout&lt;&lt;s2&lt;&lt;endl;<span class="comment">//o wor</span></span><br></pre></td></tr></table></figure>

<h3 id="搜索find"><a href="#搜索find" class="headerlink" title="搜索find()"></a>搜索find()</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;hello worlld&quot;</span>)</span></span>;</span><br><span class="line">   cout&lt;&lt;s1.<span class="built_in">find</span>(<span class="string">&quot;ll&quot;</span>)&lt;&lt;endl;<span class="comment">//2</span></span><br><span class="line">   cout&lt;&lt;s1.<span class="built_in">find</span>(<span class="string">&quot;abc&quot;</span>)&lt;&lt;endl;<span class="comment">//4294967295正序查找没有的话出现一个很大的数</span></span><br><span class="line">   cout&lt;&lt;s1.<span class="built_in">rfind</span>(<span class="string">&quot;ll&quot;</span>)&lt;&lt;endl;<span class="comment">//9逆序查找</span></span><br><span class="line">   cout&lt;&lt;s1.<span class="built_in">find_first_of</span>(<span class="string">&quot;abcde&quot;</span>)&lt;&lt;endl;<span class="comment">//1  abcde中第一个字符的下标位置</span></span><br><span class="line">   cout&lt;&lt;s1.<span class="built_in">find_last_of</span>(<span class="string">&quot;abcde&quot;</span>)&lt;&lt;endl;<span class="comment">//11  abcde中最后一个字符下标位置</span></span><br><span class="line">   cout&lt;&lt;s1.<span class="built_in">find_first_not_of</span>(<span class="string">&quot;abcde&quot;</span>)&lt;&lt;endl;<span class="comment">//0在字符串中不是abcde的下标位置</span></span><br><span class="line">   cout&lt;&lt;s1.<span class="built_in">find_last_not_of</span>(<span class="string">&quot;abcde&quot;</span>)&lt;&lt;endl;<span class="comment">//10逆序在字符串中不是abcde的下标位置</span></span><br></pre></td></tr></table></figure>

<h3 id="删除string元素"><a href="#删除string元素" class="headerlink" title="删除string元素"></a>删除string元素</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s1.<span class="built_in">erase</span>(<span class="number">5</span>)<span class="comment">//会去掉下标5之后的字符</span></span><br></pre></td></tr></table></figure>

<h3 id="替换string元素"><a href="#替换string元素" class="headerlink" title="替换string元素"></a>替换string元素</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s1.<span class="built_in">replace</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="string">&quot;hahah&quot;</span>)<span class="comment">//将s1下标为2到3的字符换成hahah</span></span><br><span class="line">s1.<span class="built_in">replace</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="string">&quot;hahah&quot;</span>,<span class="number">1</span>,<span class="number">2</span>)<span class="comment">//将s1下标为2到3的字符换成hahah的下标1开始的2个字符</span></span><br></pre></td></tr></table></figure>

<h3 id="插入string元素"><a href="#插入string元素" class="headerlink" title="插入string元素"></a>插入string元素</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s1.<span class="built_in">insert</span>(<span class="number">5</span>,s2)<span class="comment">//将s2插入下标5的位置</span></span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">2</span>,s2,<span class="number">5</span>,<span class="number">3</span>)<span class="comment">//将s2中下标5开始的3个字符插入s1下标2的位置</span></span><br></pre></td></tr></table></figure>

<h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><h3 id="c-str"><a href="#c-str" class="headerlink" title="c_str()"></a>c_str()</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,s1.<span class="built_in">c_str</span>());<span class="comment">//s1.c_str()返回传统的const char*类型字符串，且该字符串以\0结尾</span></span><br></pre></td></tr></table></figure>

<h3 id="data"><a href="#data" class="headerlink" title="data()"></a>data()</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*p1=s1.<span class="built_in">data</span>();<span class="comment">//s1.data()返回char*类型的字符串，对s1的修改可能会使p1出错</span></span><br></pre></td></tr></table></figure>

<h2 id="STL库（一）"><a href="#STL库（一）" class="headerlink" title="STL库（一）"></a>STL库（一）</h2><p>容器：可容纳各种数据类型的通用数据结构，是类模板<br>迭代器：可用于依次存取容器中的元素，类似于指针<br>算法：用来操作容器中的元素的函数模板</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>1.顺序容器 vector动态数组 ，deque双向队列，list双向链表<br>2.关联容器set multset map multmap<br>3.容器适配器stack queue priority_queue</p>
<h4 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h4><h5 id="vector动态数组"><a href="#vector动态数组" class="headerlink" title="vector动态数组"></a>vector动态数组</h5><p>头文件：<vector><br>常数时间尾部性能最佳</p>
<h5 id="deque双向队列"><a href="#deque双向队列" class="headerlink" title="deque双向队列"></a>deque双向队列</h5><p>头文件：<deque><br>随机存取任何元素常数时间，但次于vector，两端删减性能最佳<br>head头  tail尾，空元素</p>
<h5 id="list双向链表"><a href="#list双向链表" class="headerlink" title="list双向链表"></a>list双向链表</h5><p>头文件<list><br>元素不能在内存不连续存放，在任何位置都能常数时间，不支持随机存取</p>
<h4 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h4><p>元素是排序的<br>插入任何元素，都是按相应的排序规则来确定其位置<br>在查找时具有非常好的性能<br>通常以平衡二叉树实现，时间logN</p>
<h5 id="set-x2F-multiset"><a href="#set-x2F-multiset" class="headerlink" title="set&#x2F;multiset"></a>set&#x2F;multiset</h5><p>头文件<set><br>set不允许相同的元素，multiset允许相同的元素</p>
<h5 id="map-x2F-multimap"><a href="#map-x2F-multimap" class="headerlink" title="map&#x2F;multimap"></a>map&#x2F;multimap</h5><p>头文件：<map><br>一个名为first另一个名为second，multimap允许相同的first值</p>
<h4 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h4><h5 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h5><p>头文件：<stack><br>栈，是项的有限序列只能修改删除检索最佳插入的项后进后出</p>
<h5 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h5><p>头文件<queue><br>队列，插入只能从尾部，删除修改检索只能在头部进行先进先出</p>
<h5 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h5><p>头文件<queue><br>优先级队列，最高优先级的元素总是第一个出列</p>
<p>顺序容器和关联容器中都有的成员函数<br>begin 返回指向容器中第一个元素的迭代器<br>end   返回指向容器中最后一个元素后面的位置的迭代器<br>rbegin返回指向容器中最后一个元素的迭代器<br>rend返回指向容器中第一个元素前面位置的迭代器<br>erase 从容器中删除一个或几个元素<br>clear 从容器中删除所有元素</p>
<p>顺序容器的常用成员函数<br>front 返回容器中第一个元素的引用<br>back 返回容器中最后一个元素的引用<br>push_back 在容器末尾增加新元素<br>pop_back删除容器末尾的元素<br>erase 删除迭代器指向的元素（可能会使该迭代器失效），或删除一个区间，返回那个元素的迭代器</p>
<h2 id="STL库（二）"><a href="#STL库（二）" class="headerlink" title="STL库（二）"></a>STL库（二）</h2><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>用于指向顺序容器和关联容器的元素<br>迭代器的用法和指针类似<br>有const 和非const两种<br>通过迭代器可以读取它指向的元素<br>通过非const迭代器还能修改其指向的元素</p>
<h3 id="定义迭代器"><a href="#定义迭代器" class="headerlink" title="定义迭代器"></a>定义迭代器</h3><p>容器类名::iterator  变量名;<br>容器类名::const_iterator  变量名;&#x2F;&#x2F;常量迭代器<br>访问迭代器指向的元素<br>*迭代器变量名<br>容器类名::reverse_iterator  变量;&#x2F;&#x2F;反向迭代器</p>
<h2 id="STL库（三）"><a href="#STL库（三）" class="headerlink" title="STL库（三）"></a>STL库（三）</h2><p>所有的vector都适用于deque<br>list<br>特有的成员函数<br>push_front 在前面插入<br>pop_front删除前面的元素<br>sort 排序（list不支持stl的算法sort）<br>remove 删除和指定值相同的所有元素<br>unique 删除所有和前一个元素相同的元素（做到不重复需要unique之前需要sort）<br>merge合并两个链表，并清空被合并的那个<br>reverse 颠倒链表<br>splice在指定位置前面插入另一个链表中的一个或多个元素，并在另一个链表删除被插入的元素<br>lst1.splice(p1,lst2,p2,p3)&#x2F;&#x2F;将[p2,p3)插入p1之前，并从lst2中删除[p2,p3)</p>
<h1 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h1><h2 id="set与multiset"><a href="#set与multiset" class="headerlink" title="set与multiset"></a>set与multiset</h2><p>iterator find:查找等于某个值的元素<br>iterator lower_bound:查找某个下界<br>iterator upper_bound:查找某个上界<br>equal_range: 同时查找上界和下界<br>int  count:计算等于某个值的元素个数<br>void insert：插入某个元素或某个区间</p>
<h2 id="map与multimap"><a href="#map与multimap" class="headerlink" title="map与multimap"></a>map与multimap</h2><p>1直接赋值，例如 mp[“Tom”]&#x3D;0<br>2通过插入一个类型为 pair&lt;Key, T&gt; 的值，例如 mp.insert(pair&lt;string,int&gt;(“Alan”,100));<br>map&lt;string, int&gt;::iterator it;&#x2F;&#x2F;迭代器<br>cout &lt;&lt; iter-&gt;first &lt;&lt; “ “ &lt;&lt; iter-&gt;second &lt;&lt; endl;&#x2F;&#x2F;不能用iter.first<br>但是可以重载&lt;&lt;<br>template&lt;class Key,class Value&gt;<br>ostream&amp;operator&lt;&lt;(ostream&amp;o,const pair&lt;Key,Value&gt;&amp;p)<br>{<br>    o&lt;&lt;”(“&lt;&lt;p.first&lt;&lt;”,”&lt;&lt;p.second&lt;&lt;”)”;<br>}<br>cout&lt;&lt;*s;<br>&#x2F;&#x2F;map专用</p>
<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>push  插入元素<br>pop  弹出元素<br>top   返回栈顶的元素的引用<br>queue<br>push  插入元素发生在尾部<br>pop  弹出元素对头<br>top   返回栈顶的元素的引用对头<br>back  返回栈顶的元素的引用尾部<br>priority_queue<br>保证优先级最大的在前面，保证最大的在前面<br>size   还有多少数<br>empty   是否空</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="1不变序列算法"><a href="#1不变序列算法" class="headerlink" title="1不变序列算法"></a>1不变序列算法</h3><p>min   求两个对象中较小的1<br>max   求两个对象较大的<br>min_element求区间最小的1<br>max_element求区间最大的&#x2F;&#x2F;1有点问题<br>for_each对区间每个元素都做这种操作<br>count计算区间等于某值的元素个数<br>count_if计算区间符合某种条件的元素个数<br>find在区间查找某值的元素<br>find_if区间符合某种条件的元素<br>find_end从区间查找另一个区间出现的最后一次位置<br>find_first_of从区间查找另一个区间出现的第一次的元素<br>adjacent_find从区间查找第一次出现连续两个相等元素的位置<br>search在区间查找另一个区间第一次出现的位置<br>search_n在区间查找第一次出现等于某值的连续n个元素<br>equal判断两个区间是否相等<br>mismatch逐个比较两个区间的元素，返回第一次发生不相等的位置<br>lexicographical_compare按字典比较两个区间的大小</p>
<h3 id="2-变值算法"><a href="#2-变值算法" class="headerlink" title="2.变值算法"></a>2.变值算法</h3><p>for_each 对区间中的每个元素都做某种操作<br>copy复制一个区间到别处<br>copy_backward复制一个区间到别处但目标区前是从后往前被修改的<br>transform将一个区间的元素变形后拷贝到另一个区间&#x2F;&#x2F;迭代器<br>swap_ranges交换两个区间的内容<br>fill用某个值填充区间<br>fill_n用某个值代替区间的n个元素<br>generate用某个操作的结果填充区间<br>generate_n用某个操作的结果替换区间中的n个元素<br>replace将区间中某个值替换为另一个值<br>replace_if将区间中符合某种条件的值替换成另一个值<br>replace_copy将一个区间拷贝到另一个区间，拷贝时某个值要换成新值拷过去<br>replace_copy_if将一个区间拷贝到另一个区间，拷贝时符合某种条件的值要换成新值拷过去</p>
<p>accumulate(first,last,累加的数);求和</p>
<h3 id="3删除算法"><a href="#3删除算法" class="headerlink" title="3删除算法"></a>3删除算法</h3><p>remove 删除区间中等于某个值的元素<br>unique删除区间中连续相等的元素，只留下一个</p>
<h3 id="4变序算法"><a href="#4变序算法" class="headerlink" title="4变序算法"></a>4变序算法</h3><p>random_shuffle(first,last);随机打乱<br>reverse 颠倒区间次序<br>next_permutation将区间改为下一个排列<br>prev_permutation将区间改为上一个排列&#x2F;&#x2F;可以list</p>
<h3 id="5排序算法"><a href="#5排序算法" class="headerlink" title="5排序算法"></a>5排序算法</h3><p>随机访问迭代器 不支持关联容器和list<br>sort()从小到大排序</p>
<h3 id="6有序区间算法"><a href="#6有序区间算法" class="headerlink" title="6有序区间算法"></a>6有序区间算法</h3><p>要求是从小到大排好的随机访问迭代器 不支持关联容器和list<br>binary_search判断区间是否又某个元素<br>lower_bound查找最后一个不小于某个值的元素的位置<br>upper_bound查找第一个大于某个值的元素位置<br>equal_range同时获取upper_bound，lower_bound</p>
<h3 id="7bitset"><a href="#7bitset" class="headerlink" title="7bitset"></a>7bitset</h3><p>bitset<N>&amp;set();全部为1<br>bitset<N>&amp;set(size_t pos,bool val&#x3D;true);设置某位<br>bitset<N>&amp;reset();全部为0<br>bitset<N>&amp;reset(size_t pos);某位设为0<br>bitset<N>&amp;flip();全部翻转<br>bitset<N>&amp;flip(size_t pos)翻转某位</p>
<h1 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h1><h2 id="c-11的新特性"><a href="#c-11的新特性" class="headerlink" title="c++11的新特性"></a>c++11的新特性</h2><ol>
<li><p>数组，容器可以直接用花括号初始化.</p>
</li>
<li><p>auto关键字<br>迭代器的时候可以用auto</p>
</li>
<li><p>decltype关键字<br>返回数据类型</p>
</li>
<li><p>智能指针shared_ptr<br>头文件<memory><br>会自动delete，不能是指针数组</p>
</li>
<li><p>空指针nullpr<br>转化bool等于false</p>
</li>
<li><p>基于范围for循环<br>int ary[]&#x3D;{1,2,3,4,5};<br>for(int &amp;e:ary)<br>e*&#x3D;10&#x2F;&#x2F;输出10，20，30，40，50*</p>
</li>
<li><p>*右值引用<br>&amp;&amp;是右值引用<br>减少进行深拷贝的次数</p>
</li>
<li><p>无序容器（哈希表）<br>头文件<unordered_map><br>用法和map一样，效率更高</p>
</li>
<li><p>正则表达式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">头文件&lt;regex&gt;</span><br><span class="line"><span class="function">regex <span class="title">reg</span><span class="params">(<span class="string">&quot;b.?p.*k&quot;</span>)</span></span></span><br><span class="line"><span class="function">regex_match<span class="comment">//匹配成功1匹配失败0</span></span></span><br><span class="line"><span class="function">10。lambda表达式</span></span><br><span class="line"><span class="function">[外部变量访问方式说明符]<span class="params">(参数表)</span>-&gt;返回值类型</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        语句组</span><br><span class="line">&#125;</span><br><span class="line">[=]以传值的方式使用外部变量</span><br><span class="line">[]  不使用任何外部变量</span><br><span class="line">[&amp;]以引用的方式使用所有的外部变量</span><br><span class="line">[x,&amp;y]x传值，有引用</span><br><span class="line">[=,&amp;x,&amp;y]x，y引用，其他传值</span><br><span class="line">[&amp;,x,y]x，y传值，其他引用</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h2><p>static_cast  reinterpret_cast<br>const_cast  dynamic_cast<br>1.static_cast<br>用于整型，实数型，字符型<br>static_cast&lt;类型&gt;(数)<br>2.reinterpret_cast<br>不同类型的指针之间的转换，不同类型的引用之间的转换<br>3.const_cast<br>去除const的转换<br>4.dynamic_cast<br>将多态基类的指针或引用强制转换为派生类的指针和引用<br>必须是多态</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>try{throw 类型}处理<br>catch(参数){}<br>多个catch<br>如果程序异常没有被catch捕获，程序崩溃<br>catch(…){}属于任何异常<br>exception类<br>bad_typeid<br>转换异常<br>bad_cast<br>多态基类指针转换异常<br>bad_alloc<br>在用new运算符进行动态内存分配时，没有足够的内存<br>ios_base::failure</p>
<p>bad_error–&gt;out_of_range<br>下标越界</p>
<h1 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>可以将子类赋值给父类，在继承时注意需要加public才能让子类继承父类，不然父类就成了私有类了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> :<span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Class C&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>override是在c++11的时候加的在c++中可以全用virtual也可以子类在函数名后加override</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Class B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> :<span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Class C&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="用子类指针调用基类"><a href="#用子类指针调用基类" class="headerlink" title="用子类指针调用基类"></a>用子类指针调用基类</h2><p>其一是强制转换但可以是不安全的</p>
<p>个人觉得其二还是有很大局限性的，需要基类要虚函数<br>其二是用dynamic_cast<br>将多态基类的指针或引用强制转换为派生类的指针和引用<br>必须是多态</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>TA2.2色调映射视差偏移</title>
    <url>/2022/03/26/TA2.2%E8%89%B2%E8%B0%83%E6%98%A0%E5%B0%84%E8%A7%86%E5%B7%AE%E5%81%8F%E7%A7%BB/</url>
    <content><![CDATA[<h1 id="Blinn-Phong"><a href="#Blinn-Phong" class="headerlink" title="Blinn-Phong"></a>Blinn-Phong</h1><p>半角向量&#x3D;观察方向V+光照方向L；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">half3 view_dir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.pos_world);</span><br><span class="line">                half3 light_dir =<span class="built_in">normalize</span>( _WorldSpaceLightPos0.xyz );</span><br><span class="line">                half3 half_dir  = <span class="built_in">normalize</span>(view_dir+light_dir);</span><br><span class="line">half NotH = <span class="built_in">max</span>(<span class="built_in">dot</span>(normal_dir,half_dir),<span class="number">0</span>);</span><br><span class="line">half3 specular =  <span class="built_in">pow</span>(<span class="built_in">max</span>(NotH,<span class="number">0</span>),_Shininess)* _LightColor0.xyz*_SpecularIntensity*spec_mask;</span><br></pre></td></tr></table></figure>

<h1 id="色彩映射"><a href="#色彩映射" class="headerlink" title="色彩映射"></a>色彩映射</h1><p>高光部分过曝，使得颜色直接变白色为了体现更多细节，将色调重新映射,注意一般这个处理都在后处理完成。实现如下。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">float3 <span class="title">ACESFilm</span><span class="params">(float3 x)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        <span class="type">float</span> a = <span class="number">2.51f</span>;</span><br><span class="line">        <span class="type">float</span> b = <span class="number">0.03f</span>;</span><br><span class="line">        <span class="type">float</span> c = <span class="number">2.43f</span>;</span><br><span class="line">        <span class="type">float</span> d = <span class="number">0.59f</span>;</span><br><span class="line">        <span class="type">float</span> e = <span class="number">0.14f</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">saturate</span>((x*(a*x + b)) / (x*(c*x + d) + e));</span><br><span class="line">      &#125;;</span><br><span class="line">base_color =<span class="built_in">pow</span>(base_color,<span class="number">2.2</span>);</span><br><span class="line">half3 tone_color = <span class="built_in">ACESFilm</span>(col.xyz);</span><br><span class="line">col.xyz=<span class="built_in">pow</span>(tone_color,<span class="number">1.0</span>/<span class="number">2.2</span>);</span><br></pre></td></tr></table></figure>

<h1 id="视察偏移"><a href="#视察偏移" class="headerlink" title="视察偏移"></a>视察偏移</h1><p>用高度图模拟侧面的观察的遮挡问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">float3 view_tangentspace = <span class="built_in">normalize</span>(<span class="built_in">mul</span>(TBN,view_dir));</span><br><span class="line">                half2 uv_parallax = i.uv;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;_HeightTime;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    half height = <span class="built_in">tex2D</span>(_Parallax,uv_parallax);</span><br><span class="line">                    uv_parallax = uv_parallax - (<span class="number">0.5</span> - height) * (view_tangentspace.xy/view_tangentspace.z+<span class="number">0.42</span>) *_ParallaxIntensity*<span class="number">0.01f</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                half3 base_color = <span class="built_in">tex2D</span>(_MainTex, uv_parallax).xyz;</span><br><span class="line">                base_color =<span class="built_in">pow</span>(base_color,<span class="number">2.2</span>);</span><br><span class="line">                half3 AO = <span class="built_in">tex2D</span>(_AOMap,uv_parallax).xyz;</span><br><span class="line">                half3 spec_mask = <span class="built_in">tex2D</span>(_SpecMask,uv_parallax).xyz;</span><br></pre></td></tr></table></figure>

<h1 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h1><p><img src="https://img-blog.csdnimg.cn/b4e49300b10d4343bbb929c5b0bb7819.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="实时阴影"><a href="#实时阴影" class="headerlink" title="实时阴影"></a>实时阴影</h2><h3 id="传统实时阴影"><a href="#传统实时阴影" class="headerlink" title="传统实时阴影"></a>传统实时阴影</h3><p><img src="https://img-blog.csdnimg.cn/d4e54fe16d55458192dffc2201354366.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>阴影距离决定定向光的拍摄位置位置大概是</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//摄像头的 forword 向量*阴影距离 向光照反方向 + 阴影距离</span></span><br></pre></td></tr></table></figure>

<p>在光源位置做摄像机，拍摄一张深度图</p>
<p><img src="https://img-blog.csdnimg.cn/399f4e8f6a9f4fb4844d403cb000798d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>将光源摄像头内的顶点转入光源相机空间用z坐标z1和shadowMap的灰度值z2进行比对，z1&lt;z2，则不再阴影区，最佳理解：就是单纯的摄像机深度剔除的部分，把光源看作摄像机，看到的就被照亮，没看到的就是阴影咯。</p>
<h3 id="Unity屏幕空间阴影"><a href="#Unity屏幕空间阴影" class="headerlink" title="Unity屏幕空间阴影"></a>Unity屏幕空间阴影</h3><p>用摄像头view渲染深度图，渲染的深度图可以还原屏幕需要的片元的世界坐标空间进行优化</p>
<p><img src="https://img-blog.csdnimg.cn/9346f44043224d33a328311423dcd20d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/52f6b72858994de695791f6b5f9e249f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>然后从Camera直接转到光照摄像头坐标系下。</p>
<h3 id="联级阴影-CSM"><a href="#联级阴影-CSM" class="headerlink" title="联级阴影 CSM"></a>联级阴影 CSM</h3><p>以下是个人通过unity猜测出来的，暂未找资料</p>
<p>分成四个区域，越靠近物体联级越多，把所有得到的联级进行均值混合原理还是前两种方法</p>
<p>证明</p>
<p>无联级，阴影距离3.3</p>
<p><img src="https://img-blog.csdnimg.cn/289b9b933af247808d08256809864b85.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>两联级，阴影距离10</p>
<p><img src="https://img-blog.csdnimg.cn/505e0a7663404e69abafbfecfb47481a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>得到的阴影效果会胡一点，可能是混合了</p>
<h2 id="阴影相关的内置函数"><a href="#阴影相关的内置函数" class="headerlink" title="阴影相关的内置函数"></a>阴影相关的内置函数</h2><h3 id="只计算实时阴影"><a href="#只计算实时阴影" class="headerlink" title="只计算实时阴影"></a>只计算实时阴影</h3><p>记得把v2f结构体中的vertex改成pos。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SHADOW_COORDS</span>(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">TRANSFER_SHADOW</span>(o)</span><br><span class="line">half shadow = <span class="built_in">SHADOW_ATTENUATION</span>(i);</span><br></pre></td></tr></table></figure>

<p>多光源</p>
<h3 id="混合光源计算"><a href="#混合光源计算" class="headerlink" title="混合光源计算"></a>混合光源计算</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">LIGHTING_COORDS</span>(<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">TRANSFER_VERTEX_TO_FRAGMENT</span>(o);</span><br><span class="line">half atten = <span class="built_in">LIGHT_ATTENUATION</span> (i);</span><br><span class="line">half NotL = <span class="built_in">min</span>(atten,<span class="built_in">max</span>(<span class="built_in">dot</span>(normal_dir,light_dir),<span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>在forwardadd中一定把环境光删除，否则出现阴影锯齿。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;lit/Blin-Phong&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _NormalMap(<span class="string">&quot;Normal Map&quot;</span>,<span class="number">2</span>D)=<span class="string">&quot;bump&quot;</span>&#123;&#125;</span><br><span class="line">        _NormalIntensity(<span class="string">&quot;Normal Intensity&quot;</span>,<span class="built_in">Range</span>(<span class="number">0.0</span>,<span class="number">5.0</span>))= <span class="number">1.0</span></span><br><span class="line">        _AOMap(<span class="string">&quot;AO Map&quot;</span>,<span class="number">2</span>D)=<span class="string">&quot;white&quot;</span>&#123;&#125;</span><br><span class="line">         _SpecMask(<span class="string">&quot;Spec Mask&quot;</span>,<span class="number">2</span>D)=<span class="string">&quot;white&quot;</span>&#123;&#125;</span><br><span class="line">        _Shininess (<span class="string">&quot;Shininess&quot;</span>, Float) = <span class="number">1</span></span><br><span class="line">        _SpecularIntensity(<span class="string">&quot;SpecularIntensity&quot;</span>,<span class="built_in">Range</span>(<span class="number">0.01</span>,<span class="number">5</span>))= <span class="number">1.0</span></span><br><span class="line">        _Parallax(<span class="string">&quot;Parallax&quot;</span>,<span class="number">2</span>D)=<span class="string">&quot;black&quot;</span>&#123;&#125;</span><br><span class="line">        _ParallaxIntensity(<span class="string">&quot;Parallax Intensity&quot;</span>,Float)=<span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">        _HeightTime(<span class="string">&quot;Height Time&quot;</span>,<span class="built_in">Range</span>(<span class="number">0</span>,<span class="number">10</span>))=<span class="number">1.0</span></span><br><span class="line">        <span class="comment">//_AmbientColor(&quot;Ambient Color&quot;,Color)=(0,0,0,0)</span></span><br><span class="line">       <span class="comment">// __AmbientIntensity(&quot;Ambient Intensity&quot;,Float)=0</span></span><br><span class="line">       </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span>&#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdbase</span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AutoLight.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 normal:NORMAL;</span><br><span class="line">                float4 tangent:TANGENT;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">v2f</span></span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 normali_dir:TEXCOORD1;</span><br><span class="line">                float3 tangent_dir:TEXCOORD2;</span><br><span class="line">                float3 binormal_dir:TEXCOORD3;</span><br><span class="line">                float3 pos_world:TEXCOORD4;</span><br><span class="line">                <span class="built_in">SHADOW_COORDS</span>(<span class="number">5</span>)</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            sampler2D _AOMap;</span><br><span class="line">            float4 _AOMap_ST;</span><br><span class="line">            float4 _LightColor0;</span><br><span class="line">            <span class="type">float</span> _Shininess;</span><br><span class="line">            <span class="type">float</span> _SpecularIntensity;</span><br><span class="line">            <span class="comment">//float4 _AmbientColor; </span></span><br><span class="line">            sampler2D _SpecMask;</span><br><span class="line">            <span class="type">float</span> _SpecMask_ST; </span><br><span class="line">            sampler2D _NormalMap;</span><br><span class="line">            float4 _NormalMap_ST; </span><br><span class="line">            <span class="type">float</span> _NormalIntensity;</span><br><span class="line">            sampler2D _Parallax;</span><br><span class="line">            <span class="type">float</span> _ParallaxIntensity;</span><br><span class="line">            <span class="type">float</span> _HeightTime;</span><br><span class="line">            <span class="comment">//float __AmbientIntensity;</span></span><br><span class="line"></span><br><span class="line">            <span class="function">float3 <span class="title">ACESFilm</span><span class="params">(float3 x)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        <span class="type">float</span> a = <span class="number">2.51f</span>;</span><br><span class="line">        <span class="type">float</span> b = <span class="number">0.03f</span>;</span><br><span class="line">        <span class="type">float</span> c = <span class="number">2.43f</span>;</span><br><span class="line">        <span class="type">float</span> d = <span class="number">0.59f</span>;</span><br><span class="line">        <span class="type">float</span> e = <span class="number">0.14f</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">saturate</span>((x*(a*x + b)) / (x*(c*x + d) + e));</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span> <span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = <span class="built_in">UnityObjectToClipPos</span>(v.vertex);</span><br><span class="line">                o.normali_dir = <span class="built_in">normalize</span>(<span class="built_in">mul</span>(<span class="built_in">float4</span>(v.normal,<span class="number">0.0</span>),unity_WorldToObject).xyz);</span><br><span class="line">                o.tangent_dir = <span class="built_in">normalize</span>(<span class="built_in">mul</span>(<span class="built_in">float4</span>(v.tangent.xyz,<span class="number">0.0</span>),unity_WorldToObject).xyz);</span><br><span class="line">                o.binormal_dir = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(o.normali_dir,o.tangent_dir))* v.tangent.w;</span><br><span class="line">                o.pos_world = <span class="built_in">mul</span>(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line">                o.uv = <span class="built_in">TRANSFORM_TEX</span>(v.uv, _MainTex);</span><br><span class="line">                <span class="built_in">TRANSFER_SHADOW</span>(o)</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span> <span class="params">(v2f i)</span> : SV_Target</span></span><br><span class="line"><span class="function">            &#123;</span></span><br><span class="line">                fixed4 col=<span class="built_in">fixed4</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">                </span><br><span class="line">           </span><br><span class="line">                half shadow = <span class="built_in">SHADOW_ATTENUATION</span>(i);</span><br><span class="line">                half4 normalmap = <span class="built_in">tex2D</span>(_NormalMap,i.uv);</span><br><span class="line">                half3 view_dir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.pos_world);</span><br><span class="line">                half3 light_dir =<span class="built_in">normalize</span>( _WorldSpaceLightPos0.xyz );</span><br><span class="line">                half3 half_dir  = <span class="built_in">normalize</span>(view_dir+light_dir);</span><br><span class="line">                <span class="comment">//Normal</span></span><br><span class="line">                half3 normal_dir  =<span class="built_in">normalize</span>(i.normali_dir);</span><br><span class="line">                half3 tangent_dir  =<span class="built_in">normalize</span>(i.tangent_dir)*_NormalIntensity;</span><br><span class="line">                half3 binormal_dir =<span class="built_in">normalize</span>(i.binormal_dir)*_NormalIntensity;</span><br><span class="line">                half3 normal_data = <span class="built_in">UnpackNormal</span>(normalmap);</span><br><span class="line">                float3x3 TBN = <span class="built_in">float3x3</span>(tangent_dir,binormal_dir,normal_dir);</span><br><span class="line">                normal_dir =<span class="built_in">normalize</span>(<span class="built_in">mul</span>(normal_data,TBN));</span><br><span class="line">                <span class="comment">//normal_dir=tangent_dir*normal_data.x*_NormalIntensity+binormal_dir*normal_data.y*_NormalIntensity+normal_dir*normal_data.z ;</span></span><br><span class="line">              </span><br><span class="line">                float3 view_tangentspace = <span class="built_in">normalize</span>(<span class="built_in">mul</span>(TBN,view_dir));</span><br><span class="line">                half2 uv_parallax = i.uv;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;_HeightTime;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    half height = <span class="built_in">tex2D</span>(_Parallax,uv_parallax);</span><br><span class="line">                    uv_parallax = uv_parallax - (<span class="number">0.5</span> - height) * (view_tangentspace.xy/view_tangentspace.z+<span class="number">0.42</span>) *_ParallaxIntensity*<span class="number">0.01f</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                half3 base_color = <span class="built_in">tex2D</span>(_MainTex, uv_parallax).xyz;</span><br><span class="line">                base_color =<span class="built_in">pow</span>(base_color,<span class="number">2.2</span>);</span><br><span class="line">                half3 AO = <span class="built_in">tex2D</span>(_AOMap,uv_parallax).xyz;</span><br><span class="line">                half3 spec_mask = <span class="built_in">tex2D</span>(_SpecMask,uv_parallax).xyz;</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">                half NotL = <span class="built_in">min</span>(shadow,<span class="built_in">max</span>(<span class="built_in">dot</span>(normal_dir,light_dir),<span class="number">0</span>));</span><br><span class="line">                half NotH = <span class="built_in">max</span>(<span class="built_in">dot</span>(normal_dir,half_dir),<span class="number">0</span>);</span><br><span class="line">                half3 diffuse =  NotL*_LightColor0.xyz;</span><br><span class="line">                half3 specular =  <span class="built_in">pow</span>(<span class="built_in">max</span>(NotH,<span class="number">0</span>),_Shininess)* _LightColor0.xyz*_SpecularIntensity*spec_mask*NotL;</span><br><span class="line">               <span class="comment">// half3 ambient =  _AmbientColor.xyz*__AmbientIntensity;</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//col.xyz+= AO;</span></span><br><span class="line"></span><br><span class="line">                col.xyz += diffuse;</span><br><span class="line">                col.xyz += specular;</span><br><span class="line">                col.xyz += UNITY_LIGHTMODEL_AMBIENT.xyz; </span><br><span class="line"></span><br><span class="line">                 <span class="comment">// sample the texture</span></span><br><span class="line">                col.xyz *=base_color;</span><br><span class="line">                col.xyz *=AO;</span><br><span class="line">                half3 tone_color = <span class="built_in">ACESFilm</span>(col.xyz);</span><br><span class="line">                col.xyz=<span class="built_in">pow</span>(tone_color,<span class="number">1.0</span>/<span class="number">2.2</span>);</span><br><span class="line">                <span class="comment">// apply fog</span></span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">       Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardAdd&quot;</span>&#125;</span><br><span class="line">            Blend One One</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdadd</span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AutoLight.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 normal:NORMAL;</span><br><span class="line">                float4 tangent:TANGENT;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">v2f</span></span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 normali_dir:TEXCOORD1;</span><br><span class="line">                float3 tangent_dir:TEXCOORD2;</span><br><span class="line">                float3 binormal_dir:TEXCOORD3;</span><br><span class="line">                float3 pos_world:TEXCOORD4;</span><br><span class="line">                <span class="built_in">LIGHTING_COORDS</span>(<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            sampler2D _AOMap;</span><br><span class="line">            float4 _AOMap_ST;</span><br><span class="line">            float4 _LightColor0;</span><br><span class="line">            <span class="type">float</span> _Shininess;</span><br><span class="line">            <span class="type">float</span> _SpecularIntensity;</span><br><span class="line">            <span class="comment">//float4 _AmbientColor; </span></span><br><span class="line">            sampler2D _SpecMask;</span><br><span class="line">            <span class="type">float</span> _SpecMask_ST; </span><br><span class="line">            sampler2D _NormalMap;</span><br><span class="line">            float4 _NormalMap_ST; </span><br><span class="line">            <span class="type">float</span> _NormalIntensity;</span><br><span class="line">            sampler2D _Parallax;</span><br><span class="line">            <span class="type">float</span> _ParallaxIntensity;</span><br><span class="line">            <span class="type">float</span> _HeightTime;</span><br><span class="line">            <span class="comment">//float __AmbientIntensity;</span></span><br><span class="line"></span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span> <span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = <span class="built_in">UnityObjectToClipPos</span>(v.vertex);</span><br><span class="line">                o.normali_dir = <span class="built_in">normalize</span>(<span class="built_in">mul</span>(<span class="built_in">float4</span>(v.normal,<span class="number">0.0</span>),unity_WorldToObject).xyz);</span><br><span class="line">                o.tangent_dir = <span class="built_in">normalize</span>(<span class="built_in">mul</span>(<span class="built_in">float4</span>(v.tangent.xyz,<span class="number">0.0</span>),unity_WorldToObject).xyz);</span><br><span class="line">                o.binormal_dir = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(o.normali_dir,o.tangent_dir))* v.tangent.w;</span><br><span class="line">                o.pos_world = <span class="built_in">mul</span>(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line">                o.uv = <span class="built_in">TRANSFORM_TEX</span>(v.uv, _MainTex);</span><br><span class="line">                <span class="built_in">TRANSFER_VERTEX_TO_FRAGMENT</span>(o);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span> <span class="params">(v2f i)</span> : SV_Target</span></span><br><span class="line"><span class="function">            &#123;</span></span><br><span class="line">                fixed4 col=<span class="built_in">fixed4</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">                </span><br><span class="line">           </span><br><span class="line">                half atten = <span class="built_in">LIGHT_ATTENUATION</span> (i);</span><br><span class="line">                half4 normalmap = <span class="built_in">tex2D</span>(_NormalMap,i.uv);</span><br><span class="line">                half3 view_dir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.pos_world);</span><br><span class="line">                half3 light_dir_point =<span class="built_in">normalize</span>( _WorldSpaceLightPos0.xyz - i.pos_world);</span><br><span class="line">                half3 light_dir =<span class="built_in">normalize</span>( _WorldSpaceLightPos0.xyz );</span><br><span class="line">                light_dir = <span class="built_in">lerp</span>(light_dir,light_dir_point,_WorldSpaceLightPos0.w);</span><br><span class="line">                half3 half_dir  = <span class="built_in">normalize</span>(view_dir+light_dir);</span><br><span class="line">                <span class="comment">//Normal</span></span><br><span class="line">                half3 normal_dir  =<span class="built_in">normalize</span>(i.normali_dir);</span><br><span class="line">                half3 tangent_dir  =<span class="built_in">normalize</span>(i.tangent_dir)*_NormalIntensity;</span><br><span class="line">                half3 binormal_dir =<span class="built_in">normalize</span>(i.binormal_dir)*_NormalIntensity;</span><br><span class="line">                half3 normal_data = <span class="built_in">UnpackNormal</span>(normalmap);</span><br><span class="line">                float3x3 TBN = <span class="built_in">float3x3</span>(tangent_dir,binormal_dir,normal_dir);</span><br><span class="line">                normal_dir =<span class="built_in">normalize</span>(<span class="built_in">mul</span>(normal_data,TBN));</span><br><span class="line">                <span class="comment">//normal_dir=tangent_dir*normal_data.x*_NormalIntensity+binormal_dir*normal_data.y*_NormalIntensity+normal_dir*normal_data.z ;</span></span><br><span class="line">              </span><br><span class="line">                float3 view_tangentspace = <span class="built_in">normalize</span>(<span class="built_in">mul</span>(TBN,view_dir));</span><br><span class="line">                half2 uv_parallax = i.uv;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;_HeightTime;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    half height = <span class="built_in">tex2D</span>(_Parallax,uv_parallax);</span><br><span class="line">                    uv_parallax = uv_parallax - (<span class="number">0.5</span> - height) * (view_tangentspace.xy/view_tangentspace.z+<span class="number">0.42</span>) *_ParallaxIntensity*<span class="number">0.01f</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                half3 base_color = <span class="built_in">tex2D</span>(_MainTex, uv_parallax).xyz;</span><br><span class="line">                </span><br><span class="line">                half3 AO = <span class="built_in">tex2D</span>(_AOMap,uv_parallax).xyz;</span><br><span class="line">                half3 spec_mask = <span class="built_in">tex2D</span>(_SpecMask,uv_parallax).xyz;</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">                half NotL = <span class="built_in">min</span>(atten,<span class="built_in">max</span>(<span class="built_in">dot</span>(normal_dir,light_dir),<span class="number">0</span>));</span><br><span class="line">                half NotH = <span class="built_in">max</span>(<span class="built_in">dot</span>(normal_dir,half_dir),<span class="number">0</span>);</span><br><span class="line">                half3 diffuse =  NotL*_LightColor0.xyz;</span><br><span class="line">                half3 specular =  <span class="built_in">pow</span>(<span class="built_in">max</span>(NotH,<span class="number">0</span>),_Shininess)* _LightColor0.xyz*_SpecularIntensity*spec_mask*NotL;</span><br><span class="line"></span><br><span class="line">                col.xyz += diffuse;</span><br><span class="line">                col.xyz += specular;</span><br><span class="line">               </span><br><span class="line"></span><br><span class="line">                 <span class="comment">// sample the texture</span></span><br><span class="line">                col.xyz *=base_color;</span><br><span class="line">                col.xyz *=AO;</span><br><span class="line">             </span><br><span class="line">                <span class="comment">// apply fog</span></span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>Games104第2节记录</title>
    <url>/2022/03/22/Games104%E7%AC%AC3%E8%8A%82%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="如何构建游戏世界"><a href="#如何构建游戏世界" class="headerlink" title="如何构建游戏世界"></a>如何构建游戏世界</h1><h1 id="如何让游戏世界活起来"><a href="#如何让游戏世界活起来" class="headerlink" title="如何让游戏世界活起来"></a>如何让游戏世界活起来</h1><p>将物体变成GO（ Game Object）</p>
<p>动态物体</p>
<p><img src="https://img-blog.csdnimg.cn/ecc483da75994bb9a6fe64b7a709b970.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>静态物体</p>
<p><img src="https://img-blog.csdnimg.cn/0f44a362a514421287f5bb72021a117d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>环境</p>
<p>​    天空，地形，植被</p>
<p><img src="https://img-blog.csdnimg.cn/c65850254e2647f186d66c4bc77886d5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>其他物体</p>
<p>​    空气墙，规则</p>
<p><img src="C:\Users\27371\AppData\Roaming\Typora\typora-user-images\image-20220330164946213.png" alt="image-20220330164946213"></p>
<h1 id="如何去描述虚拟世界的物体"><a href="#如何去描述虚拟世界的物体" class="headerlink" title="如何去描述虚拟世界的物体"></a>如何去描述虚拟世界的物体</h1><p>将物体的属性和行为封装在一起，成为一个对象。</p>
<p>假如但有两个功能时我怎么处理</p>
<h2 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h2><p>每一个Component类都需要一个tick()函数</p>
<p>多功能物体我们用组合方法来解决。</p>
<p><img src="https://img-blog.csdnimg.cn/ded04fd6b0544d6099e8575a3bdb44a6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/c20590192bd44886b2a15c36a9906d04.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="怎么让游戏动起来"><a href="#怎么让游戏动起来" class="headerlink" title="怎么让游戏动起来"></a>怎么让游戏动起来</h1><p>进行单个系统进行tick()。</p>
<p><img src="https://img-blog.csdnimg.cn/f62c230d4d0f4af28c6e47528f9b373c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>一个一个系统进行tick，而不是一个物体一个物体进行tick，这样的架构会更高效</p>
<h1 id="如何在游戏引爆炸弹"><a href="#如何在游戏引爆炸弹" class="headerlink" title="如何在游戏引爆炸弹"></a>如何在游戏引爆炸弹</h1><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>如果写在一个爆炸类里用switch判断，随着系统的复杂类会越来越大。变得不可调试。爆炸类只需要将这给消息传给其他组件让其他类添加相关方法。</p>
<h1 id="如何管理Game-Object"><a href="#如何管理Game-Object" class="headerlink" title="如何管理Game Object"></a>如何管理Game Object</h1><h2 id="Scene-Management"><a href="#Scene-Management" class="headerlink" title="Scene Management"></a>Scene Management</h2><p>每一个物体都需要一个特别的UID</p>
<p>每个物体都需要一个位置</p>
<h3 id="简单的空间分割"><a href="#简单的空间分割" class="headerlink" title="简单的空间分割"></a>简单的空间分割</h3><h4 id="不需要划分"><a href="#不需要划分" class="headerlink" title="不需要划分"></a>不需要划分</h4><p>物体较少的情况下直接遍历</p>
<p>优点：特别简单，无脑</p>
<p>缺点：但物体多就效率低</p>
<h4 id="进行网格划分"><a href="#进行网格划分" class="headerlink" title="进行网格划分"></a>进行网格划分</h4><p>对格子进行编号，发生事件找邻近格子的部分物体</p>
<p>优点：对比上一种方法能减轻弊端</p>
<p>缺点：对于空间不均匀不适用</p>
<h4 id="四叉树"><a href="#四叉树" class="headerlink" title="四叉树"></a>四叉树</h4><p>对目标块不断的划分。</p>
<p><img src="https://img-blog.csdnimg.cn/26e21d25bf784fca866a120365a6113c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="空间数据管理"><a href="#空间数据管理" class="headerlink" title="空间数据管理"></a>空间数据管理</h3><p>最常用的是BVH方法。</p>
<p><img src="https://img-blog.csdnimg.cn/59b9a5d92205484d98395d4e5c178e37.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>一切都是对象</p>
<p>游戏对象可以用基于组件的方式来描述</p>
<p>游戏对象的状态会在tick循环中更新</p>
<p>游戏对象是通过有效的策略在场景中管理的</p>
<h1 id="物体tick的先后顺序"><a href="#物体tick的先后顺序" class="headerlink" title="物体tick的先后顺序"></a>物体tick的先后顺序</h1><p>多线程通信问题，当你访问其他线程时先通过一个邮局，然后由邮局统一相互发送消息。保证时序一定一致。比如你的精彩时刻是记录玩家的输入，如果是多核执行可能导致结果不一样。</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>引擎制作</tag>
      </tags>
  </entry>
  <entry>
    <title>TA3.1环境贴图技术</title>
    <url>/2022/04/01/TA3.1%E7%8E%AF%E5%A2%83%E8%B4%B4%E5%9B%BE%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><p><img src="https://img-blog.csdnimg.cn/88c6172ddf434fe08f2402d04f5c72ed.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h1 id="环境贴图"><a href="#环境贴图" class="headerlink" title="环境贴图"></a>环境贴图</h1><p><img src="https://img-blog.csdnimg.cn/3dbe7748467c4b17b46bef1315a907f5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_15,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"></p>
<p>立方体贴图采样如上</p>
<h2 id="采样缺陷"><a href="#采样缺陷" class="headerlink" title="采样缺陷"></a>采样缺陷</h2><p>当同一角度，不同位置看过去会得到同样采样，所以不适合平面采样，解决方案后续说。</p>
<p><img src="https://img-blog.csdnimg.cn/992f6d6e2a2544f08ae0c748c47a10b6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">v2f <span class="title">vert</span> <span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function">         </span>&#123;</span><br><span class="line">             v2f o;</span><br><span class="line">             o.pos = <span class="built_in">UnityObjectToClipPos</span>(v.vertex);</span><br><span class="line">             o.normal_world = <span class="built_in">normalize</span>(<span class="built_in">mul</span>((v.normal),unity_WorldToObject).xyz);</span><br><span class="line">             o.tangent_world = <span class="built_in">normalize</span>(<span class="built_in">mul</span>((v.tangent),unity_WorldToObject).xyz);</span><br><span class="line">             o.binormal_world=<span class="built_in">normalize</span>(<span class="built_in">cross</span>(o.normal_world,o.tangent_world) * v.tangent.w);</span><br><span class="line">             o.pos_world = <span class="built_in">normalize</span>(<span class="built_in">mul</span>((v.vertex),unity_WorldToObject).xyz);</span><br><span class="line">             o.uv = v.uv*_NormalMap_ST.xy+_NormalMap_ST.zw;</span><br><span class="line">             </span><br><span class="line">             <span class="keyword">return</span> o;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function">fixed4 <span class="title">frag</span> <span class="params">(v2f i)</span> : SV_Target</span></span><br><span class="line"><span class="function">         &#123;</span></span><br><span class="line">             <span class="comment">// sample the texture</span></span><br><span class="line">             <span class="comment">//fixed4 base_col = tex2D(_MainTex, i.uv);</span></span><br><span class="line">             fixed4 base_col = <span class="built_in">fixed4</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">             half3 normaldata = <span class="built_in">UnpackNormal</span>( <span class="built_in">tex2D</span>(_NormalMap, i.uv));</span><br><span class="line">             half3 normal_world = <span class="built_in">normalize</span>(i.normal_world);</span><br><span class="line">             half3 tangent_world = <span class="built_in">normalize</span>(i.tangent_world);</span><br><span class="line">             half3 binormal_world = <span class="built_in">normalize</span>(i.binormal_world);</span><br><span class="line">             normal_world=<span class="built_in">mul</span>(normaldata, <span class="built_in">float3x3</span>(tangent_world,binormal_world,normal_world));</span><br><span class="line"></span><br><span class="line">             half3 view_dir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz-i.pos_world.xyz);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             half3 reflect_dir =<span class="built_in">reflect</span>(-view_dir,normal_world);</span><br><span class="line">             half4 finish_col = base_col;</span><br><span class="line">             </span><br><span class="line">             half4 Cube_col=<span class="built_in">texCUBE</span>(_CubeMap,reflect_dir); </span><br><span class="line">             half3 CubeHDR_col=<span class="built_in">DecodeHDR</span>(Cube_col,_CubeMap_HDR);</span><br><span class="line">             finish_col.rgb+=CubeHDR_col;</span><br><span class="line">             <span class="keyword">return</span> finish_col;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>



<h1 id="IBL-基于图像的光照技术"><a href="#IBL-基于图像的光照技术" class="headerlink" title="IBL 基于图像的光照技术"></a>IBL 基于图像的光照技术</h1><h2 id="预计算卷积"><a href="#预计算卷积" class="headerlink" title="预计算卷积"></a>预计算卷积</h2><p>通过模糊，得到不同层次的mip Map，便于模拟相应的磨砂层次。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">half4 Cube_col=<span class="built_in">texCUBElod</span>(_CubeMap,<span class="built_in">float4</span>(reflect_dir,_Roughness))</span><br></pre></td></tr></table></figure>

<p>粗糙度变成非线性</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">roughness=roughness*(<span class="number">1.7</span><span class="number">-0.7</span>*roughness);</span><br></pre></td></tr></table></figure>

<h2 id="反射探针"><a href="#反射探针" class="headerlink" title="反射探针"></a>反射探针</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">half4 Cube_col = <span class="built_in">UNITY_SAMPLE_TEXCUBE_LOD</span>(unity_SpecCube0,reflect_dir,_Roughness);</span><br></pre></td></tr></table></figure>

<p>为了用反射探针</p>
<p>UNITY_SAMPLE_TEXCUBE_LOD(反射贴图，反射向量，mip)</p>
<p>UNITY_SAMPLE_TEXCUBE(反射贴图，反射向量)  </p>
<p>反射探针贴图</p>
<p>unity_SpecCube0 </p>
<h1 id="SH球谐光照"><a href="#SH球谐光照" class="headerlink" title="SH球谐光照"></a>SH球谐光照</h1><h2 id="造轮子"><a href="#造轮子" class="headerlink" title="造轮子"></a>造轮子</h2><h3 id="shader"><a href="#shader" class="headerlink" title="shader"></a>shader</h3><p>将光照信息记录下来，实现间接光照。</p>
<p>属性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">custom_SHAr(<span class="string">&quot;Custom SHAr&quot;</span>, Vector) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">custom_SHAg(<span class="string">&quot;Custom SHAg&quot;</span>, Vector) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">custom_SHAb(<span class="string">&quot;Custom SHAb&quot;</span>, Vector) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">custom_SHBr(<span class="string">&quot;Custom SHBr&quot;</span>, Vector) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">custom_SHBg(<span class="string">&quot;Custom SHBg&quot;</span>, Vector) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">custom_SHBb(<span class="string">&quot;Custom SHBb&quot;</span>, Vector) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">custom_SHC(<span class="string">&quot;Custom SHC&quot;</span>, Vector) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>片元</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">float4 normalForSH = <span class="built_in">float4</span>(normal_dir, <span class="number">1.0</span>);</span><br><span class="line"><span class="comment">//SHEvalLinearL0L1</span></span><br><span class="line">half3 x;</span><br><span class="line">x.r = <span class="built_in">dot</span>(custom_SHAr, normalForSH);</span><br><span class="line">x.g = <span class="built_in">dot</span>(custom_SHAg, normalForSH);</span><br><span class="line">x.b = <span class="built_in">dot</span>(custom_SHAb, normalForSH);</span><br><span class="line"></span><br><span class="line"><span class="comment">//SHEvalLinearL2</span></span><br><span class="line">half3 x1, x2;</span><br><span class="line"><span class="comment">// 4 of the quadratic (L2) polynomials</span></span><br><span class="line">half4 vB = normalForSH.xyzz * normalForSH.yzzx;</span><br><span class="line">x1.r = <span class="built_in">dot</span>(custom_SHBr, vB);</span><br><span class="line">x1.g = <span class="built_in">dot</span>(custom_SHBg, vB);</span><br><span class="line">x1.b = <span class="built_in">dot</span>(custom_SHBb, vB);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Final (5th) quadratic (L2) polynomial</span></span><br><span class="line">half vC = normalForSH.x*normalForSH.x - normalForSH.y*normalForSH.y;</span><br><span class="line">x2 = custom_SHC.rgb * vC;</span><br><span class="line"></span><br><span class="line">float3 sh = <span class="built_in">max</span>(<span class="built_in">float3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>), (x + x1 + x2));</span><br><span class="line">sh = <span class="built_in">pow</span>(sh, <span class="number">1.0</span> / <span class="number">2.2</span>);</span><br><span class="line"></span><br><span class="line">half3 env_color = sh;</span><br></pre></td></tr></table></figure>

<p>部分函数可以放在顶点着色器中</p>
<h3 id="获取属性工具"><a href="#获取属性工具" class="headerlink" title="获取属性工具"></a>获取属性工具</h3><h4 id="SphericalHarmonicsCoefficient"><a href="#SphericalHarmonicsCoefficient" class="headerlink" title="SphericalHarmonicsCoefficient"></a>SphericalHarmonicsCoefficient</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 球谐光照因子计算方法,结果可以跟Unity内部的算法匹配上</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> http://sunandblackcat.com/tipFullView.php?l=eng&amp;topicid=32&amp;topic=Spherical-Harmonics-From-Cube-Texture</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> https://github.com/Microsoft/DirectXMath</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> http://www.ppsloan.org/publications/StupidSH36.pdf</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">SphericalHarmonicsCoefficient</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sphericalHarmonicsFromCubemap9</span>(<span class="params">Cubemap cubeTexture, <span class="keyword">ref</span> Vector3[] output</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// allocate memory for calculations</span></span><br><span class="line">        <span class="built_in">float</span>[] resultR = <span class="keyword">new</span> <span class="built_in">float</span>[<span class="number">9</span>];</span><br><span class="line">        <span class="built_in">float</span>[] resultG = <span class="keyword">new</span> <span class="built_in">float</span>[<span class="number">9</span>];</span><br><span class="line">        <span class="built_in">float</span>[] resultB = <span class="keyword">new</span> <span class="built_in">float</span>[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// initialize values</span></span><br><span class="line">        <span class="built_in">float</span> fWt = <span class="number">0.0f</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">uint</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            resultR[i] = <span class="number">0</span>;</span><br><span class="line">            resultG[i] = <span class="number">0</span>;</span><br><span class="line">            resultB[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">float</span>[] shBuff = <span class="keyword">new</span> <span class="built_in">float</span>[<span class="number">9</span>];</span><br><span class="line">        <span class="built_in">float</span>[] shBuffB = <span class="keyword">new</span> <span class="built_in">float</span>[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for each face of cube texture</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> face = <span class="number">0</span>; face &lt; <span class="number">6</span>; face++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// step between two texels for range [0, 1]</span></span><br><span class="line">            <span class="built_in">float</span> invWidth = <span class="number">1.0f</span> / cubeTexture.width;</span><br><span class="line">            <span class="comment">// initial negative bound for range [-1, 1]</span></span><br><span class="line">            <span class="built_in">float</span> negativeBound = <span class="number">-1.0f</span> + invWidth;</span><br><span class="line">            <span class="comment">// step between two texels for range [-1, 1]</span></span><br><span class="line">            <span class="built_in">float</span> invWidthBy2 = <span class="number">2.0f</span> / cubeTexture.width;</span><br><span class="line"></span><br><span class="line">            Color[] data = cubeTexture.GetPixels((CubemapFace)face);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> y = <span class="number">0</span>; y &lt; cubeTexture.width; y++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// texture coordinate V in range [-1 to 1]</span></span><br><span class="line">                <span class="built_in">float</span> fV = negativeBound + y * invWidthBy2;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> x = <span class="number">0</span>; x &lt; cubeTexture.width; x++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// texture coordinate U in range [-1 to 1]</span></span><br><span class="line">                    <span class="built_in">float</span> fU = negativeBound + x * invWidthBy2;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// determine direction from center of cube texture to current texel</span></span><br><span class="line">                    Vector3 dir;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">switch</span> ((CubemapFace)face)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">case</span> CubemapFace.PositiveX:</span><br><span class="line">                            dir.x = <span class="number">1.0f</span>;</span><br><span class="line">                            dir.y = <span class="number">1.0f</span> - (invWidthBy2 * y + invWidth);</span><br><span class="line">                            dir.z = <span class="number">1.0f</span> - (invWidthBy2 * x + invWidth);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> CubemapFace.NegativeX:</span><br><span class="line">                            dir.x = <span class="number">-1.0f</span>;</span><br><span class="line">                            dir.y = <span class="number">1.0f</span> - (invWidthBy2 * y + invWidth);</span><br><span class="line">                            dir.z = <span class="number">-1.0f</span> + (invWidthBy2 * x + invWidth);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> CubemapFace.PositiveY:</span><br><span class="line">                            dir.x = <span class="number">-1.0f</span> + (invWidthBy2 * x + invWidth);</span><br><span class="line">                            dir.y = <span class="number">1.0f</span>;</span><br><span class="line">                            dir.z = <span class="number">-1.0f</span> + (invWidthBy2 * y + invWidth);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> CubemapFace.NegativeY:</span><br><span class="line">                            dir.x = <span class="number">-1.0f</span> + (invWidthBy2 * x + invWidth);</span><br><span class="line">                            dir.y = <span class="number">-1.0f</span>;</span><br><span class="line">                            dir.z = <span class="number">1.0f</span> - (invWidthBy2 * y + invWidth);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> CubemapFace.PositiveZ:</span><br><span class="line">                            dir.x = <span class="number">-1.0f</span> + (invWidthBy2 * x + invWidth);</span><br><span class="line">                            dir.y = <span class="number">1.0f</span> - (invWidthBy2 * y + invWidth);</span><br><span class="line">                            dir.z = <span class="number">1.0f</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> CubemapFace.NegativeZ:</span><br><span class="line">                            dir.x = <span class="number">1.0f</span> - (invWidthBy2 * x + invWidth);</span><br><span class="line">                            dir.y = <span class="number">1.0f</span> - (invWidthBy2 * y + invWidth);</span><br><span class="line">                            dir.z = <span class="number">-1.0f</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="literal">default</span>:</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// normalize direction</span></span><br><span class="line">                    dir = dir.normalized;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// scale factor depending on distance from center of the face</span></span><br><span class="line">                    <span class="built_in">float</span> fDiffSolid = <span class="number">4.0f</span> / ((<span class="number">1.0f</span> + fU * fU + fV * fV) * Mathf.Sqrt(<span class="number">1.0f</span> + fU * fU + fV * fV));</span><br><span class="line">                    fWt += fDiffSolid;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// calculate coefficients of spherical harmonics for current direction</span></span><br><span class="line">                    sphericalHarmonicsEvaluateDirection9(<span class="keyword">ref</span> shBuff, dir);</span><br><span class="line">                    <span class="comment">//XMSHEvalDirection(dir, ref shBuff);</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// index of texel in texture</span></span><br><span class="line">                    <span class="built_in">int</span> pixOffsetIndex = x + y * cubeTexture.width;</span><br><span class="line">                    <span class="comment">// get color from texture and map to range [0, 1]</span></span><br><span class="line">                    Vector3 clr= <span class="keyword">new</span> Vector3(data[pixOffsetIndex].r, data[pixOffsetIndex].g, data[pixOffsetIndex].b);</span><br><span class="line">                    <span class="comment">//if (data[pixOffsetIndex].a == 1)</span></span><br><span class="line">                    <span class="comment">//&#123;</span></span><br><span class="line">                    <span class="comment">//    clr = new Vector3(data[pixOffsetIndex].r, data[pixOffsetIndex].g, data[pixOffsetIndex].b);</span></span><br><span class="line">                    <span class="comment">//&#125;</span></span><br><span class="line">                    <span class="comment">//else</span></span><br><span class="line">                    <span class="comment">//&#123;</span></span><br><span class="line">                    <span class="comment">//    clr = DecodeHDR(data[pixOffsetIndex]);</span></span><br><span class="line">                    <span class="comment">//&#125;</span></span><br><span class="line">                    <span class="keyword">if</span> (PlayerSettings.colorSpace == ColorSpace.Gamma)</span><br><span class="line">                    &#123;</span><br><span class="line">                        clr.x = Mathf.GammaToLinearSpace(clr.x);</span><br><span class="line">                        clr.y = Mathf.GammaToLinearSpace(clr.y);</span><br><span class="line">                        clr.z = Mathf.GammaToLinearSpace(clr.z);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// scale color and add to previously accumulated coefficients</span></span><br><span class="line">                    sphericalHarmonicsScale9(<span class="keyword">ref</span> shBuffB, shBuff, clr.x * fDiffSolid);</span><br><span class="line">                    sphericalHarmonicsAdd9(<span class="keyword">ref</span> resultR, resultR, shBuffB);</span><br><span class="line">                    sphericalHarmonicsScale9(<span class="keyword">ref</span> shBuffB, shBuff, clr.y * fDiffSolid);</span><br><span class="line">                    sphericalHarmonicsAdd9(<span class="keyword">ref</span> resultG, resultG, shBuffB);</span><br><span class="line">                    sphericalHarmonicsScale9(<span class="keyword">ref</span> shBuffB, shBuff, clr.z * fDiffSolid);</span><br><span class="line">                    sphericalHarmonicsAdd9(<span class="keyword">ref</span> resultB, resultB, shBuffB);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// final scale for coefficients</span></span><br><span class="line">        <span class="built_in">float</span> fNormProj = (<span class="number">4.0f</span> * Mathf.PI) / fWt;</span><br><span class="line">        sphericalHarmonicsScale9(<span class="keyword">ref</span> resultR, resultR, fNormProj);</span><br><span class="line">        sphericalHarmonicsScale9(<span class="keyword">ref</span> resultG, resultG, fNormProj);</span><br><span class="line">        sphericalHarmonicsScale9(<span class="keyword">ref</span> resultB, resultB, fNormProj);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// save result</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">uint</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            output[i].x = resultR[i];</span><br><span class="line">            output[i].y = resultG[i];</span><br><span class="line">            output[i].z = resultB[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Vector3 <span class="title">DecodeHDR</span>(<span class="params">Color clr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Vector3(clr.r, clr.g, clr.b) * clr.a;<span class="comment">// * Mathf.Pow(clr.a, 2);// * (Mathf.Pow(clr.a, 0.1f) * 1);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sphericalHarmonicsEvaluateDirection9</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">float</span>[] outsh, Vector3 dir</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 86 clocks</span></span><br><span class="line">        <span class="comment">// Make sure all constants are never computed at runtime</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">float</span> kInv2SqrtPI = <span class="number">0.28209479177387814347403972578039f</span>; <span class="comment">// 1 / (2*sqrt(kPI))</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">float</span> kSqrt3Div2SqrtPI = <span class="number">0.48860251190291992158638462283835f</span>; <span class="comment">// sqrt(3) / (2*sqrt(kPI))</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">float</span> kSqrt15Div2SqrtPI = <span class="number">1.0925484305920790705433857058027f</span>; <span class="comment">// sqrt(15) / (2*sqrt(kPI))</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">float</span> k3Sqrt5Div4SqrtPI = <span class="number">0.94617469575756001809268107088713f</span>; <span class="comment">// 3 * sqrtf(5) / (4*sqrt(kPI))</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">float</span> kSqrt15Div4SqrtPI = <span class="number">0.54627421529603953527169285290135f</span>; <span class="comment">// sqrt(15) / (4*sqrt(kPI))</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">float</span> kOneThird = <span class="number">0.3333333333333333333333f</span>; <span class="comment">// 1.0/3.0</span></span><br><span class="line">        outsh[<span class="number">0</span>] = kInv2SqrtPI;</span><br><span class="line">        outsh[<span class="number">1</span>] = -dir.y * kSqrt3Div2SqrtPI;</span><br><span class="line">        outsh[<span class="number">2</span>] = dir.z * kSqrt3Div2SqrtPI;</span><br><span class="line">        outsh[<span class="number">3</span>] = -dir.x * kSqrt3Div2SqrtPI;</span><br><span class="line">        outsh[<span class="number">4</span>] = dir.x * dir.y * kSqrt15Div2SqrtPI;</span><br><span class="line">        outsh[<span class="number">5</span>] = -dir.y * dir.z * kSqrt15Div2SqrtPI;</span><br><span class="line">        outsh[<span class="number">6</span>] = (dir.z * dir.z - kOneThird) * k3Sqrt5Div4SqrtPI;</span><br><span class="line">        outsh[<span class="number">7</span>] = -dir.x * dir.z * kSqrt15Div2SqrtPI;</span><br><span class="line">        outsh[<span class="number">8</span>] = (dir.x * dir.x - dir.y * dir.y) * kSqrt15Div4SqrtPI;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sphericalHarmonicsAdd9</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">float</span>[] result, <span class="built_in">float</span>[] inputA, <span class="built_in">float</span>[] inputB</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            result[i] = inputA[i] + inputB[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sphericalHarmonicsScale9</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">float</span>[] result, <span class="built_in">float</span>[] input, <span class="built_in">float</span> scale</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            result[i] = input[i] * scale;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">float</span> s_fSqrtPI = Mathf.Sqrt(Mathf.PI);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">float</span> fC0 = <span class="number">1.0f</span> / (<span class="number">2.0f</span> * s_fSqrtPI);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">float</span> fC1 = Mathf.Sqrt(<span class="number">3.0f</span>) / (<span class="number">3.0f</span> * s_fSqrtPI);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">float</span> fC2 = Mathf.Sqrt(<span class="number">15.0f</span>) / (<span class="number">8.0f</span> * s_fSqrtPI);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">float</span> fC3 = Mathf.Sqrt(<span class="number">5.0f</span>) / (<span class="number">16.0f</span> * s_fSqrtPI);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">float</span> fC4 = <span class="number">0.5f</span> * fC2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ConvertSHConstants</span>(<span class="params">Vector3[] sh, <span class="keyword">ref</span> Vector4[] SHArBrC</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> iC;</span><br><span class="line">        <span class="keyword">for</span> (iC = <span class="number">0</span>; iC &lt; <span class="number">3</span>; iC++)</span><br><span class="line">        &#123;</span><br><span class="line">            SHArBrC[iC].x = -fC1 * sh[<span class="number">3</span>][iC];</span><br><span class="line">            SHArBrC[iC].y = -fC1 * sh[<span class="number">1</span>][iC];</span><br><span class="line">            SHArBrC[iC].z = fC1 * sh[<span class="number">2</span>][iC];</span><br><span class="line">            SHArBrC[iC].w = fC0 * sh[<span class="number">0</span>][iC] - fC3 * sh[<span class="number">6</span>][iC];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (iC = <span class="number">0</span>; iC &lt; <span class="number">3</span>; iC++)</span><br><span class="line">        &#123;</span><br><span class="line">            SHArBrC[iC + <span class="number">3</span>].x = fC2 * sh[<span class="number">4</span>][iC];</span><br><span class="line">            SHArBrC[iC + <span class="number">3</span>].y = -fC2 * sh[<span class="number">5</span>][iC];</span><br><span class="line">            SHArBrC[iC + <span class="number">3</span>].z = <span class="number">3.0f</span> * fC3 * sh[<span class="number">6</span>][iC];</span><br><span class="line">            SHArBrC[iC + <span class="number">3</span>].w = -fC2 * sh[<span class="number">7</span>][iC];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SHArBrC[<span class="number">6</span>].x = fC4 * sh[<span class="number">8</span>][<span class="number">0</span>];</span><br><span class="line">        SHArBrC[<span class="number">6</span>].y = fC4 * sh[<span class="number">8</span>][<span class="number">1</span>];</span><br><span class="line">        SHArBrC[<span class="number">6</span>].z = fC4 * sh[<span class="number">8</span>][<span class="number">2</span>];</span><br><span class="line">        SHArBrC[<span class="number">6</span>].w = <span class="number">1.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CubemapSHProjector"><a href="#CubemapSHProjector" class="headerlink" title="CubemapSHProjector"></a>CubemapSHProjector</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CubemapSHProjector</span> : <span class="title">EditorWindow</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//PUBLIC FIELDS</span></span><br><span class="line">    <span class="keyword">public</span> Texture envMap;</span><br><span class="line">    <span class="keyword">public</span> Transform go;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//PRIVATE FIELDS</span></span><br><span class="line">    <span class="keyword">private</span> Material    view_mat;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span>       view_mode;</span><br><span class="line">    <span class="keyword">private</span> Vector4[]   coefficients;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SerializedObject so;</span><br><span class="line">    <span class="keyword">private</span> SerializedProperty sp_input_cubemap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Texture2D tmp = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CheckAndConvertEnvMap</span>(<span class="params"><span class="keyword">ref</span> Texture envMap, <span class="keyword">ref</span> Vector4[] sh_out</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!envMap) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> map_path = AssetDatabase.GetAssetPath(envMap);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(map_path)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        TextureImporter ti = AssetImporter.GetAtPath(map_path) <span class="keyword">as</span> TextureImporter;</span><br><span class="line">        <span class="keyword">if</span> (!ti) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">bool</span> read_able = ti.isReadable;</span><br><span class="line">        <span class="built_in">bool</span> need_reimport = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ti.textureShape != TextureImporterShape.TextureCube)</span><br><span class="line">        &#123;</span><br><span class="line">            ti.textureShape = TextureImporterShape.TextureCube;</span><br><span class="line">            need_reimport = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ti.mipmapEnabled)</span><br><span class="line">        &#123;</span><br><span class="line">            ti.mipmapEnabled = <span class="literal">true</span>;</span><br><span class="line">            need_reimport = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ti.sRGBTexture)</span><br><span class="line">        &#123;</span><br><span class="line">            ti.sRGBTexture = <span class="literal">true</span>;</span><br><span class="line">            need_reimport = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ti.filterMode != FilterMode.Trilinear)</span><br><span class="line">        &#123;</span><br><span class="line">            ti.filterMode = FilterMode.Trilinear;</span><br><span class="line">            need_reimport = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TextureImporterSettings tis = <span class="keyword">new</span> TextureImporterSettings();</span><br><span class="line">        ti.ReadTextureSettings(tis);</span><br><span class="line">        <span class="keyword">if</span> (tis.cubemapConvolution != TextureImporterCubemapConvolution.Specular)</span><br><span class="line">        &#123;</span><br><span class="line">            tis.cubemapConvolution = TextureImporterCubemapConvolution.Specular;</span><br><span class="line">            ti.SetTextureSettings(tis);</span><br><span class="line">            need_reimport = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if (ti.GetDefaultPlatformTextureSettings().maxTextureSize != 128)</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="comment">//    TextureImporterPlatformSettings tips = new TextureImporterPlatformSettings();</span></span><br><span class="line">        <span class="comment">//    tips.maxTextureSize = 128;</span></span><br><span class="line">        <span class="comment">//    ti.SetPlatformTextureSettings(tips);</span></span><br><span class="line">        <span class="comment">//    ti.maxTextureSize = 128;</span></span><br><span class="line">        <span class="comment">//    need_reimport = true;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!read_able)</span><br><span class="line">        &#123;</span><br><span class="line">            ti.isReadable = <span class="literal">true</span>;</span><br><span class="line">            need_reimport = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (need_reimport)</span><br><span class="line">        &#123;</span><br><span class="line">            ti.SaveAndReimport();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        envMap = AssetDatabase.LoadAssetAtPath&lt;Texture&gt;(map_path);</span><br><span class="line">        <span class="keyword">if</span> (!envMap) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        Vector3[] sh = <span class="keyword">new</span> Vector3[<span class="number">9</span>];</span><br><span class="line">        SphericalHarmonicsCoefficient.sphericalHarmonicsFromCubemap9((Cubemap)envMap, <span class="keyword">ref</span> sh);</span><br><span class="line">        SphericalHarmonicsCoefficient.ConvertSHConstants(sh, <span class="keyword">ref</span> sh_out);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ti.isReadable != read_able)</span><br><span class="line">        &#123;</span><br><span class="line">            ti.isReadable = read_able;</span><br><span class="line">            ti.SaveAndReimport();</span><br><span class="line">            envMap = AssetDatabase.LoadAssetAtPath&lt;Texture&gt;(map_path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">MenuItem(<span class="string">&quot;美术/SH系数生成&quot;</span>, false, 2100)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Init</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CubemapSHProjector window = (CubemapSHProjector)EditorWindow.GetWindow(<span class="keyword">typeof</span>(CubemapSHProjector));</span><br><span class="line">        window.Show();</span><br><span class="line">        window.titleContent = <span class="keyword">new</span> GUIContent(<span class="string">&quot;SH生成器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnFocus</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Initialize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Initialize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Initialize</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        so = <span class="keyword">new</span> SerializedObject(<span class="keyword">this</span>);</span><br><span class="line">        sp_input_cubemap = so.FindProperty(<span class="string">&quot;input_cubemap&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGUI</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        EditorGUI.BeginChangeCheck();</span><br><span class="line">        envMap = EditorGUILayout.ObjectField(<span class="string">&quot;环境图&quot;</span>, envMap, <span class="keyword">typeof</span>(Texture), <span class="literal">false</span>) <span class="keyword">as</span> Texture;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (envMap != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            EditorGUILayout.Space();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (GUILayout.Button(<span class="string">&quot;Calc&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (envMap != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    coefficients = <span class="keyword">new</span> Vector4[<span class="number">7</span>];</span><br><span class="line">                    CheckAndConvertEnvMap(<span class="keyword">ref</span> envMap, <span class="keyword">ref</span> coefficients);</span><br><span class="line">                &#125;</span><br><span class="line">                SceneView.RepaintAll();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            EditorGUILayout.Space();</span><br><span class="line"></span><br><span class="line">            go = EditorGUILayout.ObjectField(<span class="string">&quot;Obj&quot;</span>, go, <span class="keyword">typeof</span>(Transform), <span class="literal">true</span>) <span class="keyword">as</span> Transform;</span><br><span class="line">            <span class="keyword">if</span> (go != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (GUILayout.Button(<span class="string">&quot;Apply&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    List&lt;Material&gt; mat_list = <span class="keyword">new</span> List&lt;Material&gt;();</span><br><span class="line">                    <span class="keyword">var</span> renders = go.GetComponentsInChildren&lt;Renderer&gt;();</span><br><span class="line">                    <span class="keyword">foreach</span> (<span class="keyword">var</span> render <span class="keyword">in</span> renders)</span><br><span class="line">                    &#123;</span><br><span class="line">                        mat_list.AddRange(render.sharedMaterials);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">foreach</span> (<span class="keyword">var</span> mat <span class="keyword">in</span> mat_list)</span><br><span class="line">                    &#123;</span><br><span class="line">                        mat.SetVector(<span class="string">&quot;custom_SHAr&quot;</span>, coefficients[<span class="number">0</span>]);</span><br><span class="line">                        mat.SetVector(<span class="string">&quot;custom_SHAg&quot;</span>, coefficients[<span class="number">1</span>]);</span><br><span class="line">                        mat.SetVector(<span class="string">&quot;custom_SHAb&quot;</span>, coefficients[<span class="number">2</span>]);</span><br><span class="line">                        mat.SetVector(<span class="string">&quot;custom_SHBr&quot;</span>, coefficients[<span class="number">3</span>]);</span><br><span class="line">                        mat.SetVector(<span class="string">&quot;custom_SHBg&quot;</span>, coefficients[<span class="number">4</span>]);</span><br><span class="line">                        mat.SetVector(<span class="string">&quot;custom_SHBb&quot;</span>, coefficients[<span class="number">5</span>]);</span><br><span class="line">                        mat.SetVector(<span class="string">&quot;custom_SHC&quot;</span>, coefficients[<span class="number">6</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mat_list.Clear();</span><br><span class="line">                    SceneView.RepaintAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            EditorGUILayout.Space();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//print the 9 coefficients</span></span><br><span class="line">            <span class="keyword">if</span> (coefficients != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                EditorGUILayout.LabelField(<span class="string">&quot;custom_SHAr&quot;</span> + <span class="string">&quot;: &quot;</span> + coefficients[<span class="number">0</span>].ToString(<span class="string">&quot;F4&quot;</span>));</span><br><span class="line">                EditorGUILayout.LabelField(<span class="string">&quot;custom_SHAg&quot;</span> + <span class="string">&quot;: &quot;</span> + coefficients[<span class="number">1</span>].ToString(<span class="string">&quot;F4&quot;</span>));</span><br><span class="line">                EditorGUILayout.LabelField(<span class="string">&quot;custom_SHAb&quot;</span> + <span class="string">&quot;: &quot;</span> + coefficients[<span class="number">2</span>].ToString(<span class="string">&quot;F4&quot;</span>));</span><br><span class="line">                EditorGUILayout.LabelField(<span class="string">&quot;custom_SHBr&quot;</span> + <span class="string">&quot;: &quot;</span> + coefficients[<span class="number">3</span>].ToString(<span class="string">&quot;F4&quot;</span>));</span><br><span class="line">                EditorGUILayout.LabelField(<span class="string">&quot;custom_SHBg&quot;</span> + <span class="string">&quot;: &quot;</span> + coefficients[<span class="number">4</span>].ToString(<span class="string">&quot;F4&quot;</span>));</span><br><span class="line">                EditorGUILayout.LabelField(<span class="string">&quot;custom_SHBb&quot;</span> + <span class="string">&quot;: &quot;</span> + coefficients[<span class="number">5</span>].ToString(<span class="string">&quot;F4&quot;</span>));</span><br><span class="line">                EditorGUILayout.LabelField(<span class="string">&quot;custom_SHC&quot;</span> + <span class="string">&quot;: &quot;</span> + coefficients[<span class="number">6</span>].ToString(<span class="string">&quot;F4&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        EditorGUILayout.Space();</span><br><span class="line">        <span class="keyword">if</span> (tmp != <span class="literal">null</span>)</span><br><span class="line">            GUILayout.Label(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Unity内置函数"><a href="#Unity内置函数" class="headerlink" title="Unity内置函数"></a>Unity内置函数</h2><p>换上小皮肤</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Tags&#123;<span class="string">&quot;LightMode&quot;</span>=<span class="string">&quot;ForwardBase&quot;</span>&#125;</span><br><span class="line">CGPROGRAM</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdbase</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AutoLight.cginc&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>片元</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">half3 env_color = <span class="built_in">ShadeSH9</span>(<span class="built_in">float4</span>(normal_dir,<span class="number">1.0</span>));</span><br></pre></td></tr></table></figure>

<p>完成</p>
<h2 id="光照探测器"><a href="#光照探测器" class="headerlink" title="光照探测器"></a>光照探测器</h2><p>光照探测器的小球记录下问题的球谐数值，然后物体在范围内时，用物体周围小球的球谐数值做插值。</p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
</search>
