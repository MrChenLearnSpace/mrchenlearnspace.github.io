<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>搭建博客</title>
    <url>/2021/11/01/Hollow/</url>
    <content><![CDATA[<h1 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h1><p>文档格式<br><strong>需要git，Node.js，npm</strong></p>
<h2 id="做好准备"><a href="#做好准备" class="headerlink" title="做好准备"></a>做好准备</h2><p>安装好软件，配置好相关的环境</p>
<p>建立一个github仓库，由于在部署时未设置配置建议改成 用户名.github.io,方便网站进入导致只打开一个html，与整个页面脱节的情况</p>
<h2 id="寻找材料"><a href="#寻找材料" class="headerlink" title="寻找材料"></a>寻找材料</h2><p>到Hexo中找相关喜欢的主题，并找到相应的开源的GitHub，先hexo init在空文件夹中初始化，导入相关主题，修改全局中的theme变量</p>
<h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p><a href="https://hexo.io/zh-cn/docs/configuration">https://hexo.io/zh-cn/docs/configuration</a><br>具体配置连接</p>
<p><strong>网站</strong></p>
<p>参数  ||    描述</p>
<p>title ||    网站标题</p>
<p>subtitle ||    网站副标题</p>
<p>description ||    网站描述</p>
<p>keywords ||    网站的关键词。支持多个关键词。</p>
<p>author ||    您的名字</p>
<p>language  ||    网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 zh-Hans和 zh-CN。</p>
<p>timezone ||    网站时区。Hexo 默认使用您电脑的时区。请参考 时区列表 进行设置，如 America/New_York, Japan, 和 UTC 。一般的，对于中国大陆地区可以使用 Asia/Shanghai。</p>
<p><strong>网址</strong></p>
<p>url    || 网址, 必须以 http:// 或 https:// 开头    </p>
<p>root ||    网站根目录    url’s pathname</p>
<p>permalink ||    文章的 永久链接 格式    :year/:month/:day/:title/</p>
<p>permalink_defaults ||     永久链接中各部分的默认值    </p>
<p>pretty_urls ||    改写 permalink 的值来美化 URL    </p>
<p>pretty_urls.trailing_index ||    是否在永久链接中保留尾部的index.html，设置为 false 时去除    true</p>
<p>pretty_urls.trailing_html    是否在永久链接中保留尾部的 .html, 设置为 false 时去除 (对尾部的 index.html无效)</p>
<p><em>网站存放在子目录<br>如果您的网站存放在子目录中，例如 <a href="http://example.com/blog%EF%BC%8C%E5%88%99%E8%AF%B7%E5%B0%86%E6%82%A8%E7%9A%84">http://example.com/blog，则请将您的</a> url 设为 <a href="http://example.com/blog">http://example.com/blog</a> 并把 root 设为 /blog/。</em><br><em>例如：# 比如，一个页面的永久链接是 <a href="http://example.com/foo/bar/index.html">http://example.com/foo/bar/index.html</a><br>pretty_urls:<br>  trailing_index: false<br>此时页面的永久链接会变为 <a href="http://example.com/foo/bar/">http://example.com/foo/bar/</a></em></p>
<p><strong>目录</strong><br>参数  ||    描述  ||    默认值</p>
<p>source_dir ||    资源文件夹，这个文件夹用来存放内容。||    source</p>
<p>public_dir ||    公共文件夹，这个文件夹用于存放生成的站点文件。||    public</p>
<p>tag_dir  ||    标签文件夹 ||    tags</p>
<p>archive_dir    归档文件夹    archives</p>
<p>category_dir    分类文件夹    categories</p>
<p>code_dir    Include code 文件夹，source_dir 下的子目录    downloads/code</p>
<p>i18n_dir    国际化（i18n）文件夹    :lang</p>
<p>skip_render    跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 public 目录中。您可使用 glob 表达式来匹配路径。</p>
<p><strong>文章</strong><br>参数    描述    默认值</p>
<p>new_post_name    新文章的文件名称    :title.md</p>
<p>default_layout    预设布局    post</p>
<p>auto_spacing    在中文和英文之间加入空格    false</p>
<p>titlecase    把标题转换为 title case    false</p>
<p>external_link    在新标签中打开链接    true</p>
<p>external_link.enable    在新标签中打开链接    true</p>
<p>external_link.field    对整个网站（site）生效或仅对文章（post）生效    site</p>
<p>external_link.exclude    需要排除的域名。主域名和子域名如 www 需分别配置    []</p>
<p>filename_case    把文件名称转换为 (1) 小写或 (2) 大写    0</p>
<p>render_drafts    显示草稿    false</p>
<p>post_asset_folder    启动 Asset 文件夹    false</p>
<p>relative_link    把链接改为与根目录的相对位址    false</p>
<p>future    显示未来的文章    true</p>
<p>highlight    代码块的设置, 请参考 Highlight.js 进行设置    </p>
<p>prismjs    代码块的设置, 请参考 PrismJS 进行设置</p>
<p><em>默认情况下，Hexo 生成的超链接都是绝对地址。例如，如果您的网站域名为 example.com,您有一篇文章名为 hello，那么绝对链接可能像这样：<a href="http://example.com/hello.html%EF%BC%8C%E5%AE%83%E6%98%AF%E7%BB%9D%E5%AF%B9%E4%BA%8E%E5%9F%9F%E5%90%8D%E7%9A%84%E3%80%82%E7%9B%B8%E5%AF%B9%E9%93%BE%E6%8E%A5%E5%83%8F%E8%BF%99%E6%A0%B7%EF%BC%9A/hello.html%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%EF%BC%8C%E6%97%A0%E8%AE%BA%E7%94%A8%E4%BB%80%E4%B9%88%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE%E8%AF%A5%E7%AB%99%E7%82%B9%EF%BC%8C%E9%83%BD%E6%B2%A1%E6%9C%89%E5%85%B3%E7%B3%BB%EF%BC%8C%E8%BF%99%E5%9C%A8%E8%BF%9B%E8%A1%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%97%B6%E5%8F%AF%E8%83%BD%E7%94%A8%E5%88%B0%E3%80%82%E9%80%9A%E5%B8%B8%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E7%BB%9D%E5%AF%B9%E5%9C%B0%E5%9D%80%E3%80%82">http://example.com/hello.html，它是绝对于域名的。相对链接像这样：/hello.html，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。</a></em></p>
<p><strong>分类 &amp; 标签</strong></p>
<p>参数    描述    默认值</p>
<p>default_category    默认分类    uncategorized</p>
<p>category_map    分类别名    </p>
<p>tag_map    标签别名    </p>
<p><strong>日期 / 时间格式</strong></p>
<p>参数    描述    默认值</p>
<p>date_format    日期格式    YYYY-MM-DD</p>
<p>time_format    时间格式    HH:mm:ss</p>
<p>updated_option    当 Front Matter 中没有指定 updated 时 updated 的取值    mtime</p>
<p>updated_option<br><em>updated_option 控制了当 Front Matter 中没有指定 updated 时，updated 如何取值：</em></p>
<p><em>mtime: 使用文件的最后修改时间。这是从 Hexo 3.0.0 开始的默认行为。</em><br><em>date: 使用 date 作为 updated 的值。可被用于 Git 工作流之中，因为使用 Git 管理站点时，文件的最后修改日期常常会发生改变</em><br><em>empty: 直接删除 updated。使用这一选项可能会导致大部分主题和插件无法正常工作。</em><br><em>use_date_for_updated 选项已经被废弃，将会在下个重大版本发布时去除。请改为使用 updated_option: ‘date’。</em></p>
<p><em>use_date_for_updated | 启用以后，如果 Front Matter 中没有指定 updated， post.updated 将会使用 date 的值而不是文件的创建时间。在 Git 工作流中这个选项会很有用 | true</em></p>
<p><strong>分页</strong></p>
<p>参数    描述    默认值</p>
<p>per_page    每页显示的文章量 (0 = 关闭分页功能)    10</p>
<p>pagination_dir    分页目录    page</p>
<p><strong>扩展</strong><br>参数    描述</p>
<p>theme    当前主题名称。值为false时禁用主题</p>
<p>theme_config    主题的配置文件。在这里放置的配置会覆盖主题目录下的 _config.yml 中的配置</p>
<p>deploy    部署部分的设置</p>
<p>meta_generator    Meta generator 标签。 值为 false 时 Hexo 不会在头部插入该标签</p>
<ul>
<li>*<h3 id="特别注意，记得修改配置中的连接和主题"><a href="#特别注意，记得修改配置中的连接和主题" class="headerlink" title="特别注意，记得修改配置中的连接和主题"></a>特别注意，记得修改配置中的连接和主题</h3></li>
<li>*</li>
</ul>
<h2 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h2><p>配置好配置中的部署部分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/MrChenLreanSpace/MrChenLreanSpace.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure>
<p>用 npm 安装好hexo-deployer-git.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git </span><br></pre></td></tr></table></figure>
<p>有些加入搜索功能，需要插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>配置hexo全局配置文件（请将生成的索引文件放在网站根目录或修改主题js文件的path值）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>
<p>在主题配置文件启用本地搜索</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#本地搜索,请将索引文件放在网站根目录</span><br><span class="line">local_search:</span><br><span class="line">    #是否启用</span><br><span class="line">    enable: true</span><br></pre></td></tr></table></figure>
<p>开始生成本地站点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<p>本地测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s 或者 hexo serve</span><br></pre></td></tr></table></figure>
<p>完成之后，连上github，需要GitHub的令牌，令牌生成后记得记住密钥，之后会看不到<br>令牌在设置的开发者选项中第三个第一次上传需要登入和用用户名和令牌连上账户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean&amp;&amp;hexo d</span><br></pre></td></tr></table></figure>
<p>清除本地文件且部署到GitHub上</p>
]]></content>
      <categories>
        <category>博客开始</category>
      </categories>
      <tags>
        <tag>标签和分类可以多个</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL学习之路之窗口的建立</title>
    <url>/2021/11/02/OpenGL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E7%AA%97%E5%8F%A3%E7%9A%84%E5%BB%BA%E7%AB%8B/</url>
    <content><![CDATA[<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>先建立一个空项目，建立一个c++文件，然后设置解决方案的属性设置三个位置<br><strong>第一是c&#x2F;c++\常规\附加包含目录加入include的文件夹，glfw和glew都需要，第二，链接器\常规\附加库目录，lib文件夹，第三，链接器\输入\附加依赖库，opengl32.lib glfw3.lib glew32s.lib</strong></p>
<h1 id="创建自己的引擎"><a href="#创建自己的引擎" class="headerlink" title="创建自己的引擎"></a>创建自己的引擎</h1><p>将文件修改为main作为主函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GLEW_STATIC</span></span><br></pre></td></tr></table></figure>
<p>这个注意小心拼写错误，本人搞了几小时</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="声明版本号"><a href="#声明版本号" class="headerlink" title="声明版本号"></a>声明版本号</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glfwInit</span>();</span><br><span class="line">  <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span><br></pre></td></tr></table></figure>
<p>MacOSX系统加上这一句<br>以上是初始化Glfw，说明我们要使用的OPENGL版本是3.3，我们同样明确告诉GLFW我们使用的是核心模式(Core-profile)。明确告诉GLFW我们需要使用核心模式意味着我们只能使用OpenGL功能的一个子集。</p>
<h3 id="创建窗口指针"><a href="#创建窗口指针" class="headerlink" title="创建窗口指针"></a>创建窗口指针</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;LearnOPENGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//前两个参数代表生成窗口大小</span></span><br></pre></td></tr></table></figure>
<h3 id="接下来进行GLFW的初始化"><a href="#接下来进行GLFW的初始化" class="headerlink" title="接下来进行GLFW的初始化"></a>接下来进行GLFW的初始化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;GLFW窗口初始化失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();<span class="comment">//程序终止函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(window);</span><br></pre></td></tr></table></figure>
<h3 id="然后是GLEW的初始化"><a href="#然后是GLEW的初始化" class="headerlink" title="然后是GLEW的初始化"></a>然后是GLEW的初始化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">glewExperimental = GL_TRUE;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;GLEW初始化失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="确定渲染窗口"><a href="#确定渲染窗口" class="headerlink" title="确定渲染窗口"></a>确定渲染窗口</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>);<span class="comment">//渲染窗口大小</span></span><br><span class="line"><span class="built_in">glfwSetFramebufferSizeCallback</span>(window,framebuffer_size_callback);<span class="comment">//注册函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>framebuffer_size_callback自定义函数注册到当窗口大小改变的事件中能及时反映</p>
<h3 id="确定基本架构"><a href="#确定基本架构" class="headerlink" title="确定基本架构"></a>确定基本架构</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(!<span class="built_in">glfwWindowShouldClose</span>(window))&#123;</span><br><span class="line">    <span class="comment">//输入</span></span><br><span class="line">    <span class="comment">//渲染指令</span></span><br><span class="line">    <span class="comment">//检查并调用事件，交换缓冲</span></span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);<span class="comment">//进行屏幕缓冲</span></span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();<span class="comment">//检查函数有没有触发事件	</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="清理缓冲区颜色"><a href="#清理缓冲区颜色" class="headerlink" title="清理缓冲区颜色"></a>清理缓冲区颜色</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);<span class="comment">//来设置清空屏幕所用的颜色,表示清除板的颜色</span></span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);<span class="comment">//清除颜色缓冲之后</span></span><br></pre></td></tr></table></figure>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">processInput</span>(window)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//输入</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) &#123;</span><br><span class="line">    <span class="built_in">glfwSetWindowShouldClose</span>(window, GLFW_TRUE);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GLEW_STATIC</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">glfwInit</span>();</span><br><span class="line">  <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line">  <span class="comment">//glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);MacOSX系统加上这一句</span></span><br><span class="line">  <span class="comment">//以上是初始化Glfw，说明我们要使用的OPENGL版本是3.3，我们同样明确告诉GLFW我们使用的是核心模式(Core-profile)。明确告诉GLFW我们需要使用核心模式意味着我们只能使用OpenGL功能的一个子集。</span></span><br><span class="line"></span><br><span class="line">  GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;LearnOPENGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//前两个参数代表生成窗口大小</span></span><br><span class="line">  <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;GLFW窗口初始化失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();<span class="comment">//程序终止函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">  <span class="comment">//GLFW初始化</span></span><br><span class="line">  glewExperimental = GL_TRUE;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;GLEW初始化失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//Glew的初始化</span></span><br><span class="line">  <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>);<span class="comment">//渲染窗口大小</span></span><br><span class="line">  <span class="built_in">glfwSetFramebufferSizeCallback</span>(window,framebuffer_size_callback);<span class="comment">//注册函数</span></span><br><span class="line">  <span class="keyword">while</span>(!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//输入</span></span><br><span class="line">    <span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//渲染指令</span></span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);<span class="comment">//来设置清空屏幕所用的颜色,表示清除板的颜色</span></span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);<span class="comment">//清除颜色缓冲之后</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查并调用事件，交换缓冲</span></span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);<span class="comment">//进行屏幕缓冲</span></span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();<span class="comment">//检查函数有没有触发事件</span></span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">glfwTerminate</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//输入</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) &#123;</span><br><span class="line">    <span class="built_in">glfwSetWindowShouldClose</span>(window, GLFW_TRUE);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL学习之路之三角形绘制</title>
    <url>/2021/11/02/OpenGL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E4%B8%89%E8%A7%92%E5%BD%A2%E7%BB%98%E5%88%B6/</url>
    <content><![CDATA[<p><strong>先从几何阶段取出顶点转换成vbo转到vao如果有重复顶点可以转到EBo<br>openGL是一个状态机只能运行context的状态只能放一个vao<br>状态机中必须要一个vao</strong></p>
<h3 id="VAO"><a href="#VAO" class="headerlink" title="VAO"></a>VAO</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> VAO;</span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);<span class="comment">//注意</span></span><br></pre></td></tr></table></figure>
<h3 id="VBO"><a href="#VBO" class="headerlink" title="VBO"></a>VBO</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> VBO;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);<span class="comment">//一个缓冲ID生成一个VBO对象建立顶点缓冲对象</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);<span class="comment">//新创建的缓冲绑定到GL_ARRAY_BUFFER目标</span></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);<span class="comment">//它会把之前定义的顶点数据复制到缓冲的内存中</span></span><br></pre></td></tr></table></figure>
<p>一定要绑定顶点数组</p>
<h3 id="shader"><a href="#shader" class="headerlink" title="shader"></a>shader</h3><p>顶点着色器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> vertexShader;</span><br><span class="line">vertexShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);<span class="comment">//由于我们正在创建一个顶点着色器，传递的参数是GL_VERTEX_SHADER</span></span><br><span class="line"><span class="built_in">glShaderSource</span>(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);<span class="comment">//这个着色器源码附加到着色器对象上</span></span><br><span class="line"><span class="built_in">glCompileShader</span>(vertexShader);<span class="comment">//编译着色器</span></span><br></pre></td></tr></table></figure>
<p>片段着色器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> fragmentShader;</span><br><span class="line">fragmentShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line"><span class="built_in">glShaderSource</span>(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glCompileShader</span>(fragmentShader);</span><br></pre></td></tr></table></figure>
<p>着色器程序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> shaderProgram;</span><br><span class="line">shaderProgram = <span class="built_in">glCreateProgram</span>();<span class="comment">//建立着色器程序对象</span></span><br><span class="line"><span class="built_in">glAttachShader</span>(shaderProgram, vertexShader);</span><br><span class="line"><span class="built_in">glAttachShader</span>(shaderProgram, fragmentShader);<span class="comment">//附加着色器</span></span><br><span class="line"><span class="built_in">glLinkProgram</span>(shaderProgram);<span class="comment">//连接着色器</span></span><br><span class="line"><span class="built_in">glDeleteShader</span>(vertexShader);<span class="comment">//着色器对象链接到程序对象以后，记得删除着色器对象，我们不再需要它们了</span></span><br><span class="line"><span class="built_in">glDeleteShader</span>(fragmentShader);</span><br></pre></td></tr></table></figure>
<p>序列化数据，可以得到数据的属性，是uv图片还是顶点信息</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>


<p>EBO的使用<br>需要加人索引<br>unsigned int indices[] &#x3D; { &#x2F;&#x2F; 注意索引从0开始!<br>    0, 1, 3, &#x2F;&#x2F; 第一个三角形<br>    1, 2, 3  &#x2F;&#x2F; 第二个三角形<br>};来确定三角形<br>放发与VBO类似当有点点区别<br>绑定缓存时GL_ELEMENT_ARRAY_BUFFER，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br></pre></td></tr></table></figure>
<p>绑定缓存数据的是索引值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure>
<p>在具体绘画过程中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);<span class="comment">//这是vao没有的</span></span><br></pre></td></tr></table></figure>
<p>用的函数也是和VAO绘制有区别的<br>三角形不用EBO的代码</p>
<p>四边形代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GLEW_STATIC</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CheckCompileShaderSuccess</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> vertexShader)</span></span>;<span class="comment">//检查着色器是否编译成功</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CheckLinkShaderSuccess</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> shaderProgram)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//float vertices[] = &#123;</span></span><br><span class="line"><span class="comment">//  -0.5f, -0.5f, 0.0f,</span></span><br><span class="line"><span class="comment">//   0.5f, -0.5f, 0.0f,</span></span><br><span class="line"><span class="comment">//   0.0f,  0.5f, 0.0f</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">  <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右上角</span></span><br><span class="line">  <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">  <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下角</span></span><br><span class="line">  <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// 左上角</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> indices[] = &#123; <span class="comment">// 注意索引从0开始! </span></span><br><span class="line">  <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="comment">// 第一个三角形</span></span><br><span class="line">  <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment">// 第二个三角形</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* vertexShaderSource =</span><br><span class="line"><span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="string">&quot;layout(location = 0) in vec3 aPos;\n&quot;</span></span><br><span class="line"><span class="string">&quot;void main()&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);&#125;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* fragmentShaderSource =</span><br><span class="line"><span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="string">&quot;out vec4 FragColor;\n;&quot;</span></span><br><span class="line"><span class="string">&quot;void main()&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;    FragColor=vec4(1.0f,0.5f,0.2f,1.0f);&#125;\n&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">glfwInit</span>();</span><br><span class="line">  <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line">  <span class="comment">//glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);MacOSX系统加上这一句</span></span><br><span class="line">  <span class="comment">//以上是初始化Glfw，说明我们要使用的OPENGL版本是3.3，我们同样明确告诉GLFW我们使用的是核心模式(Core-profile)。明确告诉GLFW我们需要使用核心模式意味着我们只能使用OpenGL功能的一个子集。</span></span><br><span class="line"></span><br><span class="line">  GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;LearnOPENGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//前两个参数代表生成窗口大小</span></span><br><span class="line">  <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;GLFW窗口初始化失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();<span class="comment">//程序终止函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">  <span class="comment">//GLFW初始化</span></span><br><span class="line">  glewExperimental = GL_TRUE;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;GLEW初始化失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//Glew的初始化</span></span><br><span class="line">  <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>);<span class="comment">//渲染窗口大小</span></span><br><span class="line">  <span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);<span class="comment">//注册函数</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> VAO;</span><br><span class="line">  <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">  <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">  <span class="comment">//顶点数据绑定</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> VBO;</span><br><span class="line">  <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);<span class="comment">//一个缓冲ID生成一个VBO对象建立顶点缓冲对象</span></span><br><span class="line">  <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);<span class="comment">//新创建的缓冲绑定到GL_ARRAY_BUFFER目标</span></span><br><span class="line">  <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);<span class="comment">//它会把之前定义的顶点数据复制到缓冲的内存中</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">unsigned</span> EBO;</span><br><span class="line">  <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;EBO);</span><br><span class="line">  <span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">  <span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//顶点着色器</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> vertexShader;</span><br><span class="line">  vertexShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);<span class="comment">//由于我们正在创建一个顶点着色器，传递的参数是GL_VERTEX_SHADER</span></span><br><span class="line">  <span class="built_in">glShaderSource</span>(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);<span class="comment">//这个着色器源码附加到着色器对象上</span></span><br><span class="line">  <span class="built_in">glCompileShader</span>(vertexShader);<span class="comment">//编译着色器</span></span><br><span class="line">  <span class="built_in">CheckCompileShaderSuccess</span>(vertexShader);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//片段着色器</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> fragmentShader;</span><br><span class="line">  fragmentShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line">  <span class="built_in">glShaderSource</span>(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">glCompileShader</span>(fragmentShader);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//着色器程序</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> shaderProgram;</span><br><span class="line">  shaderProgram = <span class="built_in">glCreateProgram</span>();<span class="comment">//建立着色器程序对象</span></span><br><span class="line">  <span class="built_in">glAttachShader</span>(shaderProgram, vertexShader);</span><br><span class="line">  <span class="built_in">glAttachShader</span>(shaderProgram, fragmentShader);<span class="comment">//附加着色器</span></span><br><span class="line">  <span class="built_in">glLinkProgram</span>(shaderProgram);<span class="comment">//连接着色器</span></span><br><span class="line">  <span class="built_in">CheckLinkShaderSuccess</span>(shaderProgram);</span><br><span class="line">  <span class="built_in">glDeleteShader</span>(vertexShader);<span class="comment">//着色器对象链接到程序对象以后，记得删除着色器对象，我们不再需要它们了</span></span><br><span class="line">  <span class="built_in">glDeleteShader</span>(fragmentShader);</span><br><span class="line">  <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//输入</span></span><br><span class="line">    <span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//渲染指令</span></span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);<span class="comment">//来设置清空屏幕所用的颜色,表示清除板的颜色</span></span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);<span class="comment">//清除颜色缓冲之后</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">glUseProgram</span>(shaderProgram);<span class="comment">//调用着色器</span></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">    <span class="comment">//glDrawArrays(GL_TRIANGLES, 0, 3);</span></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(EBO);</span><br><span class="line">    <span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);<span class="comment">//这是vao没有的</span></span><br><span class="line">    <span class="comment">//检查并调用事件，交换缓冲</span></span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);<span class="comment">//进行屏幕缓冲</span></span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();<span class="comment">//检查函数有没有触发事件</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">glfwTerminate</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//输入</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) &#123;</span><br><span class="line">    <span class="built_in">glfwSetWindowShouldClose</span>(window, GLFW_TRUE);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CheckCompileShaderSuccess</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> vertexShader)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//检查着色器是否编译成功</span></span><br><span class="line">  <span class="type">int</span> success;</span><br><span class="line">  <span class="type">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">  <span class="built_in">glGetShaderiv</span>(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">  <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">    <span class="built_in">glGetShaderInfoLog</span>(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CheckLinkShaderSuccess</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> shaderProgram)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//检查shaderProgram连接成功</span></span><br><span class="line">  <span class="type">int</span> success;</span><br><span class="line">  <span class="type">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">  <span class="built_in">glGetProgramiv</span>(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line">  <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">    <span class="built_in">glGetProgramInfoLog</span>(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::Program::Link_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/11/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>全景图传输</title>
    <url>/2022/03/21/%E5%85%A8%E6%99%AF%E5%9B%BE%E4%BC%A0%E8%BE%93/</url>
    <content><![CDATA[<h1 id="全景图"><a href="#全景图" class="headerlink" title="全景图"></a>全景图</h1><h2 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h2><h3 id="将全景图转变为Byte数组"><a href="#将全景图转变为Byte数组" class="headerlink" title="将全景图转变为Byte数组"></a>将全景图转变为Byte数组</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Camera.main.RenderToCubemap(cm);</span><br><span class="line">texture2D = <span class="keyword">new</span> Texture2D(width, hight);</span><br><span class="line">texture2D.SetPixels(cm.GetPixels(CubemapFace.NegativeZ));</span><br><span class="line">texture2D.Apply();</span><br><span class="line">byt = texture2D.EncodeToPNG();</span><br></pre></td></tr></table></figure>

<h3 id="将Byte数组变成全景图"><a href="#将Byte数组变成全景图" class="headerlink" title="将Byte数组变成全景图"></a>将Byte数组变成全景图</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">texture2DFix.LoadImage(byt);</span><br><span class="line">texture2DFix.Apply</span><br><span class="line">cm1.SetPixels(texture2DFix.GetPixels(), CubemapFace.PositiveZ);</span><br><span class="line">cm1.Apply();</span><br></pre></td></tr></table></figure>

<h3 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a>网络传输</h3><p>名字设为 I P 地址名</p>
<p>1.发送连接信号并在服务器创建位置</p>
<h3 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; width + <span class="number">1</span>; i++) Array.Copy(cmmcolors, width * (width - i), ReCmmcolors, width * (i - <span class="number">1</span>), width);<span class="comment">//上下翻转</span></span><br></pre></td></tr></table></figure>

<h3 id="协议处理"><a href="#协议处理" class="headerlink" title="协议处理"></a>协议处理</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">print(point.Right.Length);</span><br><span class="line">      <span class="built_in">string</span> str = pos.x.ToString() + <span class="string">&quot; &quot;</span> + pos.y.ToString() + <span class="string">&quot; &quot;</span> + pos.z.ToString() + <span class="string">&quot; &quot;</span> + <span class="string">&quot;PX &quot;</span>;</span><br><span class="line">      <span class="built_in">byte</span>[] bytstr= System.Text.Encoding.UTF8.GetBytes(str);<span class="comment">//单独编译</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">byte</span>[] sendByt = <span class="keyword">new</span> <span class="built_in">byte</span>[point.Right.Length+ bytstr.Length];</span><br><span class="line">      bytstr.CopyTo(sendByt, <span class="number">0</span>);</span><br><span class="line">      point.Right.CopyTo(sendByt, bytstr.Length);<span class="comment">//合并编码</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"> Texture2D = <span class="keyword">new</span> Texture2D(width, width);</span><br><span class="line"> <span class="built_in">byte</span>[] image = sendByt.Skip(bytstr.Length).ToArray();<span class="comment">//需要using System.Linq;//截取字节</span></span><br><span class="line"> print(image.Length);</span><br><span class="line"><span class="comment">// Array.Reverse(image);//可以使图像旋转180度</span></span><br><span class="line"> print(Texture2D.LoadImage(image));</span><br><span class="line"> Texture2D.Apply();<span class="number">5.4</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>

<h3 id="获取本地-I-P-地址"><a href="#获取本地-I-P-地址" class="headerlink" title="获取本地 I P 地址"></a>获取本地 I P 地址</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetLocalIp</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment"><span class="doctag">///</span>获取本地的IP地址</span></span><br><span class="line">       <span class="built_in">string</span> AddressIP = <span class="built_in">string</span>.Empty;</span><br><span class="line">       <span class="keyword">foreach</span> (IPAddress _IPAddress <span class="keyword">in</span> Dns.GetHostEntry(Dns.GetHostName()).AddressList)</span><br><span class="line">       &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (_IPAddress.AddressFamily.ToString() == <span class="string">&quot;InterNetwork&quot;</span>)</span><br><span class="line">           &#123;</span><br><span class="line"></span><br><span class="line">               AddressIP = _IPAddress.ToString();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> AddressIP;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="基本网络架构"><a href="#基本网络架构" class="headerlink" title="基本网络架构"></a>基本网络架构</h2><h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><p><img src="https://pica.zhimg.com/80/v2-e5925782976fc81a36cca0f889cec93a_720w.png"></p>
<h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CloudService</span>()</span> &#123;</span><br><span class="line">       msgHandle = <span class="keyword">new</span> MsgHandle();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">NewIndex</span>()</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (conns == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; conns.Length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (conns[i] == <span class="literal">null</span>) &#123;</span><br><span class="line">               conns[i] = <span class="keyword">new</span> Conn();</span><br><span class="line">               <span class="keyword">return</span> i;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (conns[i].isUse == <span class="literal">false</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> i;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ServiceStart</span>(<span class="params"><span class="built_in">string</span> host, <span class="built_in">int</span> port</span>)</span> &#123;</span><br><span class="line">       conns = <span class="keyword">new</span> Conn[maxConn];</span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; maxConn; i++) &#123;</span><br><span class="line">           conns[i] = <span class="keyword">new</span> Conn();</span><br><span class="line">       &#125;</span><br><span class="line">       Listerfd = <span class="keyword">new</span> Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);</span><br><span class="line">       IPAddress ipAdr = IPAddress.Parse(host);</span><br><span class="line">       IPEndPoint ipEp = <span class="keyword">new</span> IPEndPoint(ipAdr, port);</span><br><span class="line">       Listerfd.Bind(ipEp);</span><br><span class="line">       Listerfd.Listen(maxConn);</span><br><span class="line">       Listerfd.BeginAccept(AcceptCb, <span class="literal">null</span>);</span><br><span class="line">       status = <span class="literal">true</span>;</span><br><span class="line">       NetCloudServerManager.instance.debug.text+=(<span class="string">&quot;\n&quot;</span>+<span class="string">&quot;[服务器]启动成功&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Accept-Cb-异步监听"><a href="#Accept-Cb-异步监听" class="headerlink" title="Accept Cb 异步监听"></a>Accept Cb 异步监听</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AcceptCb</span>(<span class="params">IAsyncResult ar</span>)</span> &#123;</span><br><span class="line">        Socket socket = Listerfd.EndAccept(ar);<span class="comment">//要放在try外面</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//接收客户端</span></span><br><span class="line">            <span class="built_in">int</span> index = NewIndex();</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                socket.Close();</span><br><span class="line">                Debug.Log(<span class="string">&quot;[警告]连接已满&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Conn conn = conns[index];</span><br><span class="line">                conn.Init(socket);</span><br><span class="line">                <span class="built_in">string</span> host = conn.GetAdress();</span><br><span class="line">                Debug.Log(<span class="string">&quot;客户端连接:[&quot;</span> + host + <span class="string">&quot;] conn池ID:&quot;</span> + index);</span><br><span class="line">                conn.socket.BeginReceive(conn.readBuff, conn.buffCount, conn.BuffRemain(), SocketFlags.None, ReciveCb, conn);<span class="comment">//接收的同时调用ReciveCb回调函数</span></span><br><span class="line">            &#125;</span><br><span class="line">            Listerfd.BeginAccept(AcceptCb, <span class="literal">null</span>);<span class="comment">//再次调用AcceprCb回调函数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;AccpetCb 失败:&quot;</span> + e.Message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>出现莫名其妙的问题，等待异步需要放在 try 外面，不然会抛出 AcceptCb只能在主线程调用，要我放在awake和start中</p>
<h3 id="Recive-Cb异步接收"><a href="#Recive-Cb异步接收" class="headerlink" title="Recive Cb异步接收"></a>Recive Cb异步接收</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReciveCb</span>(<span class="params">IAsyncResult ar</span>)</span> &#123;</span><br><span class="line">        Conn conn = (Conn)ar.AsyncState;<span class="comment">//这个AsyncState就是上面那个BeginRecive函数里面最后一个参数</span></span><br><span class="line">        <span class="keyword">lock</span> (conn) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">int</span> count = conn.socket.EndReceive(ar);<span class="comment">//返回接收的字节数</span></span><br><span class="line">                                                       <span class="comment">//没有信息就关闭</span></span><br><span class="line">                <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    Debug.Log(<span class="string">&quot;收到[&quot;</span> + conn.GetAdress() + <span class="string">&quot;] 断开连接&quot;</span>);</span><br><span class="line">                    conn.Close();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                conn.buffCount += count;</span><br><span class="line">                ProcessData(conn);</span><br><span class="line">               </span><br><span class="line">                <span class="comment">//继续接收</span></span><br><span class="line">                conn.socket.BeginReceive(conn.readBuff, conn.buffCount, conn.BuffRemain(), SocketFlags.None, ReciveCb, conn);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Debug.Log(<span class="string">&quot;Recive失败&quot;</span> + e.Message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ProcessData</span>(<span class="params">Conn conn</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//小于字节长度</span></span><br><span class="line">        <span class="keyword">if</span> (conn.buffCount &lt; <span class="keyword">sizeof</span>(Int32)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Debug.Log(<span class="string">&quot;接收到了 &quot;</span> + conn.buffCount + <span class="string">&quot; 个字节&quot;</span>);</span><br><span class="line">        Array.Copy(conn.readBuff, conn.lenByte, <span class="keyword">sizeof</span>(Int32));</span><br><span class="line">        conn.msgLength = BitConverter.ToInt32(conn.lenByte, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//小于最小要求长度则返回表示未接收完全</span></span><br><span class="line">        <span class="keyword">if</span> (conn.buffCount &lt; conn.msgLength + <span class="keyword">sizeof</span>(Int32)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里接收信息有个细节，因为之前发送回来的信息又被加了一次长度，相当于要把他所有的信息接收完了</span></span><br><span class="line">        <span class="comment">//才算接收成功，然后再把前面的sizeof(Int32)去掉，剩下的就是带长度的信息了</span></span><br><span class="line">        ProtocolByte proto = <span class="keyword">new</span> ProtocolByte();</span><br><span class="line">        ProtocolByte protoStr = <span class="keyword">new</span> ProtocolByte();</span><br><span class="line">        ProtocolByte protocol = proto.Decode(conn.readBuff, <span class="keyword">sizeof</span>(Int32), conn.msgLength) <span class="keyword">as</span> ProtocolByte;</span><br><span class="line">        protoStr.AddString(conn.GetAdress());</span><br><span class="line">        protocol.bytes = protoStr.bytes.Concat(protocol.bytes).ToArray();</span><br><span class="line">        <span class="keyword">lock</span>(msgHandle.msgList) &#123;</span><br><span class="line">            msgHandle.msgList.Add(protocol);</span><br><span class="line">        &#125;</span><br><span class="line">        Debug.Log( protocol.GetDesc());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//清除已处理的消息</span></span><br><span class="line">        <span class="built_in">int</span> count = conn.buffCount - conn.msgLength - <span class="keyword">sizeof</span>(Int32);</span><br><span class="line">        Array.Copy(conn.readBuff, <span class="keyword">sizeof</span>(Int32) + conn.msgLength, conn.readBuff, <span class="number">0</span>, count);</span><br><span class="line">        conn.buffCount = count;</span><br><span class="line">        <span class="comment">//如果还有多余信息就继续处理</span></span><br><span class="line">        <span class="keyword">if</span> (conn.buffCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ProcessData(conn);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Conn类"><a href="#Conn类" class="headerlink" title="Conn类"></a>Conn类</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Conn</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">int</span> BUFFER_SIZE = <span class="number">16384</span>;</span><br><span class="line">    <span class="keyword">public</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isUse = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">byte</span>[] readBuff = <span class="keyword">new</span> <span class="built_in">byte</span>[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> buffCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> Int32 msgLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">byte</span>[] lenByte = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="keyword">sizeof</span>(Int32)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ProtocolByte assistProtolByte;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Conn</span>()</span> &#123;</span><br><span class="line">        readBuff = <span class="keyword">new</span> <span class="built_in">byte</span>[BUFFER_SIZE];</span><br><span class="line">        assistProtolByte = <span class="keyword">new</span> ProtocolByte();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params">Socket socket</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        isUse = <span class="literal">true</span>;</span><br><span class="line">        buffCount = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">BuffRemain</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BUFFER_SIZE - buffCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetAdress</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isUse) &#123; <span class="keyword">return</span> <span class="string">&quot;无法获取地址&quot;</span>; &#125;</span><br><span class="line">        <span class="keyword">return</span> socket.RemoteEndPoint.ToString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Close</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isUse) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;[断开连接]&quot;</span> + GetAdress());</span><br><span class="line">        socket.Close();</span><br><span class="line">        isUse = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">SendMsg</span>(<span class="params">ProtocolBase protol</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> proName = protol.GetName(); ;</span><br><span class="line">        <span class="keyword">return</span> SendMsg(protol, proName);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">SendMsg</span>(<span class="params">ProtocolBase protol, <span class="built_in">string</span> protolName</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        ProtocolByte protocolByte1 = <span class="keyword">new</span> ProtocolByte();</span><br><span class="line">        protocolByte1.AddString(protolName);</span><br><span class="line">        <span class="built_in">byte</span>[] protolNameByte = protocolByte1.bytes;</span><br><span class="line">        <span class="built_in">byte</span>[] b = protol.Encode();</span><br><span class="line">        <span class="built_in">byte</span>[] len1 = BitConverter.GetBytes(protolNameByte.Length + b.Length);</span><br><span class="line">        <span class="built_in">byte</span>[] sendByte = len1.Concat(protolNameByte).Concat(b).ToArray();</span><br><span class="line">        socket.Send(sendByte);</span><br><span class="line">        Debug.Log(<span class="string">&quot;sendByte &quot;</span> + sendByte.Length);</span><br><span class="line">        Debug.Log(<span class="string">&quot;sendBytes &quot;</span> + GetDesc(sendByte));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="built_in">string</span> <span class="title">GetDesc</span>(<span class="params"><span class="built_in">byte</span>[] bytes</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="literal">null</span>) <span class="keyword">return</span> str;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; bytes.Length; i++) &#123;</span><br><span class="line">            <span class="built_in">int</span> b = (<span class="built_in">int</span>)bytes[i];</span><br><span class="line">            str += b.ToString() + <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消息处理类"><a href="#消息处理类" class="headerlink" title="消息处理类"></a>消息处理类</h3><p>区别于客户端消息类，处理消息时，需要在接收的消息中加入传来的消息IP地址防止找不到回溯玩家。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MsgHandle</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> num = NetCloudServerManager.instance.HandleMsgNum;</span><br><span class="line">    Dictionary&lt;<span class="built_in">string</span>, ProtocolBase&gt; oneMessager = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, ProtocolBase&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;ProtocolBase&gt; msgList = <span class="keyword">new</span> List&lt;ProtocolBase&gt;();</span><br><span class="line"></span><br><span class="line">    ProtocolByte assistProtocol;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Running</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(msgList.Count&gt;<span class="number">0</span>&amp;&amp;num&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            num--;</span><br><span class="line">            <span class="comment">//处理长度和将协议分开</span></span><br><span class="line">            assistProtocol = msgList[<span class="number">0</span>] <span class="keyword">as</span> ProtocolByte;</span><br><span class="line">            <span class="keyword">if</span>(assistProtocol==<span class="literal">null</span>) &#123;</span><br><span class="line">                Debug.Log(<span class="string">&quot;消息转化失败&quot;</span>);</span><br><span class="line">                <span class="keyword">lock</span> (msgList) &#123;</span><br><span class="line">                    msgList.RemoveAt(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">int</span> start = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">string</span> IpAddress = assistProtocol.GetString(start, <span class="keyword">ref</span> start);</span><br><span class="line">            <span class="built_in">string</span> protocolName=assistProtocol.GetString(start, <span class="keyword">ref</span> start);</span><br><span class="line">            <span class="comment">//int protocolNameLen=System.Text.Encoding.UTF8.GetBytes(protocolName).Length + sizeof(Int32);</span></span><br><span class="line">            <span class="keyword">switch</span> (protocolName) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;ProtocolCubeTexture&quot;</span>:</span><br><span class="line">                    ProtocolCubeTexture protocolCubeTexture = <span class="keyword">new</span> ProtocolCubeTexture();</span><br><span class="line">                    ProtocolCubeTexture aprotocol = protocolCubeTexture.Decode(assistProtocol.bytes, start, assistProtocol.bytes.Length) <span class="keyword">as</span> ProtocolCubeTexture;</span><br><span class="line">                    <span class="keyword">if</span> (aprotocol == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">                    PointMessage point = <span class="keyword">new</span> PointMessage();</span><br><span class="line">                    point.ResolveToPointMessage(aprotocol.Coord, aprotocol.CubemapFace, aprotocol.srcTexture);</span><br><span class="line">                    NetCloudServerManager.instance.PM.Add(point);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;Start&quot;</span>:</span><br><span class="line">                    StartProcessData(assistProtocol, start, IpAddress);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">lock</span>(msgList) &#123;</span><br><span class="line">                msgList.RemoveAt(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//ProtocolCubeTexture protocol = msgList[0] as ProtocolCubeTexture;</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        num = NetCloudServerManager.instance.HandleMsgNum;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">StartProcessData</span>(<span class="params">ProtocolByte protocol,<span class="built_in">int</span> start,<span class="built_in">string</span> SendIPAddress</span>)</span> &#123;</span><br><span class="line">        ProtocolStr protocolStr = <span class="keyword">new</span> ProtocolStr();</span><br><span class="line">        Debug.Log(<span class="string">&quot;start&quot;</span> + start + <span class="string">&quot; lenth&quot;</span> + assistProtocol.bytes.Length);</span><br><span class="line">        ProtocolStr protocolstr = protocolStr.Decode(assistProtocol.bytes, start, assistProtocol.bytes.Length-start) <span class="keyword">as</span> ProtocolStr;</span><br><span class="line">        NetCloudServerManager.instance.debug.text += (<span class="string">&quot;\n&quot;</span> + protocolstr.str);</span><br><span class="line">        <span class="built_in">string</span>[] CoordStrs = protocolstr.str.Split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        <span class="built_in">float</span>[] Coord = <span class="keyword">new</span> <span class="built_in">float</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">            Coord[i] = <span class="built_in">float</span>.Parse(CoordStrs[i]);</span><br><span class="line">        Camera camm = NetCloudServerManager.instance.cam;</span><br><span class="line">        camm.transform.position = <span class="keyword">new</span> Vector3( Coord[<span class="number">0</span>], Coord[<span class="number">1</span>], Coord[<span class="number">2</span>]);</span><br><span class="line">        PointMessage point = <span class="keyword">new</span> PointMessage();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ( camm.RenderToCubemap(point.cubemap)) &#123;</span><br><span class="line">            <span class="built_in">int</span> index = <span class="number">-1</span>;</span><br><span class="line">            Conn[] conns = NetCloudServerManager.cs.conns;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; conns.Length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (conns[i] == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (!conns[i].isUse)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(conns[i].GetAdress()==SendIPAddress) &#123;</span><br><span class="line">                    index = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//print(&quot; 将消息传播&quot; + conns[i].GetAdress());</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="built_in">int</span> width = NetCloudServerManager.instance.width;</span><br><span class="line">            ProtocolCubeTexture protocolCube = <span class="keyword">new</span> ProtocolCubeTexture();</span><br><span class="line">            protocolCube.srcTexture = <span class="keyword">new</span> Texture2D(width, width);</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">                protocolCube.Coord[i] = <span class="built_in">int</span>.Parse(CoordStrs[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++) &#123;</span><br><span class="line">                protocolCube.CubemapFace = i;</span><br><span class="line">                protocolCube.srcTexture.SetPixels(point.cubemap.GetPixels((CubemapFace)i));</span><br><span class="line">                protocolCube.srcTexture.Apply();</span><br><span class="line">                conns[index].SendMsg(protocolCube);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            NetCloudServerManager.instance.debug.text+= (<span class="string">&quot;\n&quot;</span> + protocolstr.str+<span class="string">&quot;渲染失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PointMessage-点消息类"><a href="#PointMessage-点消息类" class="headerlink" title="PointMessage 点消息类"></a>PointMessage 点消息类</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PointMessage</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Vector3 pos;</span><br><span class="line">    <span class="keyword">public</span> Cubemap cubemap;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">int</span> width;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PointMessage</span>()</span> &#123;</span><br><span class="line">        pos = Vector3.zero;</span><br><span class="line">        width = NetCloudServerManager.instance.width;</span><br><span class="line"></span><br><span class="line">        cubemap = <span class="keyword">new</span> Cubemap(width, TextureFormat.RGBA32, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="Connect-类"><a href="#Connect-类" class="headerlink" title="Connect 类"></a>Connect 类</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Connect</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Socket socket;</span><br><span class="line">    <span class="built_in">int</span> BUFFER_SIZE = NetCloudClientManager.instance.BUFFER_SIZE;</span><br><span class="line">    <span class="built_in">byte</span>[] readBuff ;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> buffCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Int32 msgLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">byte</span>[] lenByte = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="keyword">sizeof</span>(Int32)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ProtocolByte assistProtolByte;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MsgHandle msgHandle = <span class="keyword">new</span> MsgHandle();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">enum</span> Status &#123;</span><br><span class="line">        None,Connect</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> Status status = Status.None;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> width = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span>  <span class="title">Connect</span>()</span> &#123;</span><br><span class="line">        readBuff = <span class="keyword">new</span> <span class="built_in">byte</span>[BUFFER_SIZE];</span><br><span class="line">        assistProtolByte = <span class="keyword">new</span> ProtocolByte();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Connetion</span>(<span class="params"><span class="built_in">string</span> host, <span class="built_in">int</span> port</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//清理text</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Socket</span></span><br><span class="line">            socket = <span class="keyword">new</span> Socket(AddressFamily.InterNetwork,</span><br><span class="line">            SocketType.Stream, ProtocolType.Tcp);</span><br><span class="line">            <span class="keyword">if</span> (host.Length == <span class="number">0</span>) &#123;</span><br><span class="line">                host = <span class="string">&quot;192.168.50.142&quot;</span>;</span><br><span class="line">                port = <span class="number">1234</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            socket.Connect(host, port);</span><br><span class="line">            status = Status.Connect;</span><br><span class="line">            NetCloudClientManager.instance.debug.text += (<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;客户端地址&quot;</span> + socket.LocalEndPoint.ToString());</span><br><span class="line">            socket.BeginReceive(readBuff, buffCount, BUFFER_SIZE - buffCount, SocketFlags.None, ReceiveCb, readBuff);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            NetCloudClientManager.instance.debug.text += (<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;客户端失败&quot;</span>+e.Message );</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// clientText.text = &quot;客户端地址&quot; + socket.LocalEndPoint.ToString();</span></span><br><span class="line">        <span class="comment">//Recv</span></span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ReceiveCb</span>(<span class="params">IAsyncResult ar</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//count是接收数据的大小</span></span><br><span class="line">            <span class="built_in">int</span> count = socket.EndReceive(ar);</span><br><span class="line">            buffCount += count;</span><br><span class="line">            ProcessData();</span><br><span class="line">            socket.BeginReceive(readBuff,buffCount , BUFFER_SIZE-buffCount, SocketFlags.None, ReceiveCb, readBuff);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           <span class="comment">// recvText.text += &quot;连接已断开&quot;;</span></span><br><span class="line">            socket.Close();</span><br><span class="line">            status = Status.None;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ProcessData</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (buffCount &lt; <span class="keyword">sizeof</span>(Int32))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Array.Copy(readBuff, lenByte, <span class="keyword">sizeof</span>(Int32));</span><br><span class="line">        msgLength = BitConverter.ToInt32(lenByte, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (buffCount &lt; msgLength + <span class="keyword">sizeof</span>(Int32))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        ProtocolBase protocol = assistProtolByte.Decode(readBuff, <span class="keyword">sizeof</span>(Int32), msgLength);</span><br><span class="line">        <span class="keyword">lock</span>(msgHandle.msgList) &#123;</span><br><span class="line">            msgHandle.msgList.Add(protocol);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> count = buffCount - msgLength - <span class="keyword">sizeof</span>(Int32);</span><br><span class="line">        Array.Copy(readBuff, <span class="keyword">sizeof</span>(Int32) + msgLength, readBuff, <span class="number">0</span>, count);</span><br><span class="line">        buffCount = count;</span><br><span class="line">        <span class="keyword">if</span> (buffCount &gt; <span class="number">0</span>)</span><br><span class="line">            ProcessData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Close</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket.Close();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;关闭失败:&quot;</span> + e.Message);</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span>  <span class="title">SendMsg</span>(<span class="params"> ProtocolBase protol</span>)</span> &#123;    </span><br><span class="line">        <span class="built_in">string</span> proName = protol.GetName();  ;</span><br><span class="line">        <span class="keyword">return</span> SendMsg(protol, proName);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">SendMsg</span>(<span class="params">ProtocolBase protol,<span class="built_in">string</span> protolName</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (status != Status.Connect) &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;404 Not Found&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ProtocolByte protocolByte1 = <span class="keyword">new</span> ProtocolByte();</span><br><span class="line">        protocolByte1.AddString(protolName);</span><br><span class="line">        <span class="built_in">byte</span>[] protolNameByte = protocolByte1.bytes;</span><br><span class="line">        <span class="built_in">byte</span>[] b = protol.Encode();</span><br><span class="line">        <span class="built_in">byte</span>[] len1 = BitConverter.GetBytes(protolNameByte.Length + b.Length);</span><br><span class="line">        <span class="built_in">byte</span>[] sendByte = len1.Concat(protolNameByte).Concat(b).ToArray();</span><br><span class="line">        socket.Send(sendByte);</span><br><span class="line">        Debug.Log(GetStr(sendByte));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="built_in">string</span> <span class="title">GetStr</span>(<span class="params"><span class="built_in">byte</span>[] bytes</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="literal">null</span>) <span class="keyword">return</span> str;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; bytes.Length; i++) &#123;</span><br><span class="line">            <span class="built_in">int</span> b = (<span class="built_in">int</span>)bytes[i];</span><br><span class="line">            str += b.ToString() + <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 地址辅助方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetClientAddress</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> socket.LocalEndPoint.ToString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetLocalIp</span>()</span> &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span>获取本地的IP地址</span></span><br><span class="line">        <span class="built_in">string</span> AddressIP = <span class="built_in">string</span>.Empty;</span><br><span class="line">        <span class="keyword">foreach</span> (IPAddress _IPAddress <span class="keyword">in</span> Dns.GetHostEntry(Dns.GetHostName()).AddressList) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_IPAddress.AddressFamily.ToString() == <span class="string">&quot;InterNetwork&quot;</span>) &#123;</span><br><span class="line"></span><br><span class="line">                AddressIP = _IPAddress.ToString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> AddressIP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消息处理类-1"><a href="#消息处理类-1" class="headerlink" title="消息处理类"></a>消息处理类</h3><p>在处理消息队列时一定需要上lock</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MsgHandle</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> num = NetCloudClientManager.instance.HandleMsgNum;</span><br><span class="line">    <span class="keyword">public</span> List&lt;ProtocolBase&gt; msgList = <span class="keyword">new</span> List&lt;ProtocolBase&gt;();</span><br><span class="line"></span><br><span class="line">    ProtocolByte assistProtocol;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Running</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(msgList.Count&gt;<span class="number">0</span>&amp;&amp;num&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            num--;</span><br><span class="line">            <span class="comment">//处理长度和将协议分开</span></span><br><span class="line">            assistProtocol = msgList[<span class="number">0</span>] <span class="keyword">as</span> ProtocolByte;</span><br><span class="line">            <span class="keyword">if</span>(assistProtocol==<span class="literal">null</span>) &#123;</span><br><span class="line">                Debug.Log(<span class="string">&quot;消息转化失败&quot;</span>);</span><br><span class="line">                <span class="keyword">lock</span> (msgList) &#123;</span><br><span class="line">                    msgList.RemoveAt(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">string</span> protocolName=assistProtocol.GetName();</span><br><span class="line">            <span class="built_in">int</span> protocolNameLen=System.Text.Encoding.UTF8.GetBytes(protocolName).Length + <span class="keyword">sizeof</span>(Int32);</span><br><span class="line">            <span class="keyword">switch</span> (protocolName) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;ProtocolCubeTexture&quot;</span>:</span><br><span class="line">                    ProtocolCubeTexture protocolCubeTexture = <span class="keyword">new</span> ProtocolCubeTexture();</span><br><span class="line">                    ProtocolCubeTexture aprotocol = protocolCubeTexture.Decode(assistProtocol.bytes, protocolNameLen, assistProtocol.bytes.Length) <span class="keyword">as</span> ProtocolCubeTexture;</span><br><span class="line">                    <span class="keyword">if</span> (aprotocol == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">                    Vector3 pos = <span class="keyword">new</span> Vector3(aprotocol.Coord[<span class="number">0</span>], aprotocol.Coord[<span class="number">1</span>], aprotocol.Coord[<span class="number">2</span>]);</span><br><span class="line">                    PointMessage point = NetCloudClientManager.instance.PM.Find((PointMessage p) =&gt; p.pos.Equals(pos));</span><br><span class="line">                    <span class="keyword">if</span>(point==<span class="literal">null</span>) point = <span class="keyword">new</span> PointMessage();</span><br><span class="line">                    </span><br><span class="line">                    point.ResolveToPointMessage(aprotocol.Coord, aprotocol.CubemapFace, aprotocol.srcTexture);</span><br><span class="line">                    </span><br><span class="line">                    NetCloudClientManager.instance.PM.Add(point);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;Start&quot;</span>:</span><br><span class="line">                    ProtocolStr protocolStr = <span class="keyword">new</span> ProtocolStr();</span><br><span class="line">                    ProtocolStr protocolstr = protocolStr.Decode(assistProtocol.bytes, protocolNameLen, assistProtocol.bytes.Length) <span class="keyword">as</span> ProtocolStr;</span><br><span class="line">                    NetCloudClientManager.instance.debug.text += (<span class="string">&quot;\n&quot;</span> + protocolstr.str);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">lock</span>(msgList) &#123;</span><br><span class="line">                msgList.RemoveAt(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//ProtocolCubeTexture protocol = msgList[0] as ProtocolCubeTexture;</span></span><br><span class="line">        &#125;</span><br><span class="line">        num = NetCloudClientManager.instance.HandleMsgNum;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="PointMessage-点消息类-1"><a href="#PointMessage-点消息类-1" class="headerlink" title="PointMessage 点消息类"></a>PointMessage 点消息类</h3><p>区别于服务端，需要把相应的字节流变成texture，并将其贴到点消息的CubeMap上</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PointMessage</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Vector3 pos;</span><br><span class="line">    <span class="keyword">public</span> Cubemap cubemap;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">int</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span>[] FaceFlags ;</span><br><span class="line">    <span class="built_in">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PointMessage</span>()</span> &#123;</span><br><span class="line">        pos = Vector3.zero;</span><br><span class="line">        width = NetCloudClientManager.instance.width;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        FaceFlags = <span class="keyword">new</span> <span class="built_in">bool</span>[] &#123; <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span> &#125;;</span><br><span class="line">        cubemap = <span class="keyword">new</span> Cubemap(width, TextureFormat.RGBA32, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ResolveToPointMessage</span>(<span class="params"><span class="built_in">byte</span>[] byt </span>)</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> str = System.Text.Encoding.UTF8.GetString(byt);</span><br><span class="line">        <span class="built_in">string</span>[] strs = str.Split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        pos.x = <span class="built_in">float</span>.Parse(strs[<span class="number">0</span>]);</span><br><span class="line">        pos.y = <span class="built_in">float</span>.Parse(strs[<span class="number">1</span>]);</span><br><span class="line">        pos.z = <span class="built_in">float</span>.Parse(strs[<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">string</span> CF = strs[<span class="number">3</span>]; </span><br><span class="line">        <span class="built_in">int</span> bytCount = System.Text.Encoding.UTF8.GetBytes(pos.x.ToString() + <span class="string">&quot; &quot;</span> + pos.y.ToString() + <span class="string">&quot; &quot;</span> + pos.z.ToString() + <span class="string">&quot; &quot;</span> + CF + <span class="string">&quot; &quot;</span>).Length;</span><br><span class="line">        <span class="built_in">byte</span>[] image = byt.Skip(bytCount).ToArray();</span><br><span class="line">        <span class="keyword">switch</span> (CF) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;PX&quot;</span>: cubemap.SetPixels(ColorToCubemap(image), CubemapFace.PositiveX); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;NX&quot;</span>: cubemap.SetPixels(ColorToCubemap(image), CubemapFace.NegativeX); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;PY&quot;</span>: cubemap.SetPixels(ColorToCubemap(image), CubemapFace.PositiveY); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;NY&quot;</span>: cubemap.SetPixels(ColorToCubemap(image), CubemapFace.NegativeY); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;PZ&quot;</span>: cubemap.SetPixels(ColorToCubemap(image), CubemapFace.PositiveZ); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;NZ&quot;</span>: cubemap.SetPixels(ColorToCubemap(image), CubemapFace.NegativeZ); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cubemap.Apply();</span><br><span class="line">        size++;</span><br><span class="line">        <span class="comment">//Texture2DClient.LoadImage(image);</span></span><br><span class="line">        <span class="comment">//Texture2DClient.Apply();</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ResolveToPointMessage</span>(<span class="params"><span class="built_in">int</span>[] Coord,<span class="built_in">int</span> CubeMapFace,Texture2D texture</span>)</span> &#123;</span><br><span class="line">        pos.x = Coord[<span class="number">0</span>];</span><br><span class="line">        pos.y = Coord[<span class="number">1</span>];</span><br><span class="line">        pos.z = Coord[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">switch</span> (CubeMapFace) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: cubemap.SetPixels( texture.GetPixels(), CubemapFace.PositiveX); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: cubemap.SetPixels( texture.GetPixels(), CubemapFace.NegativeX); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: cubemap.SetPixels( texture.GetPixels(), CubemapFace.PositiveY); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: cubemap.SetPixels( texture.GetPixels(), CubemapFace.NegativeY); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>: cubemap.SetPixels( texture.GetPixels(), CubemapFace.PositiveZ); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>: cubemap.SetPixels( texture.GetPixels(), CubemapFace.NegativeZ); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Debug.Log(<span class="string">&quot;cubeface &quot;</span> + CubeMapFace);</span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">        FaceFlags[CubeMapFace] = <span class="literal">true</span>;</span><br><span class="line">        cubemap.Apply();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Color[] <span class="title">ColorToCubemap</span>(<span class="params"><span class="built_in">byte</span>[] byt</span>)</span> &#123;</span><br><span class="line">        Texture2D textureTest = <span class="keyword">new</span> Texture2D(width, width);</span><br><span class="line">        textureTest.LoadImage(byt);</span><br><span class="line">        textureTest.Apply();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> textureTest.GetPixels() ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="built_in">int</span>  <span class="title">GetSize</span>()</span> &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;FaceFlags.Length;i++) &#123; <span class="keyword">if</span> (FaceFlags[i]) size++; &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aa</span>()</span> &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;aaaaa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>个人理解：字节流协议和字符串流协议算是中间层协议，其他协议类可以聚合两个中间层协议进行编写。</p>
<h3 id="协议基类"><a href="#协议基类" class="headerlink" title="协议基类"></a>协议基类</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProtocolBase</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//解码器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> ProtocolBase <span class="title">Decode</span>(<span class="params"><span class="built_in">byte</span>[] readBuff,<span class="built_in">int</span> start,<span class="built_in">int</span> length</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProtocolBase();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//编码器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">byte</span>[] <span class="title">Encode</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">byte</span>[] &#123; &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">GetName</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Base&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">GetDesc</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字节流协议"><a href="#字节流协议" class="headerlink" title="字节流协议"></a>字节流协议</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProtocolByte</span> : <span class="title">ProtocolBase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">byte</span>[] bytes;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> ProtocolBase <span class="title">Decode</span>(<span class="params"><span class="built_in">byte</span>[] readBuff, <span class="built_in">int</span> start, <span class="built_in">int</span> length</span>)</span> &#123;</span><br><span class="line">        ProtocolByte proByte = <span class="keyword">new</span> ProtocolByte();</span><br><span class="line">        proByte.bytes = <span class="keyword">new</span> <span class="built_in">byte</span>[length];</span><br><span class="line">        Array.Copy(readBuff, start, proByte.bytes, <span class="number">0</span>, length);</span><br><span class="line">        <span class="keyword">return</span> (ProtocolBase)proByte;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">byte</span>[] <span class="title">Encode</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">GetName</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> GetString(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">GetDesc</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="literal">null</span>) <span class="keyword">return</span> str;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;bytes.Length;i++) &#123;</span><br><span class="line">            <span class="built_in">int</span> b = (<span class="built_in">int</span>)bytes[i];</span><br><span class="line">            str += b.ToString() + <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 字节辅助流</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddString</span>(<span class="params"><span class="built_in">string</span> str</span>)</span> &#123;</span><br><span class="line">        Int32 len = str.Length;</span><br><span class="line">        <span class="built_in">byte</span>[] lenBytes = BitConverter.GetBytes(len);</span><br><span class="line">        <span class="built_in">byte</span>[] strBytes = System.Text.Encoding.UTF8.GetBytes(str);</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="literal">null</span>)</span><br><span class="line">            bytes = lenBytes.Concat(strBytes).ToArray();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            bytes = bytes.Concat(lenBytes).Concat(strBytes).ToArray();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetString</span>(<span class="params"><span class="built_in">int</span> start, <span class="keyword">ref</span> <span class="built_in">int</span> end</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (bytes.Length &lt; start + <span class="keyword">sizeof</span>(Int32))</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        Int32 strLen = BitConverter.ToInt32(bytes, start);</span><br><span class="line">        <span class="keyword">if</span> (bytes.Length &lt; start + <span class="keyword">sizeof</span>(Int32) + strLen)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> str = System.Text.Encoding.UTF8.GetString(bytes, start + <span class="keyword">sizeof</span>(Int32) , strLen);</span><br><span class="line">        end = start + <span class="keyword">sizeof</span>(Int32) + strLen;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetString</span>(<span class="params"><span class="built_in">int</span> start</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> GetString(start,<span class="keyword">ref</span> end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddInt</span>(<span class="params"><span class="built_in">int</span> num</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">byte</span>[] numBytes = BitConverter.GetBytes(num);</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="literal">null</span>)</span><br><span class="line">            bytes = numBytes;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            bytes = bytes.Concat(numBytes).ToArray();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetInt</span>(<span class="params"><span class="built_in">int</span> start,<span class="keyword">ref</span> <span class="built_in">int</span> end</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (bytes.Length &lt; start + <span class="keyword">sizeof</span>(Int32))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        end = start + <span class="keyword">sizeof</span>(Int32);</span><br><span class="line">        <span class="keyword">return</span> BitConverter.ToInt32(bytes, start);</span><br><span class="line">    &#125;<span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetInt</span>(<span class="params"><span class="built_in">int</span> start</span>)</span> &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="built_in">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> GetInt(start,<span class="keyword">ref</span> end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddFloat</span>(<span class="params"><span class="built_in">float</span> num</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">byte</span>[] numBytes = BitConverter.GetBytes(num);</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="literal">null</span>)</span><br><span class="line">            bytes = numBytes;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            bytes = bytes.Concat(numBytes).ToArray();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">float</span> <span class="title">GetFloat</span>(<span class="params"><span class="built_in">int</span> start, <span class="keyword">ref</span> <span class="built_in">int</span> end</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (bytes.Length &lt; start + <span class="keyword">sizeof</span>(<span class="built_in">float</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        end = start + <span class="keyword">sizeof</span>(<span class="built_in">float</span>);</span><br><span class="line">        <span class="keyword">return</span> BitConverter.ToSingle(bytes, start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">float</span> <span class="title">GetFloat</span>(<span class="params"><span class="built_in">int</span> start</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> GetFloat(start, <span class="keyword">ref</span> end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串协议"><a href="#字符串协议" class="headerlink" title="字符串协议"></a>字符串协议</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProtocolStr</span> : <span class="title">ProtocolBase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> str;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> ProtocolBase <span class="title">Decode</span>(<span class="params"><span class="built_in">byte</span>[] readBuff, <span class="built_in">int</span> start, <span class="built_in">int</span> length</span>)</span> &#123;</span><br><span class="line">        ProtocolStr proStr = <span class="keyword">new</span> ProtocolStr();    </span><br><span class="line">        proStr.str = System.Text.Encoding.UTF8.GetString(readBuff, start, length);</span><br><span class="line">        <span class="keyword">return</span> (ProtocolBase) proStr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">byte</span>[] <span class="title">Encode</span>()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> System.Text.Encoding.UTF8.GetBytes(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">GetName</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.Length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> str.Split(<span class="string">&#x27;,&#x27;</span>)[<span class="number">0</span>];  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">GetDesc</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ProtocolCubeTexture-协议"><a href="#ProtocolCubeTexture-协议" class="headerlink" title="ProtocolCubeTexture 协议"></a>ProtocolCubeTexture 协议</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProtocolCubeTexture</span> : <span class="title">ProtocolBase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> width = NetCloudClientManager.instance.width;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[] Coord = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">public</span> Texture2D srcTexture;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> CubemapFace = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//解码器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> ProtocolBase <span class="title">Decode</span>(<span class="params"><span class="built_in">byte</span>[] readBuff, <span class="built_in">int</span> start, <span class="built_in">int</span> length</span>)</span> &#123;</span><br><span class="line">        ProtocolCubeTexture proTexture = <span class="keyword">new</span> ProtocolCubeTexture();</span><br><span class="line">        ProtocolByte proByte = <span class="keyword">new</span> ProtocolByte();</span><br><span class="line">        proByte.bytes = readBuff;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) &#123;</span><br><span class="line">            proTexture.Coord[i] = proByte.GetInt(start, <span class="keyword">ref</span> start);</span><br><span class="line">        &#125;</span><br><span class="line">        proTexture.CubemapFace = proByte.GetInt(start, <span class="keyword">ref</span> start);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//图片解析</span></span><br><span class="line">        <span class="built_in">int</span> srcStart = start;</span><br><span class="line">        <span class="built_in">int</span> srcLength = readBuff.Length-start;</span><br><span class="line">        <span class="built_in">byte</span>[] srcbyte = <span class="keyword">new</span> <span class="built_in">byte</span>[srcLength];</span><br><span class="line">        Array.Copy(readBuff, srcStart, srcbyte, <span class="number">0</span>, srcLength);</span><br><span class="line">        proTexture.srcTexture = <span class="keyword">new</span> Texture2D(width,width);</span><br><span class="line">        proTexture.srcTexture.LoadImage(srcbyte);</span><br><span class="line">        proTexture.srcTexture.Apply();</span><br><span class="line">        <span class="comment">//NetCloudClientManager.instance.tex[proTexture.CubemapFace] = proTexture.srcTexture;</span></span><br><span class="line">        <span class="keyword">return</span> (ProtocolBase) proTexture;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//编码器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">byte</span>[] <span class="title">Encode</span>()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//立方体面编译</span></span><br><span class="line">        </span><br><span class="line">        ProtocolByte proByte = <span class="keyword">new</span> ProtocolByte();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) &#123;</span><br><span class="line">            proByte.AddInt(Coord[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        proByte.AddInt(CubemapFace);</span><br><span class="line">        <span class="built_in">byte</span>[] cubeFaceBytes = proByte.Encode();</span><br><span class="line">        <span class="comment">//图片编译</span></span><br><span class="line">        <span class="keyword">if</span> (srcTexture == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">byte</span>[] srcTextureByte = srcTexture.EncodeToJPG();</span><br><span class="line">        <span class="comment">//byte[] lenByte = BitConverter.GetBytes(srcTextureByte.Length + cubeFaceBytes.Length);</span></span><br><span class="line">        <span class="built_in">byte</span>[] byt = cubeFaceBytes.Concat(srcTextureByte).ToArray();</span><br><span class="line">        <span class="keyword">return</span> byt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">GetName</span>()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ProtocolCubeTexture&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">GetDesc</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">byte</span>[] srcTextureByte = srcTexture.EncodeToJPG();</span><br><span class="line">        <span class="keyword">if</span> (srcTextureByte == <span class="literal">null</span>) <span class="keyword">return</span> str;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; srcTextureByte.Length; i++) &#123;</span><br><span class="line">            <span class="built_in">int</span> b = (<span class="built_in">int</span>)srcTextureByte[i];</span><br><span class="line">            str += b.ToString() + <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>全景图</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL学习之路之光照贴图</title>
    <url>/2021/12/07/OpenGL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E5%85%89%E7%85%A7%E8%B4%B4%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="冯光照模型"><a href="#冯光照模型" class="headerlink" title="冯光照模型"></a>冯光照模型</h1><p>效果混合相加：diffuse + ambient + specular</p>
<p>图片混和相乘：(diffuse + ambient + specular) * objColor</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FragColor =vec4((diffuse + ambient + specular) * objColor,<span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure>

<h1 id="环境光–ambient"><a href="#环境光–ambient" class="headerlink" title="环境光–ambient"></a>环境光–ambient</h1><p>ambient具体能表现无光照区域的颜色，在物体较暗的部分加上漫反射贴图会更真实</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vec3 ambient=texture(material.diffuse, TexCoord).rgb * ambientColor;</span><br></pre></td></tr></table></figure>

<h1 id="漫反射贴图—diffuse"><a href="#漫反射贴图—diffuse" class="headerlink" title="漫反射贴图—diffuse"></a>漫反射贴图—diffuse</h1><p>出现的大概像表面的纹理像木箱的表面，相当于简单反射到眼睛的获得的颜色</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vec3 diffuse=texture(material.diffuse,TexCoord).rgb * max( dot( lightDir, Normal), <span class="number">0</span>) * lightColor;</span><br><span class="line">    <span class="comment">//vec3 diffuse=texture(material.diffuse,TexCoord).rgb;</span></span><br></pre></td></tr></table></figure>
<h1 id="镜面反射—specular"><a href="#镜面反射—specular" class="headerlink" title="镜面反射—specular"></a>镜面反射—specular</h1><p>可以将光照和高光进行反射，提高真实度</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vec3 reflectVec=reflect(-lightDir,Normal);</span><br><span class="line"><span class="keyword">float</span> specularAmount=<span class="built_in">pow</span>(max(dot(reflectVec,cameraVec),<span class="number">0</span>),material.shininess); <span class="comment">//高光的集中度，倍数越高，同一视角高光点越小</span></span><br><span class="line">vec3 specular=texture(material.specular,TexCoord).rgb * specularAmount * lightColor;<span class="comment">//镜面反射图中为数值0或者为黑色表示不需要镜面反射，木块和铁最好对比</span></span><br></pre></td></tr></table></figure>

<h1 id="发射光贴图—emission"><a href="#发射光贴图—emission" class="headerlink" title="发射光贴图—emission"></a>发射光贴图—emission</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vec3 emission=texture(material.emission,TexCoord).rgb;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL学习之路之光源大总结</title>
    <url>/2021/12/19/OpenGL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E5%85%89%E6%BA%90%E5%A4%A7%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="光源所需条件"><a href="#光源所需条件" class="headerlink" title="光源所需条件"></a>光源所需条件</h1><h4 id="1-光照信息"><a href="#1-光照信息" class="headerlink" title="1.光照信息"></a>1.光照信息</h4><p>定向光 点光源 聚光灯的属性</p>
<h4 id="2-法线向量"><a href="#2-法线向量" class="headerlink" title="2.法线向量"></a>2.法线向量</h4><p>将顶点着色器的法线信息接收，并进行标准化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vec3 uNormal=<span class="built_in">normalize</span>(Normal);</span><br></pre></td></tr></table></figure>

<h4 id="3-片元到摄像头的位置"><a href="#3-片元到摄像头的位置" class="headerlink" title="3.片元到摄像头的位置"></a>3.片元到摄像头的位置</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vec3 dirToCamera=<span class="built_in">normalize</span>(cameraPos-FragPos);</span><br></pre></td></tr></table></figure>

<h2 id="定向光"><a href="#定向光" class="headerlink" title="定向光"></a>定向光</h2><h4 id="主要光照信息"><a href="#主要光照信息" class="headerlink" title="主要光照信息"></a>主要光照信息</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LightDirectional</span>&#123;</span><br><span class="line">  vec3 pos;<span class="comment">//光源坐标</span></span><br><span class="line">  vec3 color;<span class="comment">//光颜色</span></span><br><span class="line">  vec3 dirToLight;<span class="comment">//光照角度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>不需要光照衰弱，光照与位置无关</p>
<h4 id="diffuse"><a href="#diffuse" class="headerlink" title="diffuse"></a>diffuse</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">diffuseIntersity=<span class="built_in">max</span>(<span class="built_in">dot</span>(light.dirToLight,Normal),<span class="number">0</span>);</span><br><span class="line">diffuse=diffuseIntersity*light.color*<span class="built_in">texture</span>(material.diffuse,TexCoord).rgb;</span><br></pre></td></tr></table></figure>

<h4 id="specular"><a href="#specular" class="headerlink" title="specular"></a>specular</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">specularIntersity=<span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(<span class="built_in">normalize</span>(<span class="built_in">reflect</span>(-light.dirToLight,Normal)),dirToCamera),<span class="number">0</span>),material.shininess);</span><br><span class="line">vec3 specular=specularIntersity*light.color*<span class="built_in">texture</span>(material.specular,TexCoord).rgb;</span><br></pre></td></tr></table></figure>

<h2 id="点光源"><a href="#点光源" class="headerlink" title="点光源"></a>点光源</h2><h4 id="主要光照信息-1"><a href="#主要光照信息-1" class="headerlink" title="主要光照信息"></a>主要光照信息</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LightPoint</span>&#123;</span><br><span class="line">  vec3 pos;</span><br><span class="line">  vec3 color;</span><br><span class="line">  vec3 dirToLight;<span class="comment">//用不上</span></span><br><span class="line">    <span class="type">float</span> constant;<span class="comment">//1.0f</span></span><br><span class="line">    <span class="type">float</span> linear;<span class="comment">//0.09f</span></span><br><span class="line">    <span class="type">float</span> quadratic;<span class="comment">//0.032f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>与光照方向无关</p>
<h4 id="attenuation"><a href="#attenuation" class="headerlink" title="attenuation"></a>attenuation</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> distantes=<span class="built_in">length</span>(light.pos-FragPos);</span><br><span class="line"><span class="type">float</span> attenuation=<span class="number">1.0f</span>/light.constant+light.linear*distantes+light.quadratic*distantes*distantes;</span><br></pre></td></tr></table></figure>



<h4 id="diffuse-1"><a href="#diffuse-1" class="headerlink" title="diffuse"></a>diffuse</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">diffuseInyersity=<span class="built_in">max</span>(<span class="built_in">dot</span>(<span class="built_in">normalize</span>(light.pos-FragPos),Normal),<span class="number">0</span>);</span><br><span class="line">vec3 diffuse=diffuseIntensity*<span class="built_in">texture</span>(material.diffuse,TexCoord).rgb*light.color;</span><br></pre></td></tr></table></figure>

<h4 id="specular-1"><a href="#specular-1" class="headerlink" title="specular"></a>specular</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> specularIntersity=<span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(<span class="built_in">normalize</span>(<span class="built_in">reflect</span>(-<span class="built_in">normalize</span>(light.pos-FragPos),uNormal)),dirToCamera),<span class="number">0</span>),material.shininess);</span><br><span class="line">  vec3 specular=specularIntersity*light.color*<span class="built_in">texture</span>(material.specular,TexCoord).rgb;</span><br></pre></td></tr></table></figure>

<h2 id="聚光灯"><a href="#聚光灯" class="headerlink" title="聚光灯"></a>聚光灯</h2><h4 id="主要光照信息-2"><a href="#主要光照信息-2" class="headerlink" title="主要光照信息"></a>主要光照信息</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LightSpot</span>&#123;</span><br><span class="line">  vec3 pos;</span><br><span class="line">  vec3 color;</span><br><span class="line">  vec3 dirToLight;<span class="comment">//有用</span></span><br><span class="line">    <span class="type">float</span> constant;</span><br><span class="line">    <span class="type">float</span> linear;</span><br><span class="line">    <span class="type">float</span> quadratic;</span><br><span class="line">  <span class="type">float</span> cosPhyInner;</span><br><span class="line">  <span class="type">float</span> cosPhyOutter;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><p>边缘模糊化，对比点光源需要会受角度影响</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vec3 result=<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//attenuation</span></span><br><span class="line"><span class="type">float</span> distances= <span class="built_in">length</span>(light.pos - FragPos);</span><br><span class="line"><span class="type">float</span> attenuation=<span class="number">1.0f</span>/(light.constant+light.linear*distances+light.quadratic*distances*distances);</span><br><span class="line"><span class="type">float</span> spotRatio=<span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> cosTheta=<span class="built_in">dot</span>(<span class="built_in">normalize</span>(FragPos-light.pos),<span class="number">-1.0f</span>*light.dirToLight);</span><br><span class="line"><span class="comment">//cosTheta=1;</span></span><br><span class="line"><span class="keyword">if</span>(cosTheta &gt; light.cosPhyInner)</span><br><span class="line">&#123;</span><br><span class="line">  spotRatio=<span class="number">1.0f</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(cosTheta &gt; light.cosPhyOutter)&#123;</span><br><span class="line">  <span class="comment">//spotRatio=1.0f-(cosTheta-light.cosPhyInner)/(light.cosPhyOutter-light.cosPhyInner);</span></span><br><span class="line">  spotRatio=(light.cosPhyOutter-cosTheta)/(light.cosPhyOutter - light.cosPhyInner);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">  spotRatio=<span class="number">0.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line">attenuation*=spotRatio;</span><br><span class="line"><span class="comment">//diffuse</span></span><br><span class="line"><span class="type">float</span> diffuseIntensity=<span class="built_in">max</span>(<span class="built_in">dot</span>(<span class="built_in">normalize</span>(light.pos-FragPos),uNormal),<span class="number">0</span>);</span><br><span class="line">vec3 diffuse=<span class="built_in">texture</span>(material.diffuse,TexCoord).rgb*light.color*diffuseIntensity;</span><br><span class="line">result+=diffuse;</span><br><span class="line"></span><br><span class="line"><span class="comment">//specular</span></span><br><span class="line"><span class="type">float</span> specularIntersity=<span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(<span class="built_in">normalize</span>(<span class="built_in">reflect</span>(-<span class="built_in">normalize</span>(light.pos-FragPos),uNormal)),dirToCamera),<span class="number">0</span>),material.shininess);</span><br><span class="line">vec3 specular = specularIntersity*<span class="built_in">texture</span>(material.specular,TexCoord).rgb*light.color;</span><br><span class="line">result+=specular;</span><br><span class="line"><span class="comment">//result*=attenuation;</span></span><br><span class="line">result*=spotRatio;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity升级管线的注意事项</title>
    <url>/2022/01/18/Unity%E5%8D%87%E7%BA%A7%E7%AE%A1%E7%BA%BF%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<blockquote>
<h1 id="升级渲染管线在PM中下载-Universal-RP"><a href="#升级渲染管线在PM中下载-Universal-RP" class="headerlink" title="升级渲染管线在PM中下载 Universal RP"></a>升级渲染管线在PM中下载 Universal RP</h1></blockquote>
<p>材质记得替，不如会出现洋红色</p>
<blockquote>
<h1 id="使用的简单的建模工具"><a href="#使用的简单的建模工具" class="headerlink" title="使用的简单的建模工具"></a>使用的简单的建模工具</h1></blockquote>
<h3 id="在pm包中有不错的东西"><a href="#在pm包中有不错的东西" class="headerlink" title="在pm包中有不错的东西"></a>在pm包中有不错的东西</h3><h3 id="在游戏中进行简单的建模可以用ProBuilder和Polybrush这两个包进行修改地形的顶点"><a href="#在游戏中进行简单的建模可以用ProBuilder和Polybrush这两个包进行修改地形的顶点" class="headerlink" title="在游戏中进行简单的建模可以用ProBuilder和Polybrush这两个包进行修改地形的顶点"></a>在游戏中进行简单的建模可以用ProBuilder和Polybrush这两个包进行修改地形的顶点</h3><h3 id="ProGrids做方格的校准"><a href="#ProGrids做方格的校准" class="headerlink" title="ProGrids做方格的校准"></a>ProGrids做方格的校准</h3>]]></content>
      <categories>
        <category>升级渲染管线</category>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>TA1.3人物扫光</title>
    <url>/2022/01/21/TA1.3%E4%BA%BA%E7%89%A9%E6%89%AB%E5%85%89/</url>
    <content><![CDATA[<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="边缘光"><a href="#边缘光" class="headerlink" title="边缘光"></a>边缘光</h2><p><img src="https://img-blog.csdnimg.cn/ae5ddfb6e8464ec0aa7ffeb6c7f1bf90.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">    </p>
<h2 id="流光"><a href="#流光" class="headerlink" title="流光"></a>流光</h2><p><img src="https://img-blog.csdnimg.cn/1ee1c9a1e9ad45809bdd840452952c77.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当一个三维向量补全为四维向量的时候，如果是点的话最后需要补成1.0，如果是向量的话需要补0.0</p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>TA1.2UnityShader入门</title>
    <url>/2022/01/10/TA1.2UnityShader%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h4 id="平铺和偏移"><a href="#平铺和偏移" class="headerlink" title="平铺和偏移"></a>平铺和偏移</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//properties</span></span><br><span class="line">_Texture(<span class="string">&quot;Texture&quot;</span>,<span class="number">2</span>D)=<span class="string">&quot;white&quot;</span>&#123;&#125;</span><br><span class="line"><span class="comment">//SubPass/Pass</span></span><br><span class="line">sampler2D _Texture;</span><br><span class="line">float4 _Texture_ST;	</span><br><span class="line">o.uv=v.uv*_Texture_ST.xy+_Texture_ST.zw;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="顶点坐标系MVP转换"><a href="#顶点坐标系MVP转换" class="headerlink" title="顶点坐标系MVP转换"></a>顶点坐标系MVP转换</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">float4 pos_world = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">float4 pos_view = mul(UNITY_MATRIX_V,pos_world);</span><br><span class="line">float4 pos_clip = mul(UNITY_MATRIX_P,pos_view);</span><br><span class="line">o.pos=pos_clip;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">o.pos=UnityObjectToClipPos(v.vertex);</span><br></pre></td></tr></table></figure>

<h4 id="CG变量用法"><a href="#CG变量用法" class="headerlink" title="CG变量用法"></a>CG变量用法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> = <span class="number">32</span><span class="comment">//坐标</span></span><br><span class="line">half = <span class="number">16</span><span class="comment">//uv，大部分向量</span></span><br><span class="line">fixed =<span class="number">8</span><span class="comment">//颜色</span></span><br></pre></td></tr></table></figure>

<h2 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h2><h3 id="面剔除"><a href="#面剔除" class="headerlink" title="面剔除"></a>面剔除</h3><h4 id="单独写死"><a href="#单独写死" class="headerlink" title="单独写死"></a>单独写死</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Cull off</span><br></pre></td></tr></table></figure>

<h4 id="在面板上显示"><a href="#在面板上显示" class="headerlink" title="在面板上显示"></a>在面板上显示</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[Enum(UnityEngine.Rendering.CullMode)]_CullMode(<span class="string">&quot;CullMode&quot;</span>,Float)=<span class="number">2</span><span class="comment">//Properties</span></span><br><span class="line">Cull [_CullMode]<span class="comment">//SubPass/Pass</span></span><br></pre></td></tr></table></figure>

<h3 id="图片铺在模型上"><a href="#图片铺在模型上" class="headerlink" title="图片铺在模型上"></a>图片铺在模型上</h3><p>图片将平铺到x与y组成的平面上</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">o.uv=v.vertex.xy*_Texture_ST.xy+_Texture_ST.zw;</span><br></pre></td></tr></table></figure>

<p>xy变成yx时</p>
<p>相当与x轴旋转180度y轴旋转-90度</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">o.uv=v.vertex.yx*_Texture_ST.xy+_Texture_ST.zw;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">float4 pos_world = mul(unity_ObjectToWorld, v.vertex);</span><br></pre></td></tr></table></figure>



<p>加面解决圆面失真的问题</p>
<h2 id="水波的制作"><a href="#水波的制作" class="headerlink" title="水波的制作"></a>水波的制作</h2><h3 id="先制作动态圆盘"><a href="#先制作动态圆盘" class="headerlink" title="先制作动态圆盘"></a>先制作动态圆盘</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_Float(<span class="string">&quot;Float&quot;</span>,Float)=<span class="number">0.0</span></span><br><span class="line">_Vector(<span class="string">&quot;Vector&quot;</span>,Vector)=(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">_Texture(<span class="string">&quot;Texture&quot;</span>,<span class="number">2</span>D)=<span class="string">&quot;white&quot;</span>&#123;&#125;<span class="comment">//Properties</span></span><br><span class="line">half gradient=tex2D(_Texture,i.uv+_Time.y*_Vector.xy).x;</span><br><span class="line">clip(gradient-_Float);</span><br><span class="line"><span class="keyword">return</span> gradient.xxxx;<span class="comment">//fragment</span></span><br></pre></td></tr></table></figure>

<h3 id="噪声"><a href="#噪声" class="headerlink" title="噪声"></a>噪声</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_NoiseTex(<span class="string">&quot;NoiseTex&quot;</span>,<span class="number">2</span>D)=<span class="string">&quot;white&quot;</span>&#123;&#125;<span class="comment">//Properties</span></span><br><span class="line">half noise=<span class="number">1.0f</span>-tex2D(_NoiseTex,i.uv+_Time.y*_Vector.wz).x;</span><br><span class="line">clip(gradient-_Float-noise);<span class="comment">//fragment</span></span><br></pre></td></tr></table></figure>

<h3 id="完善颜色-完整代码"><a href="#完善颜色-完整代码" class="headerlink" title="完善颜色,完整代码"></a>完善颜色,完整代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Shader<span class="string">&quot;MyShader/03shader&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties&#123;</span><br><span class="line">        _Float(<span class="string">&quot;Float&quot;</span>,Float)=<span class="number">0.0</span></span><br><span class="line">        _Range(<span class="string">&quot;Range&quot;</span>,Range(<span class="number">0</span>,<span class="number">1</span>))=<span class="number">0.0</span></span><br><span class="line">        _Vector(<span class="string">&quot;Vector&quot;</span>,Vector)=(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _Color(<span class="string">&quot;Color&quot;</span>,Color)=(<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>)</span><br><span class="line">        _Texture(<span class="string">&quot;Texture&quot;</span>,<span class="number">2</span>D)=<span class="string">&quot;white&quot;</span>&#123;&#125;</span><br><span class="line">        _NoiseTex(<span class="string">&quot;NoiseTex&quot;</span>,<span class="number">2</span>D)=<span class="string">&quot;white&quot;</span>&#123;&#125;</span><br><span class="line">        [Enum(UnityEngine.Rendering.CullMode)]_CullMode(<span class="string">&quot;CullMode&quot;</span>,Float)=<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        Pass&#123;</span><br><span class="line">            Cull [_CullMode]</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">            struct appdata&#123;</span><br><span class="line">                float4 vertex:POSITION;</span><br><span class="line">                float2 uv:TEXCOORD0;</span><br><span class="line">             <span class="comment">//   float4 color:COLOR;</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">                float4 pos:SV_POSITION;</span><br><span class="line">                float2 uv:TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            sampler2D _Texture;</span><br><span class="line">            float4 _Texture_ST;</span><br><span class="line">            <span class="keyword">float</span> _Float;</span><br><span class="line">            float4 _Vector;</span><br><span class="line">            sampler2D _NoiseTex;</span><br><span class="line">            float2 _NoiseTex_ST;</span><br><span class="line">            fixed4 _Color;</span><br><span class="line"></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                float4 pos_world = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">                float4 pos_view = mul(UNITY_MATRIX_V,pos_world);</span><br><span class="line">                float4 pos_clip = mul(UNITY_MATRIX_P,pos_view);</span><br><span class="line">                <span class="comment">//o.pos=pos_clip;</span></span><br><span class="line">                o.pos=UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv=v.uv.xy*_Texture_ST.xy+_Texture_ST.zw;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="function">half4 <span class="title">frag</span><span class="params">(v2f i)</span>:SV_Target</span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                half gradient=tex2D(_Texture,i.uv+_Time.y*_Vector.xy).x;</span><br><span class="line">                half noise=<span class="number">1.0f</span>-tex2D(_NoiseTex,i.uv+_Time.y*_Vector.wz).x;</span><br><span class="line">                clip(gradient-_Float-noise);</span><br><span class="line">                <span class="keyword">return</span> _Color;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="半透明混合"><a href="#半透明混合" class="headerlink" title="半透明混合"></a>半透明混合</h2><h3 id="参数意思"><a href="#参数意思" class="headerlink" title="参数意思"></a>参数意思</h3><table>
<thead>
<tr>
<th></th>
<th>one</th>
<th>此输入的值是 one。该值用于使用源或目标的颜色的值。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><code>Zero</code></td>
<td>此输入的值是 zero。该值用于删除源或目标值。</td>
</tr>
<tr>
<td></td>
<td><code>SrcColor</code></td>
<td>GPU 将此输入的值乘以源颜色值。</td>
</tr>
<tr>
<td></td>
<td><code>SrcAlpha</code></td>
<td>GPU 将此输入的值乘以源 Alpha 值。</td>
</tr>
<tr>
<td></td>
<td><code>DstColor</code></td>
<td>GPU 将此输入的值乘以帧缓冲区的源颜色值。</td>
</tr>
<tr>
<td></td>
<td><code>DstAlpha</code></td>
<td>GPU 将此输入的值乘以帧缓冲区的源 Alpha 值。</td>
</tr>
<tr>
<td></td>
<td><code>OneMinusSrcColor</code></td>
<td>GPU 将此输入的值乘以（1 - 源颜色）。</td>
</tr>
<tr>
<td></td>
<td><code>OneMinusSrcAlpha</code></td>
<td>GPU 将此输入的值乘以（1 - 源 Alpha）。</td>
</tr>
<tr>
<td></td>
<td><code>OneMinusDstColor</code></td>
<td>GPU 将此输入的值乘以（1 - 目标颜色）。</td>
</tr>
<tr>
<td></td>
<td><code>OneMinusDstAlpha</code></td>
<td>GPU 将此输入的值乘以（1 - 目标 Alpha）。</td>
</tr>
</tbody></table>
<h3 id="常见混合类型"><a href="#常见混合类型" class="headerlink" title="常见混合类型"></a>常见混合类型</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Blend SrcAlpha OneMinusSrcAlpha <span class="comment">// 传统透明度</span></span><br><span class="line">Blend SrcAlpha One</span><br><span class="line"><span class="comment">//以上两种常用</span></span><br><span class="line">Blend One OneMinusSrcAlpha <span class="comment">// 预乘透明度</span></span><br><span class="line">Blend One One <span class="comment">// 加法</span></span><br><span class="line">Blend OneMinusDstColor One <span class="comment">// 软加法</span></span><br><span class="line">Blend DstColor Zero <span class="comment">// 乘法</span></span><br><span class="line">Blend DstColor SrcColor <span class="comment">// 2x 乘法</span></span><br></pre></td></tr></table></figure>

<h3 id="代码修改"><a href="#代码修改" class="headerlink" title="代码修改"></a>代码修改</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Tags &#123; <span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;Transparent&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ZWrite Off</span><br><span class="line">Blend SrcAlpha One<span class="comment">//预乘透明度</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">half3 col=_Color.xyz*_Float;</span><br><span class="line">half alpha=saturate(tex2D(_Texture,i.uv).r*_Color.a*_Float);</span><br><span class="line"><span class="keyword">return</span> half4(col,alpha);</span><br></pre></td></tr></table></figure>

<h2 id="边缘光-fresnel-简版的菲涅尔方程"><a href="#边缘光-fresnel-简版的菲涅尔方程" class="headerlink" title="边缘光(fresnel)简版的菲涅尔方程"></a>边缘光(fresnel)简版的菲涅尔方程</h2><h3 id="菲涅尔边缘光实现"><a href="#菲涅尔边缘光实现" class="headerlink" title="菲涅尔边缘光实现"></a>菲涅尔边缘光实现</h3><p>口述： 菲涅耳系数=pow (1.0f-saturate(dot(世界坐标到局部坐标的法线向量,世界坐标的顶点到摄像头的单位向量)) ,梯度系数)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">o.normal_world=normalize( mul(float4(v.normal,<span class="number">0</span>),unity_WorldToObject));<span class="comment">//世界坐标到局部坐标的法线向量</span></span><br><span class="line">float4 pos_world = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">o.view_world=normalize(_WorldSpaceCameraPos.xyz-pos_world);<span class="comment">//世界坐标的顶点到摄像头的单位向量</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">float3 normal_world=normalize(i.normal_world);</span><br><span class="line">float3 view_world=normalize(i.view_world);<span class="comment">//光栅化后向量需要标准化</span></span><br><span class="line"><span class="keyword">float</span> NdotV=saturate(dot(normal_world,view_world));</span><br><span class="line">half3 col=_Color.xyz*_Float;</span><br><span class="line"><span class="keyword">float</span> fresnel=<span class="built_in">pow</span>(<span class="number">1.0f</span>-NdotV,_Rim);<span class="comment">//菲涅尔系数</span></span><br><span class="line">half alpha=saturate(_Float*fresnel);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> half4(col,alpha);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Pass&#123;</span><br><span class="line">    ZWrite Off</span><br><span class="line">    Blend SrcAlpha One<span class="comment">//预乘透明度</span></span><br><span class="line">    Cull [_CullMode]</span><br><span class="line">    CGPROGRAM</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">        float4 vertex:POSITION;</span><br><span class="line">        float2 uv:TEXCOORD0;</span><br><span class="line">        float3 normal:NORMAL;</span><br><span class="line">     <span class="comment">//   float4 color:COLOR;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">        float4 pos:SV_POSITION;</span><br><span class="line">        float2 uv:TEXCOORD0;</span><br><span class="line">        float3 normal_world:TEXCOORD1;</span><br><span class="line">        float3 view_world:TEXCOORD2;</span><br><span class="line">    &#125;;</span><br><span class="line">    sampler2D _Texture;</span><br><span class="line">    float4 _Texture_ST;</span><br><span class="line">    fixed4 _Color;</span><br><span class="line">    <span class="keyword">float</span> _Float;</span><br><span class="line">    <span class="keyword">float</span> _Rim;</span><br><span class="line">    <span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        v2f o;</span><br><span class="line">        o.pos=UnityObjectToClipPos(v.vertex);</span><br><span class="line">        o.normal_world=normalize( mul(float4(v.normal,<span class="number">0</span>),unity_WorldToObject));</span><br><span class="line">        float4 pos_world = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">        o.view_world=normalize(_WorldSpaceCameraPos.xyz-pos_world);</span><br><span class="line">        o.uv=v.uv*_Texture_ST.xy+_Texture_ST.zw;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">half4 <span class="title">frag</span><span class="params">(v2f i)</span>:SV_Target</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        float3 normal_world=normalize(i.normal_world);</span><br><span class="line">        float3 view_world=normalize(i.view_world);</span><br><span class="line">        <span class="keyword">float</span> NdotV=saturate(dot(normal_world,view_world));</span><br><span class="line">        half3 col=_Color.xyz*_Float;</span><br><span class="line">        <span class="keyword">float</span> fresnel=<span class="built_in">pow</span>(<span class="number">1.0f</span>-NdotV,_Rim);</span><br><span class="line">        half alpha=saturate(_Float*fresnel);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> half4(col,alpha);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="预先写深度"><a href="#预先写深度" class="headerlink" title="预先写深度"></a>预先写深度</h3><p><strong>修除内部透明小Bug，预先将前面的深度写入，但不写入颜色信息，用上面的pass第二遍时将后面的透明的给剔除掉，</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line">   	Cull Off </span><br><span class="line">   	ZWrite On <span class="comment">//深度写入</span></span><br><span class="line">   	ColorMask <span class="number">0</span><span class="comment">//不写颜色信息</span></span><br><span class="line">   	CGPROGRAM</span><br><span class="line">   	float4 _Color;</span><br><span class="line">   	<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert </span></span><br><span class="line">   	<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">   	<span class="function">float4 <span class="title">vert</span><span class="params">(float4 vertexPos : POSITION)</span> : SV_POSITION</span></span><br><span class="line"><span class="function">   	</span>&#123;</span><br><span class="line">   		<span class="keyword">return</span> UnityObjectToClipPos(vertexPos);</span><br><span class="line">   	&#125;</span><br><span class="line"></span><br><span class="line">   	<span class="function">float4 <span class="title">frag</span><span class="params">(<span class="keyword">void</span>)</span> : COLOR</span></span><br><span class="line"><span class="function">   	</span>&#123;</span><br><span class="line">   		<span class="keyword">return</span> _Color;</span><br><span class="line">   	&#125;</span><br><span class="line">   	ENDCG</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>计算机图形学</category>
        <category>Unity</category>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>TA1.4薄膜干涉效果</title>
    <url>/2022/01/22/TA1.4%E8%96%84%E8%86%9C%E5%B9%B2%E6%B6%89%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<blockquote>
<h1 id="薄膜干涉"><a href="#薄膜干涉" class="headerlink" title="薄膜干涉"></a>薄膜干涉</h1></blockquote>
<h2 id="材质捕捉效果（Material-Capture）"><a href="#材质捕捉效果（Material-Capture）" class="headerlink" title="材质捕捉效果（Material Capture）"></a>材质捕捉效果（Material Capture）</h2><p><strong>预览效果</strong></p>
<p><img src="https://img-blog.csdnimg.cn/56c243af89ed49898a5ee5130e2a0507.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_16,color_FFFFFF,t_70,g_se,x_16" alt="预览效果"></p>
<p><strong>ASE图</strong></p>
<p><img src="https://img-blog.csdnimg.cn/d923225abd084649b13c00901cb87279.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>将观察坐标系的顶点法线xy当作材质的uv，将材质图片根据坐标平埔视角坐标系下的模型上，缺点当模型处于视野边缘时会有破绽。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>Properties</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_MainTex (<span class="string">&quot;diffuse&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">  _MatCatAddTex (<span class="string">&quot;MatCatAdd&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">  _MatCatAddIntensity (<span class="string">&quot;MatCatAddIntensity&quot;</span>, Float) = <span class="number">0.35</span></span><br><span class="line"></span><br><span class="line">  _MatCatTex (<span class="string">&quot;MatCat&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">  _MatCatIntensity (<span class="string">&quot;MatCatIntensity&quot;</span>, Float) = <span class="number">5.0</span></span><br></pre></td></tr></table></figure>

<p>Pass</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sampler2D _MatCatAddTex;</span><br><span class="line">float4 _MatCatAddTex_ST;</span><br><span class="line"><span class="keyword">float</span> _MatCatAddIntensity;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sampler2D _MatCatTex;</span><br><span class="line">float4 _MatCatTex_ST;</span><br><span class="line"><span class="keyword">float</span> _MatCatIntensity;</span><br></pre></td></tr></table></figure>

<p>vert</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">o.normal_world = mul(float4(v.normal,<span class="number">0.0</span>) ,unity_WorldToObject);<span class="comment">//获取worldnormal</span></span><br></pre></td></tr></table></figure>

<p>frag</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fixed4 col_diffuse = tex2D(_MainTex, i.uv);</span><br><span class="line">half2 MatCat_uv = (mul(UNITY_MATRIX_V, half4(normal_world, <span class="number">0.0</span>)).xy + <span class="number">1.0f</span>) * <span class="number">0.5f</span>;</span><br><span class="line">fixed4 col_MatCatAdd = tex2D(_MatCatAddTex, MatCat_uv) * _MatCatAddIntensity;</span><br><span class="line">fixed4 col_MatCat = tex2D(_MatCatTex, MatCat_uv) * _MatCatIntensity;</span><br></pre></td></tr></table></figure>

<h2 id="Ramp填充里面的颜色"><a href="#Ramp填充里面的颜色" class="headerlink" title="Ramp填充里面的颜色"></a>Ramp填充里面的颜色</h2><p><strong>预览效果</strong></p>
<p><img src="https://img-blog.csdnimg.cn/4de55293ebc148d28909c8690ad9a1a9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><strong>过度颜色图</strong></p>
<p><img src="https://img-blog.csdnimg.cn/1e311d3cf2474411a1c39505009b610d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p><strong>ASE图</strong></p>
<p><img src="https://img-blog.csdnimg.cn/7d0955cba77744b8be275fa6c1b9f080.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>利用菲涅尔方程的经验，1.0f - saturate(dot(normal_world, view_dir))在x和y上得到的是单调连续数值</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>Properties</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_RampTex(<span class="string">&quot;Ramp&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>vart</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">float3 pos_world = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">o.view_world = normalize( _WorldSpaceCameraPos - pos_world );</span><br></pre></td></tr></table></figure>



<p>frag</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">half3 view_dir = normalize(i.view_world);</span><br><span class="line">half fresnel = <span class="number">1.0f</span> - saturate(dot(normal_world, view_dir));</span><br><span class="line">fixed4 col_Ramp = tex2D(_RampTex, half2(fresnel, <span class="number">0.5f</span>));</span><br></pre></td></tr></table></figure>



<h2 id="合并效果"><a href="#合并效果" class="headerlink" title="合并效果"></a>合并效果</h2><h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p><img src="https://img-blog.csdnimg.cn/6683c0fd1e1d4027be543f06e8e47de8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/89d2e4d09575407c9e6ea4d33677e259.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="ASE图"><a href="#ASE图" class="headerlink" title="ASE图"></a>ASE图</h3><p><img src="https://img-blog.csdnimg.cn/dc3628555216403f82d24ccc9a88feb6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unlit/MatCat1_Code&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;diffuse&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _MatCatAddTex (<span class="string">&quot;MatCatAdd&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _MatCatAddIntensity (<span class="string">&quot;MatCatAddIntensity&quot;</span>, Float) = <span class="number">0.35</span></span><br><span class="line"></span><br><span class="line">        _MatCatTex (<span class="string">&quot;MatCat&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _MatCatIntensity (<span class="string">&quot;MatCatIntensity&quot;</span>, Float) = <span class="number">5.0</span></span><br><span class="line">        _RampTex(<span class="string">&quot;Ramp&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 normal_world : TEXCOORD1;</span><br><span class="line">                float3 view_world : TEXCOORD2;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">            sampler2D _MatCatAddTex;</span><br><span class="line">            float4 _MatCatAddTex_ST;</span><br><span class="line">            <span class="keyword">float</span> _MatCatAddIntensity;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            sampler2D _MatCatTex;</span><br><span class="line">            float4 _MatCatTex_ST;</span><br><span class="line">            <span class="keyword">float</span> _MatCatIntensity;</span><br><span class="line">            </span><br><span class="line">            sampler2D _RampTex;</span><br><span class="line">            float4 _RampTex_ST;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span> <span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">                o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">                o.normal_world = mul(float4(v.normal,<span class="number">0.0</span>) ,unity_WorldToObject);</span><br><span class="line">                float3 pos_world = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">                o.view_world = normalize( _WorldSpaceCameraPos - pos_world );</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_Target</span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                half3 normal_world = normalize(i.normal_world);</span><br><span class="line">                fixed4 col;</span><br><span class="line">                <span class="comment">// MatCap</span></span><br><span class="line">                fixed4 col_diffuse = tex2D(_MainTex, i.uv);</span><br><span class="line">                half2 MatCat_uv = (mul(UNITY_MATRIX_V, half4(normal_world, <span class="number">0.0</span>)).xy + <span class="number">1.0f</span>) * <span class="number">0.5f</span>;</span><br><span class="line">                fixed4 col_MatCatAdd = tex2D(_MatCatAddTex, MatCat_uv) * _MatCatAddIntensity;</span><br><span class="line">                fixed4 col_MatCat = tex2D(_MatCatTex, MatCat_uv) * _MatCatIntensity;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">//Ramp</span></span><br><span class="line">                half3 view_dir = normalize(i.view_world);</span><br><span class="line">                half fresnel = <span class="number">1.0f</span> - saturate(dot(normal_world, view_dir));</span><br><span class="line">                fixed4 col_Ramp = tex2D(_RampTex, half2(fresnel, <span class="number">0.5f</span>));</span><br><span class="line"></span><br><span class="line">                col = col_diffuse * col_MatCat * col_Ramp;</span><br><span class="line">                col += col_MatCatAdd ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">               <span class="comment">// return fixed4(i.normal_world,0.0);</span></span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>TA1.5藤曼生长</title>
    <url>/2022/02/10/TA1.5%E8%97%A4%E6%9B%BC%E7%94%9F%E9%95%BF/</url>
    <content><![CDATA[<h1 id="藤曼生长"><a href="#藤曼生长" class="headerlink" title="藤曼生长"></a>藤曼生长</h1><p><strong>预览视图</strong></p>
<p><img src="https://img-blog.csdnimg.cn/239148c16c944873b02c02d3147cd67d.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/4606bf1634494bfb9d0af5015ae90502.png" alt="在这里插入图片描述"></p>
<p><strong>PBR材质下的效果</strong></p>
<p>显示更好看上ASE</p>
<p><img src="https://img-blog.csdnimg.cn/ba9a3e2dbcfc4bfdbb6771696810b7e0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/d1ea5f1eab5a4091b0baf36a3495df95.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/34ccd229561748c192f020f3b60c88c8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="简化版"><a href="#简化版" class="headerlink" title="简化版"></a>简化版</h2><p>可以乘以顶点法线向量可以实现物体的缩放，用一个UV图的权重控制不同位置缩放部分，可以形成藤曼的样子</p>
<h3 id="ASE"><a href="#ASE" class="headerlink" title="ASE"></a>ASE</h3><p><img src="https://img-blog.csdnimg.cn/cd32f8d0755c44bcb1671ecc6d91b26b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">_Grow(<span class="string">&quot;Grow&quot;</span>,Range(<span class="number">-1.0</span>,<span class="number">1.0</span>)) = <span class="number">0.0</span></span><br><span class="line">_Expend(<span class="string">&quot;Expend&quot;</span>,Float) = <span class="number">0.0</span></span><br><span class="line">_Scale(<span class="string">&quot;Scale&quot;</span>,Float) = <span class="number">0.0</span></span><br><span class="line">_GrowMin(<span class="string">&quot;GrowMin&quot;</span>, Range(<span class="number">0</span>,<span class="number">1.0</span>)) = <span class="number">0.6</span></span><br><span class="line">_GrowMax(<span class="string">&quot;GrowMax&quot;</span>, Range(<span class="number">0</span>,<span class="number">1.5</span>)) = <span class="number">1.0</span></span><br><span class="line">_EndMin(<span class="string">&quot;EndMin&quot;</span>, Range(<span class="number">0</span>,<span class="number">1.0</span>)) = <span class="number">0.6</span></span><br><span class="line">_EndMax(<span class="string">&quot;EndMax&quot;</span>, Range(<span class="number">0</span>,<span class="number">1.5</span>)) = <span class="number">1.0</span> </span><br></pre></td></tr></table></figure>

<h4 id="appdata"><a href="#appdata" class="headerlink" title="appdata"></a>appdata</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">appdata</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 normal:NORMAL;</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="vert"><a href="#vert" class="headerlink" title="vert"></a>vert</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">v2f <span class="title">vert</span> <span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    half weight = max(smoothstep( _GrowMin, _GrowMax, v.uv.y - _Grow), smoothstep(_EndMin, _EndMax,v.uv.y ));</span><br><span class="line">    half3 weight_combine = weight * _Expend * <span class="number">0.01f</span>*v.normal;</span><br><span class="line">    half3 scale_combine = _Scale * <span class="number">0.01f</span> * v.normal;</span><br><span class="line">    half3 normal_combine = weight_combine + scale_combine;</span><br><span class="line">    v.vertex.xyz = v.vertex.xyz+ normal_combine;</span><br><span class="line">    o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="frag"><a href="#frag" class="headerlink" title="frag"></a>frag</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_Target</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    clip(<span class="number">1</span> - (i.uv.y - _Grow));</span><br><span class="line">    <span class="comment">// sample the texture</span></span><br><span class="line">    fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unlit/Vice1_Code&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Grow(<span class="string">&quot;Grow&quot;</span>,Range(<span class="number">-1.0</span>,<span class="number">1.0</span>)) = <span class="number">0.0</span></span><br><span class="line">        _Expend(<span class="string">&quot;Expend&quot;</span>,Float) = <span class="number">0.0</span></span><br><span class="line">        _Scale(<span class="string">&quot;Scale&quot;</span>,Float) = <span class="number">0.0</span></span><br><span class="line">        _GrowMin(<span class="string">&quot;GrowMin&quot;</span>, Range(<span class="number">0</span>,<span class="number">1.0</span>)) = <span class="number">0.6</span></span><br><span class="line">        _GrowMax(<span class="string">&quot;GrowMax&quot;</span>, Range(<span class="number">0</span>,<span class="number">1.5</span>)) = <span class="number">1.0</span></span><br><span class="line">        _EndMin(<span class="string">&quot;EndMin&quot;</span>, Range(<span class="number">0</span>,<span class="number">1.0</span>)) = <span class="number">0.6</span></span><br><span class="line">        _EndMax(<span class="string">&quot;EndMax&quot;</span>, Range(<span class="number">0</span>,<span class="number">1.5</span>)) = <span class="number">1.0</span> </span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line">            <span class="comment">// make fog work</span></span><br><span class="line">           </span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 normal:NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float2 uv : TEXCOORD0; </span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="keyword">float</span> _Grow;</span><br><span class="line">            <span class="keyword">float</span> _Expend;</span><br><span class="line">            <span class="keyword">float</span> _GrowMin;</span><br><span class="line">            <span class="keyword">float</span> _GrowMax;</span><br><span class="line">            <span class="keyword">float</span> _EndMin;</span><br><span class="line">            <span class="keyword">float</span> _EndMax;</span><br><span class="line">            <span class="keyword">float</span> _Scale;</span><br><span class="line">            <span class="function">v2f <span class="title">vert</span> <span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                half weight = max(smoothstep( _GrowMin, _GrowMax, v.uv.y - _Grow), smoothstep(_EndMin, _EndMax,v.uv.y ));</span><br><span class="line">                half3 weight_combine = weight * _Expend * <span class="number">0.01f</span>*v.normal;</span><br><span class="line">                half3 scale_combine = _Scale * <span class="number">0.01f</span> * v.normal;</span><br><span class="line">                half3 normal_combine = weight_combine + scale_combine;</span><br><span class="line">                v.vertex.xyz = v.vertex.xyz+ normal_combine;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_Target</span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                clip(<span class="number">1</span> - (i.uv.y - _Grow));</span><br><span class="line">                <span class="comment">// sample the texture</span></span><br><span class="line">                fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最近有一点偷懒，更新有点慢，新年快乐，新的一年，冲冲冲；</p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>TA1.6魔镜世界</title>
    <url>/2022/02/13/TA1.6%E9%AD%94%E9%95%9C%E4%B8%96%E7%95%8C/</url>
    <content><![CDATA[<h1 id="魔镜世界"><a href="#魔镜世界" class="headerlink" title="魔镜世界"></a>魔镜世界</h1><p><img src="https://img-blog.csdnimg.cn/708f8e4dc58e4eebb462a598386feb4b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/60384ee277de4032bb962961f62b6cce.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="渲染队列和颜色遮罩"><a href="#渲染队列和颜色遮罩" class="headerlink" title="渲染队列和颜色遮罩"></a>渲染队列和颜色遮罩</h2><h3 id="Rendering-Queue"><a href="#Rendering-Queue" class="headerlink" title="Rendering Queue"></a>Rendering Queue</h3><p>从小到大进行排序</p>
<p>几何体 2000</p>
<p>Alpha Test 2450</p>
<p>Transparent 3000</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;AlphaTest+10&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="Color-Mask"><a href="#Color-Mask" class="headerlink" title="Color Mask"></a>Color Mask</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ColorMask <span class="number">0</span></span><br><span class="line">ColorMask 相应的颜色通道</span><br></pre></td></tr></table></figure>



<h2 id="模板测试（Stencil）"><a href="#模板测试（Stencil）" class="headerlink" title="模板测试（Stencil）"></a>模板测试（Stencil）</h2><p>Reference 参数便于判端和筛选</p>
<p>Comparison 判断方式‘</p>
<p>Pass 面 通过之后的进行操作，图中是替换的意思</p>
<p>Fail 失败之后的操作</p>
<p>ZFail 深度测试失败的操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Stencil</span><br><span class="line">&#123;</span><br><span class="line">	Ref <span class="number">1</span></span><br><span class="line">	Comp always</span><br><span class="line">	Pass Replace</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="深度测试（Depth）"><a href="#深度测试（Depth）" class="headerlink" title="深度测试（Depth）"></a>深度测试（Depth）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ZWrite Off<span class="comment">//深度测试的开关</span></span><br><span class="line">ZTest Less<span class="comment">//深度小于当前缓存则通过</span></span><br><span class="line">ZTest Greater<span class="comment">//深度大于当前缓存则通过</span></span><br><span class="line">ZTest LEqual<span class="comment">//深度小于等于当前缓存则通过</span></span><br><span class="line">ZTest GEqual<span class="comment">//深度大于等于当前缓存则通过</span></span><br><span class="line">ZTest Equal<span class="comment">//深度等于当前缓存则通过</span></span><br><span class="line">ZTest NotEqual<span class="comment">//深度不等于当前缓存则通过</span></span><br><span class="line">ZTest Always<span class="comment">//不论如何都通过</span></span><br></pre></td></tr></table></figure>

<h2 id="制作过程"><a href="#制作过程" class="headerlink" title="制作过程"></a>制作过程</h2><h3 id="将材质导入dome"><a href="#将材质导入dome" class="headerlink" title="将材质导入dome"></a>将材质导入dome</h3><p>课程材料略</p>
<h3 id="制作镜子Shader"><a href="#制作镜子Shader" class="headerlink" title="制作镜子Shader"></a>制作镜子Shader</h3><h4 id="ASE图"><a href="#ASE图" class="headerlink" title="ASE图"></a>ASE图</h4><p><img src="https://img-blog.csdnimg.cn/24690538c7d74427947ec214b96eb3e9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/930c5704723d4d62824f52fb74543c7a.png" alt="在这里插入图片描述"></p>
<h4 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Tags &#123; <span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;AlphaTest+10&quot;</span>  &#125;</span><br><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">    ColorMask <span class="number">0</span></span><br><span class="line">    Stencil&#123;</span><br><span class="line">    Ref <span class="number">1</span></span><br><span class="line">    Comp always</span><br><span class="line">    Pass Replace</span><br><span class="line">    &#125;</span><br><span class="line">    ZWrite Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="制作镜内世界"><a href="#制作镜内世界" class="headerlink" title="制作镜内世界"></a>制作镜内世界</h3><h4 id="ASE图-1"><a href="#ASE图-1" class="headerlink" title="ASE图"></a>ASE图</h4><p><img src="https://img-blog.csdnimg.cn/846f665faf02464f9294ff2fc1919ac4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_10,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="核心代码-1"><a href="#核心代码-1" class="headerlink" title="核心代码"></a>核心代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Tags &#123; <span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;AlphaTest+20&quot;</span> &#125;</span><br><span class="line">Stencil&#123;</span><br><span class="line">	Ref <span class="number">1</span></span><br><span class="line">	Comp equal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="制作深度测试球"><a href="#制作深度测试球" class="headerlink" title="制作深度测试球"></a>制作深度测试球</h3><p>这一步是为了当模板测试未通过物体出现在魔镜后会出现在魔镜中的情况</p>
<p><img src="https://img-blog.csdnimg.cn/dfa1f68f67744d619a251839ec766106.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_13,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="ASE图-2"><a href="#ASE图-2" class="headerlink" title="ASE图"></a>ASE图</h4><p><img src="https://img-blog.csdnimg.cn/61e98110db744bd2afe357319cde1f6a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/1e5541da483f41b592e50bd9957dc801.png" alt="在这里插入图片描述"></p>
<h4 id="核心代码-2"><a href="#核心代码-2" class="headerlink" title="核心代码"></a>核心代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Tags &#123; <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;AlphaTest+15&quot;</span> &#125;</span><br><span class="line">	 LOD <span class="number">100</span></span><br><span class="line">	 Stencil&#123;</span><br><span class="line">	     Ref <span class="number">1</span></span><br><span class="line">	     Comp equal</span><br><span class="line">	 &#125;</span><br><span class="line">	 ZTest always</span><br></pre></td></tr></table></figure>

<h2 id="完成效果"><a href="#完成效果" class="headerlink" title="完成效果"></a>完成效果</h2><p><img src="https://img-blog.csdnimg.cn/ae35f733fb66487d8d5cbf13168e3b6f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>Shader的主要节点介绍</title>
    <url>/2022/02/20/Shader%E7%9A%84%E4%B8%BB%E8%A6%81%E8%8A%82%E7%82%B9%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>虽然学习很久了，但没有好好总结过shader用到的数学，以至于在用的过程中总是忘记，然后花时间去找，裂开，没有搞完的发现后后续补充。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="长度length-a"><a href="#长度length-a" class="headerlink" title="长度length(a)"></a>长度length(a)</h2><p>简单的欧式距离，根号下平方的那个。</p>
<h2 id="点乘dot（-a，b）"><a href="#点乘dot（-a，b）" class="headerlink" title="点乘dot（ a，b）"></a>点乘dot（ a，b）</h2><p>点乘是通过将对应分量逐个相乘，然后再把所得积相加来计算的。就是高中学的向量的乘法</p>
<p>v¯⋅k¯=||v¯||⋅||k¯||⋅cosθ</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(a1,a2,a3)⋅(b1,b2,b3)=a1*b1+a2* b2+a3*b3</span><br></pre></td></tr></table></figure>

<h3 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h3><p>当两个向量都是单位向量时就是两个向量的夹角的余弦值，常用于计算角度。</p>
<h2 id="叉乘cross（Lhs，Rhs）"><a href="#叉乘cross（Lhs，Rhs）" class="headerlink" title="叉乘cross（Lhs，Rhs）"></a>叉乘cross（Lhs，Rhs）</h2><p>叉乘只在3D空间中有定义，它需要两个不平行向量作为输入，生成一个正交于两个输入向量的第三个向量。如果输入的两个向量也是正交的，那么叉乘之后将会产生3个互相正交的向量。接下来的教程中这会非常有用。下面的图片展示了3D空间中叉乘的样子    ：</p>
<p><img src="https://learnopengl-cn.github.io/img/01/07/vectors_crossproduct.png" alt="叉乘图"></p>
<p><strong>注意：</strong>顺序在此运算符上很重要，因为 <strong>AxB</strong> 输出的结果与 <strong>BxA</strong> 不同（其结果类似于 <strong>-AxB</strong> ）。</p>
<p>c=cross（a,b）</p>
<p>c1=a2b3-a3b2</p>
<p>c2=a3b1-a1b3</p>
<p>c3=a1b2-a2b1</p>
<h3 id="用处-1"><a href="#用处-1" class="headerlink" title="用处"></a>用处</h3><p>得到两个向量做成平面的法向量；</p>
<h2 id="Saturate"><a href="#Saturate" class="headerlink" title="Saturate"></a>Saturate</h2><p>饱和节点输出在其上设置的向量的值或单个分量饱和到[0 1]范围。</p>
<ul>
<li><p><strong>0：</strong>如果输入小于 0，则返回此值</p>
</li>
<li><p><strong>输入：</strong>如果值介于 0 和 1 之间，则返回此值</p>
</li>
<li><p><strong>1：</strong>如果值大于 1，则返回此值</p>
<p><img src="http://amplify.pt/NodeDetail/SaturateGraphicNode.png"></p>
</li>
</ul>
<h2 id="线性插值lerf（a-b-weight）"><a href="#线性插值lerf（a-b-weight）" class="headerlink" title="线性插值lerf（a,b,weight）"></a>线性插值lerf（a,b,weight）</h2><p>公式(1-weight)×a+weight×b比较均匀，比较生硬</p>
<h2 id="clamp（input-min-max）"><a href="#clamp（input-min-max）" class="headerlink" title="clamp（input,min,max）"></a>clamp（input,min,max）</h2><p>Clamp 节点输出其输入值或夹紧在 Min， Max范围之间的矢量的各个分量。</p>
<ul>
<li><strong>最小值：</strong>如果输入值小于 Min，则返回此值</li>
<li><em><strong>输入：</strong></em>如果输入值介于最小值和最大值之间，则返回此值</li>
<li><strong>最大值：</strong>如果输入值大于 Max，则返回此值</li>
</ul>
<h2 id="平滑阶梯smoothstep-min-max-input"><a href="#平滑阶梯smoothstep-min-max-input" class="headerlink" title="平滑阶梯smoothstep(min,max,input)"></a>平滑阶梯smoothstep(min,max,input)</h2><p>Clamp 节点输出其输入值或夹紧在 Min， Max范围之间的矢量的各个分量。</p>
<ul>
<li><strong>最小值：</strong>如果输入值小于 Min，则返回0</li>
<li><em><strong>输入：</strong></em>如果输入值介于最小值和最大值之间，则返回clamp（（input-min）/（max-min），0，1）</li>
<li><strong>最大值：</strong>如果输入值大于 Max，则返回1</li>
</ul>
<p><img src="http://amplify.pt/NodeDetail/SmoothstepGraphicNode.png"></p>
<h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>还在总结中</p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>后处理技术（上）</title>
    <url>/2022/02/20/TA5%E5%90%8E%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF1/</url>
    <content><![CDATA[<h1 id="后处理（上）"><a href="#后处理（上）" class="headerlink" title="后处理（上）"></a>后处理（上）</h1><h2 id="启用后处理"><a href="#启用后处理" class="headerlink" title="启用后处理"></a>启用后处理</h2><p>在摄像头添加脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">[ExecuteInEditMode()]//编辑模式就能看到效果</span><br><span class="line">public class CameraPostPress : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public Material mat;</span><br><span class="line">    // Start is called before the first frame update</span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        if(mat==null||SystemInfo.supportsImageEffects==false||mat.shader==null||mat.shader.isSupported==false) &#123;</span><br><span class="line">            enabled = false;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void OnRenderImage(RenderTexture source, RenderTexture destination) &#123;</span><br><span class="line">        //当渲染图片启用   source是帧处理的图片 0是pass的顺序</span><br><span class="line">        Graphics.Blit(source,destination,mat, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="背景板"><a href="#背景板" class="headerlink" title="背景板"></a>背景板</h2><p><img src="https://img-blog.csdnimg.cn/d5c8641a1ca14b439e5c36b1b84949da.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>只要物体能拓展到屏幕上，就能让图片平铺到图片上，在片源部分做</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">half2 screen_uv = i.screen_pos.xy / (i.screen_pos.w + <span class="number">0.000001</span>);</span><br><span class="line">screen_uv = (screen_uv + <span class="number">1.0</span>) * <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure>

<p>注意的是dx的y轴是反的</p>
<p>有三套解决方案</p>
<h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">v2f <span class="title">vert</span> <span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    o.uv = v.uv;</span><br><span class="line">    o.screen_pos = o.vertex;</span><br><span class="line">    o.screen_pos.y = -o.screen_pos.y;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_Target</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    half2 screen_uv = i.screen_pos.xy / (i.screen_pos.w + <span class="number">0.000001</span>);</span><br><span class="line">    screen_uv = (screen_uv + <span class="number">1.0</span>) * <span class="number">0.5</span>; </span><br><span class="line">    <span class="comment">// sample the texture</span></span><br><span class="line">    fixed4 col = tex2D(_MainTex, screen_uv);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">v2f <span class="title">vert</span> <span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    o.uv = v.uv;</span><br><span class="line">    o.screen_pos = o.vertex;</span><br><span class="line">    o.screen_pos.y = o.screen_pos.y * _ProjectionParams.x;<span class="comment">//改变</span></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_Target</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    half2 screen_uv = i.screen_pos.xy / (i.screen_pos.w + <span class="number">0.000001</span>);</span><br><span class="line">    screen_uv = (screen_uv + <span class="number">1.0</span>) * <span class="number">0.5</span>;</span><br><span class="line">    <span class="comment">// sample the texture</span></span><br><span class="line">    fixed4 col = tex2D(_MainTex, screen_uv);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">v2f <span class="title">vert</span> <span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    o.uv = v.uv;</span><br><span class="line">    o.screen_pos=ComputeScreenPos(o.vertex);<span class="comment">//改变</span></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;<span class="function">c</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_Target</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    half2 screen_uv = i.screen_pos.xy / (i.screen_pos.w + <span class="number">0.000001</span>);</span><br><span class="line">       <span class="comment">//改变</span></span><br><span class="line">    <span class="comment">// sample the texture</span></span><br><span class="line">    fixed4 col = tex2D(_MainTex, screen_uv);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="背景板代码"><a href="#背景板代码" class="headerlink" title="背景板代码"></a>背景板代码</h3><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unlit/Quad&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            <span class="comment">// make fog work</span></span><br><span class="line">           </span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float4 screen_pos:TEXCOORD1;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = v.uv;</span><br><span class="line">                <span class="comment">//o.screen_pos = o.vertex;</span></span><br><span class="line">                <span class="comment">//o.screen_pos.y = -o.screen_pos.y;</span></span><br><span class="line">                o.screen_pos=ComputeScreenPos(o.vertex);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                half2 screen_uv = i.screen_pos.xy / (i.screen_pos.w + <span class="number">0.000001</span>);</span><br><span class="line">                screen_uv = (screen_uv + <span class="number">1.0</span>) * <span class="number">0.5</span>;</span><br><span class="line">                <span class="comment">// sample the texture</span></span><br><span class="line">                fixed4 col = tex2D(_MainTex, screen_uv);</span><br><span class="line">               </span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="调色"><a href="#调色" class="headerlink" title="调色"></a>调色</h2><p><img src="https://img-blog.csdnimg.cn/67f8be49624b4c17be5c5d3a4f3100d7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="ASE"><a href="#ASE" class="headerlink" title="ASE"></a>ASE</h3><p><img src="https://img-blog.csdnimg.cn/68a7f0f72c9645ff8b3eb0c407796880.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><h4 id="色调"><a href="#色调" class="headerlink" title="色调"></a>色调</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">float3 <span class="title">HSVToRGB</span><span class="params">(float3 c)</span> </span>&#123;</span><br><span class="line">    float4 K = float4(<span class="number">1.0</span>, <span class="number">2.0</span> / <span class="number">3.0</span>, <span class="number">1.0</span> / <span class="number">3.0</span>, <span class="number">3.0</span>);</span><br><span class="line">    float3 p = <span class="built_in">abs</span>(frac(c.xxx + K.xyz) * <span class="number">6.0</span> - K.www);</span><br><span class="line">    <span class="keyword">return</span> c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//RGB B*lerp(float3(1.0,1.0,1.0)) frac 取小数部分 色调（H），饱和度（S），明度（V）。</span></span><br><span class="line"><span class="comment">//H=B*lerp(1.0f,saturate(abs(frac(R + 1.0) * 6.0 - 3.0) - 1.0f),G)</span></span><br><span class="line"><span class="comment">//S=B*lerp(1.0f,saturate(abs(frac(R +  2.0 / 3.0) * 6.0 - 3.0) - 1.0f),G)</span></span><br><span class="line"><span class="comment">//V=B*lerp(1.0f,saturate(abs(frac(R +  1.0 / 3.0) * 6.0 - 3.0) - 1.0f),G)</span></span><br><span class="line"><span class="function">float3 <span class="title">RGBToHSV</span><span class="params">(float3 c)</span> </span>&#123;</span><br><span class="line">    float4 K = float4(<span class="number">0.0</span>, <span class="number">-1.0</span> / <span class="number">3.0</span>, <span class="number">2.0</span> / <span class="number">3.0</span>, <span class="number">-1.0</span>);</span><br><span class="line">    float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));</span><br><span class="line">    float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));</span><br><span class="line">    <span class="keyword">float</span> d = q.x - min(q.w, q.y);</span><br><span class="line">    <span class="keyword">float</span> e = <span class="number">1.0e-10</span>;</span><br><span class="line">    <span class="keyword">return</span> float3(<span class="built_in">abs</span>(q.z + (q.w - q.y) / (<span class="number">6.0</span> * d + e)), d / (q.x + e), q.x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="亮度"><a href="#亮度" class="headerlink" title="亮度"></a>亮度</h4><p>简单粗暴直接乘</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">col.rgb=col.rgb*_Brightness;</span><br></pre></td></tr></table></figure>

<h4 id="饱和度"><a href="#饱和度" class="headerlink" title="饱和度"></a>饱和度</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> lumin=dot(col.rgb,float3(<span class="number">0.22</span>,<span class="number">0.707</span>,<span class="number">0.071</span>));</span><br><span class="line">col.rgb=lerp(lumin,col.rgb,_Saturation);</span><br></pre></td></tr></table></figure>

<h4 id="对比度"><a href="#对比度" class="headerlink" title="对比度"></a>对比度</h4><p>float3(0.5,0.5,0.5)是灰色</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">col.rgb=lerp(float3(<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>),col.rgb,_Contrast);</span><br></pre></td></tr></table></figure>

<h4 id="暗角-晕影"><a href="#暗角-晕影" class="headerlink" title="暗角/晕影"></a>暗角/晕影</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">float2 d=<span class="built_in">abs</span>(i.uv<span class="number">-0.5</span>)*_VignetteIntensity;</span><br><span class="line">d=<span class="built_in">pow</span>(saturate(d),_VignetteRoundness);</span><br><span class="line"><span class="keyword">float</span> dist=length(d);</span><br><span class="line">col.rgb=<span class="built_in">pow</span>(saturate(<span class="number">1.0</span>-dist*dist),_VignetteSmoothness)*col.rgb;</span><br></pre></td></tr></table></figure>

<h3 id="调色代码"><a href="#调色代码" class="headerlink" title="调色代码"></a>调色代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Hidden/Color_Code&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Brightness(<span class="string">&quot;Brightness&quot;</span>, Float) = <span class="number">1</span></span><br><span class="line">        _Saturation(<span class="string">&quot;Saturation&quot;</span>,Float) = <span class="number">1</span></span><br><span class="line">        _Contrast(<span class="string">&quot;Contrast&quot;</span>,Float) = <span class="number">1</span></span><br><span class="line">        _VignetteIntensity(<span class="string">&quot;VignetteIntensity&quot;</span>,Range(<span class="number">0.05</span>,<span class="number">3.0</span>)) = <span class="number">1.5</span></span><br><span class="line">        _VignetteRoundness(<span class="string">&quot;VignetteRoundness&quot;</span>,Range(<span class="number">1</span>,<span class="number">6</span>)) = <span class="number">5</span></span><br><span class="line">        _VignetteSmoothness(<span class="string">&quot;VignetteSmoothness&quot;</span>,Range(<span class="number">0.05</span>,<span class="number">5</span>)) = <span class="number">5</span></span><br><span class="line">        _HueShift(<span class="string">&quot;HueShift&quot;</span>,Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// No culling or depth</span></span><br><span class="line">        Cull Off ZWrite Off ZTest Always</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> vertex vert_img</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">            float3 HSVToRGB(float3 c) &#123;</span><br><span class="line">                float4 K = float4(<span class="number">1.0</span>, <span class="number">2.0</span> / <span class="number">3.0</span>, <span class="number">1.0</span> / <span class="number">3.0</span>, <span class="number">3.0</span>);</span><br><span class="line">                float3 p = <span class="built_in">abs</span>(frac(c.xxx + K.xyz) * <span class="number">6.0</span> - K.www);</span><br><span class="line">                <span class="keyword">return</span> c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//RGB B*lerp(float3(1.0,1.0,1.0)) frac 取小数部分 色调（H），饱和度（S），明度（V）。</span></span><br><span class="line">            <span class="comment">//H=B*lerp(1.0f,saturate(abs(frac(R + 1.0) * 6.0 - 3.0) - 1.0f),G)</span></span><br><span class="line">            <span class="comment">//S=B*lerp(1.0f,saturate(abs(frac(R +  2.0 / 3.0) * 6.0 - 3.0) - 1.0f),G)</span></span><br><span class="line">            <span class="comment">//V=B*lerp(1.0f,saturate(abs(frac(R +  1.0 / 3.0) * 6.0 - 3.0) - 1.0f),G)</span></span><br><span class="line">            <span class="function">float3 <span class="title">RGBToHSV</span><span class="params">(float3 c)</span> </span>&#123;</span><br><span class="line">                float4 K = float4(<span class="number">0.0</span>, <span class="number">-1.0</span> / <span class="number">3.0</span>, <span class="number">2.0</span> / <span class="number">3.0</span>, <span class="number">-1.0</span>);</span><br><span class="line">                float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));</span><br><span class="line">                float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));</span><br><span class="line">                <span class="keyword">float</span> d = q.x - min(q.w, q.y);</span><br><span class="line">                <span class="keyword">float</span> e = <span class="number">1.0e-10</span>;</span><br><span class="line">                <span class="keyword">return</span> float3(<span class="built_in">abs</span>(q.z + (q.w - q.y) / (<span class="number">6.0</span> * d + e)), d / (q.x + e), q.x);</span><br><span class="line">            &#125;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            <span class="keyword">float</span> _Brightness;</span><br><span class="line">            <span class="keyword">float</span> _Saturation;</span><br><span class="line">            <span class="keyword">float</span> _Contrast;</span><br><span class="line">            <span class="keyword">float</span> _VignetteIntensity;</span><br><span class="line">            <span class="keyword">float</span> _VignetteRoundness;</span><br><span class="line">            <span class="keyword">float</span> _VignetteSmoothness;</span><br><span class="line">            <span class="keyword">float</span> _HueShift;</span><br><span class="line"></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span> <span class="params">(v2f_img i)</span> : SV_Target</span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                </span><br><span class="line">                fixed4 sourse = tex2D(_MainTex, i.uv);</span><br><span class="line">                fixed4 col=sourse;</span><br><span class="line">                <span class="comment">//色相</span></span><br><span class="line">                fixed3 hsv = RGBToHSV(sourse.rgb);</span><br><span class="line">                hsv.r= hsv.r +_HueShift;</span><br><span class="line">                col.rgb=HSVToRGB(hsv);</span><br><span class="line">                <span class="comment">//亮度</span></span><br><span class="line">                col.rgb=col.rgb*_Brightness;</span><br><span class="line">                <span class="comment">//饱和度</span></span><br><span class="line">                <span class="keyword">float</span> lumin=dot(col.rgb,float3(<span class="number">0.22</span>,<span class="number">0.707</span>,<span class="number">0.071</span>));</span><br><span class="line">                col.rgb=lerp(lumin,col.rgb,_Saturation);</span><br><span class="line">                <span class="comment">//对比度</span></span><br><span class="line">                col.rgb=lerp(float3(<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>),col.rgb,_Contrast);</span><br><span class="line">                <span class="comment">//暗角/晕影</span></span><br><span class="line">                float2 d=<span class="built_in">abs</span>(i.uv<span class="number">-0.5</span>)*_VignetteIntensity;</span><br><span class="line"></span><br><span class="line">                d=<span class="built_in">pow</span>(saturate(d),_VignetteRoundness);</span><br><span class="line">                <span class="keyword">float</span> dist=length(d);</span><br><span class="line">                col.rgb=<span class="built_in">pow</span>(saturate(<span class="number">1.0</span>-dist*dist),_VignetteSmoothness)*col.rgb; </span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="破碎的玻璃"><a href="#破碎的玻璃" class="headerlink" title="破碎的玻璃"></a>破碎的玻璃</h2><p><img src="https://img-blog.csdnimg.cn/bdbfbc20fb5140fa916c22f3d7e11676.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="上玻璃"><a href="#上玻璃" class="headerlink" title="上玻璃"></a>上玻璃</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> aspect = _ScreenParams.x / _ScreenParams.y; <span class="comment">// x = width y = height z = 1 + 1.0/width w = 1 + 1.0/height</span></span><br><span class="line">float2 glass_uv = float2(i.uv.x * aspect, i.uv.y) * _GlassMask_ST.xy + _GlassMask_ST.zw;</span><br><span class="line"></span><br><span class="line">half glass_opacity = tex2D(_GlassMask, glass_uv).r;</span><br><span class="line">finalcolor = lerp(finalcolor, _GlassCrack.xxx, glass_opacity);</span><br></pre></td></tr></table></figure>

<h3 id="上法线"><a href="#上法线" class="headerlink" title="上法线"></a>上法线</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">half3 glass_normal = UnpackNormal(tex2D(_GlassNormal, glass_uv));</span><br></pre></td></tr></table></figure>

<h3 id="解决边缘法线贴图重影"><a href="#解决边缘法线贴图重影" class="headerlink" title="解决边缘法线贴图重影"></a>解决边缘法线贴图重影</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">half2 d = <span class="number">1.0</span> - smoothstep(<span class="number">0.95</span>,<span class="number">1</span>,<span class="built_in">abs</span>(i.uv * <span class="number">2.0</span> - <span class="number">1.0</span>));</span><br><span class="line">half vfactor = d.x * d.y;</span><br></pre></td></tr></table></figure>

<h3 id="解决法线贴图毛玻璃的问题"><a href="#解决法线贴图毛玻璃的问题" class="headerlink" title="解决法线贴图毛玻璃的问题"></a>解决法线贴图毛玻璃的问题</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">float2 d_mask = step(<span class="number">0.005</span>, <span class="built_in">abs</span>(glass_normal.xy));</span><br><span class="line"><span class="keyword">float</span> mask = d_mask.x * d_mask.y;</span><br><span class="line">half2 uv_distort = i.uv + glass_normal.xy * _Distort * vfactor * mask;</span><br><span class="line">half4 col = tex2D(_MainTex, uv_distort);</span><br></pre></td></tr></table></figure>

<h3 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Hidden/BrokenGlass&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">	Properties</span><br><span class="line">	&#123;</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">		_GlassMask(<span class="string">&quot;GlassMask&quot;</span>,<span class="number">2</span>D) = <span class="string">&quot;black&quot;</span>&#123;&#125;</span><br><span class="line">		_GlassCrack(<span class="string">&quot;GlassCrack&quot;</span>,Float) = <span class="number">1</span></span><br><span class="line">		_GlassNormal(<span class="string">&quot;GlassNormal&quot;</span>,<span class="number">2</span>D) = <span class="string">&quot;bump&quot;</span>&#123;&#125;</span><br><span class="line">		_Distort(<span class="string">&quot;Distort&quot;</span>,Float) = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// No culling or depth</span></span><br><span class="line">		Cull Off ZWrite Off ZTest Always</span><br><span class="line"></span><br><span class="line">		Pass</span><br><span class="line">		&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert_img</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">		</span><br><span class="line">			sampler2D _MainTex;</span><br><span class="line">			sampler2D _GlassMask;</span><br><span class="line">			float4 _GlassMask_ST;</span><br><span class="line">			<span class="keyword">float</span> _GlassCrack;</span><br><span class="line">			sampler2D _GlassNormal;</span><br><span class="line">			<span class="keyword">float</span> _Distort;</span><br><span class="line"></span><br><span class="line">			<span class="function">half4 <span class="title">frag</span> <span class="params">(v2f_img i)</span> : SV_Target</span></span><br><span class="line"><span class="function">			</span>&#123;</span><br><span class="line">				<span class="keyword">float</span> aspect = _ScreenParams.x / _ScreenParams.y; <span class="comment">// x = width y = height z = 1 + 1.0/width w = 1 + 1.0/height</span></span><br><span class="line">				float2 glass_uv = float2(i.uv.x * aspect, i.uv.y) * _GlassMask_ST.xy + _GlassMask_ST.zw;</span><br><span class="line"></span><br><span class="line">				half glass_opacity = tex2D(_GlassMask, glass_uv).r;</span><br><span class="line">				half3 glass_normal = UnpackNormal(tex2D(_GlassNormal, glass_uv));</span><br><span class="line"></span><br><span class="line">				half2 d = <span class="number">1.0</span> - smoothstep(<span class="number">0.95</span>,<span class="number">1</span>,<span class="built_in">abs</span>(i.uv * <span class="number">2.0</span> - <span class="number">1.0</span>));</span><br><span class="line">				half vfactor = d.x * d.y;</span><br><span class="line"></span><br><span class="line">				float2 d_mask = step(<span class="number">0.005</span>, <span class="built_in">abs</span>(glass_normal.xy));</span><br><span class="line">				<span class="keyword">float</span> mask = d_mask.x * d_mask.y;</span><br><span class="line"></span><br><span class="line">				half2 uv_distort = i.uv + glass_normal.xy * _Distort * vfactor * mask;</span><br><span class="line">				half4 col = tex2D(_MainTex, uv_distort);</span><br><span class="line">				half3 finalcolor = col.rgb;</span><br><span class="line">				finalcolor = lerp(finalcolor, _GlassCrack.xxx, glass_opacity);</span><br><span class="line">				<span class="keyword">return</span> float4(finalcolor,col.a);</span><br><span class="line">			&#125;</span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>后处理技术（中）</title>
    <url>/2022/02/22/TA5%E5%90%8E%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF2/</url>
    <content><![CDATA[<h1 id="模糊处理"><a href="#模糊处理" class="headerlink" title="模糊处理"></a>模糊处理</h1><p>本文章参考<a href="https://zhuanlan.zhihu.com/p/125744132">毛星云大佬的文章</a>学习，十分推荐看大佬的原文<img src="https://pic3.zhimg.com/80/v2-c2a9906331826e66f66ffda71192411a_720w.jpg"></p>
<p><strong>降采样是常见的优化性能的方法减少中间贴图的尺寸大小</strong></p>
<p><strong>产生的中间贴图一定要记得释放内存，否则造成内存泄漏</strong></p>
<p><strong>在for循环的中间贴图也要记得释放内存</strong></p>
<h1 id="课程的4种常用的模糊算法"><a href="#课程的4种常用的模糊算法" class="headerlink" title="课程的4种常用的模糊算法"></a>课程的4种常用的模糊算法</h1><h2 id="盒状模糊或均值模糊（Box-Blur）"><a href="#盒状模糊或均值模糊（Box-Blur）" class="headerlink" title="盒状模糊或均值模糊（Box Blur）"></a>盒状模糊或均值模糊（Box Blur）</h2><p>最简单的模糊方式，取一个2*2的卷积核，四个数权重都为0.25，取一个像素的四角的像素叠加乘0.25</p>
<p><img src="https://img-blog.csdnimg.cn/b3aa70f8bcb943be9a634b4a5b87acf4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>（-1，-1）（1，-1）（-1，1）（1，1）四个点位叠加除4；</p>
<p>当然卷积核的值可自己调</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="BoxBlur-cs"><a href="#BoxBlur-cs" class="headerlink" title="BoxBlur.cs"></a>BoxBlur.cs</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">[ExecuteInEditMode()]</span><br><span class="line">public class BoxBlur : MonoBehaviour &#123;</span><br><span class="line">    public Material material;</span><br><span class="line">    [Range(0, 10)]</span><br><span class="line">    public int _Iteration = 4;</span><br><span class="line">    [Range(0, 15)]</span><br><span class="line">    public float _BlurRadius = 5.0f;</span><br><span class="line">    [Range(1, 10)]</span><br><span class="line">    public float _DownSample = 2.0f;</span><br><span class="line"></span><br><span class="line">    void Start () &#123;</span><br><span class="line">        if (material == null || SystemInfo.supportsImageEffects == false</span><br><span class="line">            || material.shader == null || material.shader.isSupported == false)</span><br><span class="line">        &#123;</span><br><span class="line">            enabled = false;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void OnRenderImage(RenderTexture source, RenderTexture destination)</span><br><span class="line">    &#123;</span><br><span class="line">        int width = (int)(source.width / _DownSample);</span><br><span class="line">        int height = (int)(source.height / _DownSample);</span><br><span class="line">        RenderTexture RT1 = RenderTexture.GetTemporary(width,height);</span><br><span class="line">        RenderTexture RT2 = RenderTexture.GetTemporary(width, height);</span><br><span class="line"></span><br><span class="line">        Graphics.Blit(source, RT1);</span><br><span class="line"></span><br><span class="line">        material.SetVector(&quot;_BlurOffset&quot;, new Vector4(_BlurRadius / source.width, _BlurRadius / source.height, 0,0));</span><br><span class="line">        for (int i = 0; i &lt; _Iteration; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Graphics.Blit(RT1, RT2, material, 0);</span><br><span class="line">            Graphics.Blit(RT2, RT1, material, 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Graphics.Blit(RT1, destination);</span><br><span class="line"></span><br><span class="line">        //release</span><br><span class="line">        RenderTexture.ReleaseTemporary(RT1);</span><br><span class="line">        RenderTexture.ReleaseTemporary(RT2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="BoxBlur-shader"><a href="#BoxBlur-shader" class="headerlink" title="BoxBlur.shader"></a>BoxBlur.shader</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Hidden/BoxBlur&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">	CGINCLUDE</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">	sampler2D _MainTex;</span><br><span class="line">	float4 _BlurOffset;</span><br><span class="line"></span><br><span class="line">	<span class="function">half4 <span class="title">frag_BoxFilter_4Tap</span><span class="params">(v2f_img i)</span> : SV_Target</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		half4 d = _BlurOffset.xyxy * half4(<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">		half4 s = <span class="number">0</span>;</span><br><span class="line">		s += tex2D(_MainTex, i.uv + d.xy);</span><br><span class="line">		s += tex2D(_MainTex, i.uv + d.zy);</span><br><span class="line">		s += tex2D(_MainTex, i.uv + d.xw);</span><br><span class="line">		s += tex2D(_MainTex, i.uv + d.zw);</span><br><span class="line">		s *= <span class="number">0.25</span>;</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">half4 <span class="title">frag_BoxFilter_9Tap</span><span class="params">(v2f_img i)</span> : SV_Target</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//half4 d = _BlurOffset.xyxy * half4(-1,1,0,0);</span></span><br><span class="line">		half4 d = _BlurOffset.xyxy * half4(<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		half4 s = <span class="number">0</span>;</span><br><span class="line">		s = tex2D(_MainTex, i.uv);</span><br><span class="line"></span><br><span class="line">		s += tex2D(_MainTex, i.uv + d.xy);</span><br><span class="line">		s += tex2D(_MainTex, i.uv + d.zy);</span><br><span class="line">		s += tex2D(_MainTex, i.uv + d.xw);</span><br><span class="line">		s += tex2D(_MainTex, i.uv + d.zw);</span><br><span class="line"></span><br><span class="line">		s += tex2D(_MainTex, i.uv + half2(<span class="number">0.0</span>, d.w)); <span class="comment">// 0 1</span></span><br><span class="line">		s += tex2D(_MainTex, i.uv + half2(<span class="number">0.0</span>, d.y)); <span class="comment">// 0 -1</span></span><br><span class="line">		s += tex2D(_MainTex, i.uv + half2(d.z,<span class="number">0.0</span>)); <span class="comment">// 1 0</span></span><br><span class="line">		s += tex2D(_MainTex, i.uv + half2(d.x, <span class="number">0.0</span>)); <span class="comment">// -1 0</span></span><br><span class="line"></span><br><span class="line">		s = s/ <span class="number">9.0</span>;</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ENDCG</span><br><span class="line"></span><br><span class="line">	Properties</span><br><span class="line">	&#123;</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">		_BlurOffset(<span class="string">&quot;BlurOffset&quot;</span>,Float) = <span class="number">1</span> </span><br><span class="line">	&#125;</span><br><span class="line">	SubShader</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// No culling or depth</span></span><br><span class="line">		Cull Off ZWrite Off ZTest Always</span><br><span class="line">		<span class="comment">//0pass 4tap</span></span><br><span class="line">		Pass</span><br><span class="line">		&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert_img</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag_BoxFilter_4Tap</span></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//1pass 9tap</span></span><br><span class="line">		Pass</span><br><span class="line">		&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert_img</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag_BoxFilter_9Tap</span></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="高斯模糊（Gaussian-Blur）"><a href="#高斯模糊（Gaussian-Blur）" class="headerlink" title="高斯模糊（Gaussian Blur）"></a>高斯模糊（Gaussian Blur）</h2><p>特定的权重，离像素点越远权重越小</p>
<p>下图为高斯函数的3维图示：</p>
<p><img src="https://pic4.zhimg.com/80/v2-d6af23aafa14caec06b3a1790b6d92e3_720w.jpg"></p>
<p>0.05 0.25 0.40 0.25 0.05权值</p>
<p>和盒状模糊差不多，效果会好一点</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><h4 id="GaussianBlur-cs"><a href="#GaussianBlur-cs" class="headerlink" title="GaussianBlur.cs"></a>GaussianBlur.cs</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">[ExecuteInEditMode()]</span><br><span class="line">public class GaussianBlur : MonoBehaviour &#123;</span><br><span class="line">    public Material material;</span><br><span class="line">    [Range(0, 10)]</span><br><span class="line">    public int _Iteration = 4;</span><br><span class="line">    [Range(0, 15)]</span><br><span class="line">    public float _BlurRadius = 5.0f;</span><br><span class="line">    [Range(1, 10)]</span><br><span class="line">    public float _DownSample = 2.0f;</span><br><span class="line"></span><br><span class="line">    void Start () &#123;</span><br><span class="line">        if (material == null || SystemInfo.supportsImageEffects == false</span><br><span class="line">            || material.shader == null || material.shader.isSupported == false)</span><br><span class="line">        &#123;</span><br><span class="line">            enabled = false;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void OnRenderImage(RenderTexture source, RenderTexture destination)</span><br><span class="line">    &#123;</span><br><span class="line">        int width = (int)(source.width / _DownSample);</span><br><span class="line">        int height = (int)(source.height / _DownSample);</span><br><span class="line">        RenderTexture RT1 = RenderTexture.GetTemporary(width,height);</span><br><span class="line">        RenderTexture RT2 = RenderTexture.GetTemporary(width, height);</span><br><span class="line"></span><br><span class="line">        Graphics.Blit(source, RT1);</span><br><span class="line"></span><br><span class="line">        material.SetVector(&quot;_BlurOffset&quot;, new Vector4(_BlurRadius / source.width, _BlurRadius / source.height, 0,0));</span><br><span class="line">        for (int i = 0; i &lt; _Iteration; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Graphics.Blit(RT1, RT2, material, 0); //水平方向</span><br><span class="line">            Graphics.Blit(RT2, RT1, material, 1); //垂直方向</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Graphics.Blit(RT1, destination);</span><br><span class="line"></span><br><span class="line">        //release</span><br><span class="line">        RenderTexture.ReleaseTemporary(RT1);</span><br><span class="line">        RenderTexture.ReleaseTemporary(RT2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="GaussianBlur-shader"><a href="#GaussianBlur-shader" class="headerlink" title="GaussianBlur.shader"></a>GaussianBlur.shader</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Hidden/GaussianBlur&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">	CGINCLUDE</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">	sampler2D _MainTex;</span><br><span class="line">	float4 _BlurOffset;</span><br><span class="line"></span><br><span class="line">	<span class="function">half4 <span class="title">frag_HorizontalBlur</span><span class="params">(v2f_img i)</span> : SV_Target</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		half2 uv1 = i.uv + _BlurOffset.xy * half2(<span class="number">1</span>, <span class="number">0</span>) * <span class="number">-2.0</span>;</span><br><span class="line">		half2 uv2 = i.uv + _BlurOffset.xy * half2(<span class="number">1</span>, <span class="number">0</span>) * <span class="number">-1.0</span>;</span><br><span class="line">		half2 uv3 = i.uv;</span><br><span class="line">		half2 uv4 = i.uv + _BlurOffset.xy * half2(<span class="number">1</span>, <span class="number">0</span>) * <span class="number">1.0</span>;</span><br><span class="line">		half2 uv5 = i.uv + _BlurOffset.xy * half2(<span class="number">1</span>, <span class="number">0</span>) * <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line">		half4 s = <span class="number">0</span>;</span><br><span class="line">		s += tex2D(_MainTex, uv1) * <span class="number">0.05</span>;</span><br><span class="line">		s += tex2D(_MainTex, uv2) * <span class="number">0.25</span>;</span><br><span class="line">		s += tex2D(_MainTex, uv3) * <span class="number">0.40</span>;</span><br><span class="line">		s += tex2D(_MainTex, uv4) * <span class="number">0.25</span>;</span><br><span class="line">		s += tex2D(_MainTex, uv5) * <span class="number">0.05</span>;</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">half4 <span class="title">frag_VerticalBlur</span><span class="params">(v2f_img i)</span> : SV_Target</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		half2 uv1 = i.uv + _BlurOffset.xy * half2(<span class="number">0</span>, <span class="number">1</span>) * <span class="number">-2.0</span>;</span><br><span class="line">		half2 uv2 = i.uv + _BlurOffset.xy * half2(<span class="number">0</span>, <span class="number">1</span>) * <span class="number">-1.0</span>;</span><br><span class="line">		half2 uv3 = i.uv;</span><br><span class="line">		half2 uv4 = i.uv + _BlurOffset.xy * half2(<span class="number">0</span>, <span class="number">1</span>) * <span class="number">1.0</span>;</span><br><span class="line">		half2 uv5 = i.uv + _BlurOffset.xy * half2(<span class="number">0</span>, <span class="number">1</span>) * <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line">		half4 s = <span class="number">0</span>;</span><br><span class="line">		s += tex2D(_MainTex, uv1) * <span class="number">0.05</span>;</span><br><span class="line">		s += tex2D(_MainTex, uv2) * <span class="number">0.25</span>;</span><br><span class="line">		s += tex2D(_MainTex, uv3) * <span class="number">0.40</span>;</span><br><span class="line">		s += tex2D(_MainTex, uv4) * <span class="number">0.25</span>;</span><br><span class="line">		s += tex2D(_MainTex, uv5) * <span class="number">0.05</span>;</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ENDCG</span><br><span class="line"></span><br><span class="line">	Properties</span><br><span class="line">	&#123;</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">		_BlurOffset(<span class="string">&quot;BlurOffset&quot;</span>,Float) = <span class="number">1</span> </span><br><span class="line">	&#125;</span><br><span class="line">	SubShader</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// No culling or depth</span></span><br><span class="line">		Cull Off ZWrite Off ZTest Always</span><br><span class="line">		<span class="comment">//0</span></span><br><span class="line">		Pass</span><br><span class="line">		&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert_img</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag_HorizontalBlur</span></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//1</span></span><br><span class="line">		Pass</span><br><span class="line">		&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert_img</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag_VerticalBlur</span></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="双重模糊"><a href="#双重模糊" class="headerlink" title="双重模糊"></a>双重模糊</h2><p>双重的核心思想是先降采样，然后升采样。</p>
<p>相较于Kawase Blur在两个大小相等的纹理之间进行乒乓blit的的思路，Dual Kawase Blur的核心思路在于blit过程中进行降采样和升采样,即对RT进行了降采样以及升采样。如下图所示：</p>
<p><img src="https://pic4.zhimg.com/80/v2-4226f0fd81e3f2ed61b48995e269328f_720w.jpg"></p>
<h3 id="双重-Kawase-模糊（Dual-Kawase-Blur）"><a href="#双重-Kawase-模糊（Dual-Kawase-Blur）" class="headerlink" title="双重 Kawase 模糊（Dual Kawase Blur）"></a>双重 Kawase 模糊（Dual Kawase Blur）</h3><p>双重 Kawase 模糊和双重盒状模糊模糊是最常用的，前者常用于移动端，后者都行，两个的性能和质量都优于之前两种算法</p>
<h4 id="Kawase模糊"><a href="#Kawase模糊" class="headerlink" title="Kawase模糊"></a>Kawase模糊</h4><p>Kawase Blur的思路是对距离当前像素越来越远的地方对四个角进行采样</p>
<p><img src="https://pic4.zhimg.com/80/v2-5ef03cc98ed2ed9a22dee30ce2915e7f_720w.jpg"></p>
<p>所以中间的权重为4/8，其余四角为1/8；</p>
<p>单独的Kawase算法性能太差了，淘汰。</p>
<h4 id="Dual-Kawase-Blur"><a href="#Dual-Kawase-Blur" class="headerlink" title="Dual Kawase Blur"></a>Dual Kawase Blur</h4><p>Dual Kawase Blur，简称Dual Blur，是SIGGRAPH 2015上ARM团队提出的一种衍生自Kawase Blur的模糊算法。其由两种不同的Blur Kernel构成，如下图所示。<img src="https://pic1.zhimg.com/80/v2-1ae54eb0e154d542ff6acdae06232bdc_720w.jpg"></p>
<p><img src="https://img-blog.csdnimg.cn/e92e5664bde1419f830f6a0e5dc9b91a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>这个贴图怕是只有我看的懂了，图一的1图代表红色的框框，第二个代表整个框框</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><h4 id="DualKawaseBlur-cs"><a href="#DualKawaseBlur-cs" class="headerlink" title="DualKawaseBlur.cs"></a>DualKawaseBlur.cs</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line"></span><br><span class="line">[RequireComponent(typeof(Camera))]</span><br><span class="line">[ExecuteInEditMode]</span><br><span class="line"></span><br><span class="line">public class DualKawaseBlur : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    public Material material;</span><br><span class="line">    [Range(0,15)]</span><br><span class="line">    public float _BlurRadius = 5.0f;</span><br><span class="line">    [Range(0, 10)]</span><br><span class="line">    public int _Iteration = 4;</span><br><span class="line">    [Range(1, 10)]</span><br><span class="line">    public float _DownSample = 2.0f;</span><br><span class="line"></span><br><span class="line">    List&lt;RenderTexture&gt; _tempRTList = new List&lt;RenderTexture&gt;();</span><br><span class="line"></span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        if (!SystemInfo.supportsImageEffects || null == material ||</span><br><span class="line">           null == material.shader || !material.shader.isSupported)</span><br><span class="line">        &#123;</span><br><span class="line">            enabled = false;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void OnRenderImage(RenderTexture source, RenderTexture destination)</span><br><span class="line">    &#123;</span><br><span class="line">        int RTWidth = (int)(source.width / _DownSample);</span><br><span class="line">        int RTHeight = (int)(source.height / _DownSample);</span><br><span class="line">        RenderTexture RT1 = RenderTexture.GetTemporary(RTWidth, RTHeight, 0);</span><br><span class="line">        RenderTexture RT2 = null;</span><br><span class="line">        material.SetFloat(&quot;_Offset&quot;, _BlurRadius);</span><br><span class="line">        Graphics.Blit(source, RT1, material, 0);</span><br><span class="line">//降采样</span><br><span class="line">        for (int i = 0; i &lt; _Iteration; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            RenderTexture.ReleaseTemporary(RT2);</span><br><span class="line">            RTWidth = RTWidth / 2;</span><br><span class="line">            RTHeight = RTHeight / 2;</span><br><span class="line">            RT2 = RenderTexture.GetTemporary(RTWidth, RTHeight);</span><br><span class="line">            Graphics.Blit(RT1, RT2, material, 0);</span><br><span class="line"></span><br><span class="line">            RTWidth = RTWidth / 2;</span><br><span class="line">            RTHeight = RTHeight / 2;</span><br><span class="line">            RenderTexture.ReleaseTemporary(RT1);</span><br><span class="line">            RT1 = RenderTexture.GetTemporary(RTWidth, RTHeight);</span><br><span class="line">            Graphics.Blit(RT2, RT1, material, 0);</span><br><span class="line">        &#125;</span><br><span class="line">//升采样</span><br><span class="line">        for (int i = 0; i &lt; _Iteration; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            RenderTexture.ReleaseTemporary(RT2);</span><br><span class="line">            RTWidth = RTWidth * 2;</span><br><span class="line">            RTHeight = RTHeight * 2;</span><br><span class="line">            RT2 = RenderTexture.GetTemporary(RTWidth, RTHeight);</span><br><span class="line">            Graphics.Blit(RT1, RT2, material, 1);</span><br><span class="line"></span><br><span class="line">            RTWidth = RTWidth * 2;</span><br><span class="line">            RTHeight = RTHeight * 2;</span><br><span class="line">            RenderTexture.ReleaseTemporary(RT1);</span><br><span class="line">            RT1 = RenderTexture.GetTemporary(RTWidth, RTHeight);</span><br><span class="line">            Graphics.Blit(RT2, RT1, material, 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Graphics.Blit(RT1, destination, material, 1);</span><br><span class="line"></span><br><span class="line">        // release</span><br><span class="line">        RenderTexture.ReleaseTemporary(RT1);</span><br><span class="line">        RenderTexture.ReleaseTemporary(RT2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="DualKawaseBlur-shader"><a href="#DualKawaseBlur-shader" class="headerlink" title="DualKawaseBlur.shader"></a>DualKawaseBlur.shader</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Hidden/DualKawaseBlur&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">	CGINCLUDE</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">	uniform sampler2D _MainTex;</span><br><span class="line">	uniform float4 _MainTex_TexelSize;</span><br><span class="line">	uniform half _Offset;</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">v2f_DownSample</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		float4 pos: SV_POSITION;</span><br><span class="line">		float2 uv: TEXCOORD1;</span><br><span class="line">		float4 uv01: TEXCOORD2;</span><br><span class="line">		float4 uv23: TEXCOORD3;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">v2f_UpSample</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		float4 pos: SV_POSITION;</span><br><span class="line">		float4 uv01: TEXCOORD1;</span><br><span class="line">		float4 uv23: TEXCOORD2;</span><br><span class="line">		float4 uv45: TEXCOORD3;</span><br><span class="line">		float4 uv67: TEXCOORD4;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function">v2f_DownSample <span class="title">Vert_DownSample</span><span class="params">(appdata_img v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		v2f_DownSample o;</span><br><span class="line">		o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">		</span><br><span class="line">		_MainTex_TexelSize = <span class="number">0.5</span> * _MainTex_TexelSize;</span><br><span class="line">		float2 uv = v.texcoord;</span><br><span class="line">		o.uv = uv;</span><br><span class="line">		o.uv01.xy = uv - _MainTex_TexelSize * float2(<span class="number">1</span> + _Offset, <span class="number">1</span> + _Offset);<span class="comment">//top right</span></span><br><span class="line">		o.uv01.zw = uv + _MainTex_TexelSize * float2(<span class="number">1</span> + _Offset, <span class="number">1</span> + _Offset);<span class="comment">//bottom left</span></span><br><span class="line">		o.uv23.xy = uv - float2(_MainTex_TexelSize.x, -_MainTex_TexelSize.y) * float2(<span class="number">1</span> + _Offset, <span class="number">1</span> + _Offset);<span class="comment">//top left</span></span><br><span class="line">		o.uv23.zw = uv + float2(_MainTex_TexelSize.x, -_MainTex_TexelSize.y) * float2(<span class="number">1</span> + _Offset, <span class="number">1</span> + _Offset);<span class="comment">//bottom right</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> o;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function">half4 <span class="title">Frag_DownSample</span><span class="params">(v2f_DownSample i)</span>: SV_Target</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		half4 sum = tex2D(_MainTex, i.uv) * <span class="number">4</span>;</span><br><span class="line">		sum += tex2D(_MainTex, i.uv01.xy);</span><br><span class="line">		sum += tex2D(_MainTex, i.uv01.zw);</span><br><span class="line">		sum += tex2D(_MainTex, i.uv23.xy);</span><br><span class="line">		sum += tex2D(_MainTex, i.uv23.zw);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> sum * <span class="number">0.125</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function">v2f_UpSample <span class="title">Vert_UpSample</span><span class="params">(appdata_img v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		v2f_UpSample o;</span><br><span class="line">		o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">	</span><br><span class="line">		float2 uv = v.texcoord;</span><br><span class="line">		</span><br><span class="line">		_MainTex_TexelSize = <span class="number">0.5</span> * _MainTex_TexelSize;</span><br><span class="line">		_Offset = float2(<span class="number">1</span> + _Offset, <span class="number">1</span> + _Offset);</span><br><span class="line">		</span><br><span class="line">		o.uv01.xy = uv + float2(-_MainTex_TexelSize.x * <span class="number">2</span>, <span class="number">0</span>) * _Offset;<span class="comment">//-2,0</span></span><br><span class="line">		o.uv01.zw = uv + float2(-_MainTex_TexelSize.x, _MainTex_TexelSize.y) * _Offset;<span class="comment">//-1 1</span></span><br><span class="line">		o.uv23.xy = uv + float2(<span class="number">0</span>, _MainTex_TexelSize.y * <span class="number">2</span>) * _Offset;<span class="comment">//0 2</span></span><br><span class="line">		o.uv23.zw = uv + _MainTex_TexelSize * _Offset;<span class="comment">//1 1</span></span><br><span class="line">		o.uv45.xy = uv + float2(_MainTex_TexelSize.x * <span class="number">2</span>, <span class="number">0</span>) * _Offset;<span class="comment">//2 0</span></span><br><span class="line">		o.uv45.zw = uv + float2(_MainTex_TexelSize.x, -_MainTex_TexelSize.y) * _Offset;<span class="comment">//1 -1</span></span><br><span class="line">		o.uv67.xy = uv + float2(<span class="number">0</span>, -_MainTex_TexelSize.y * <span class="number">2</span>) * _Offset;<span class="comment">//0 -2</span></span><br><span class="line">		o.uv67.zw = uv - _MainTex_TexelSize * _Offset;<span class="comment">// -1 -1</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> o;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function">half4 <span class="title">Frag_UpSample</span><span class="params">(v2f_UpSample i)</span>: SV_Target</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		half4 sum = <span class="number">0</span>;</span><br><span class="line">		sum += tex2D(_MainTex, i.uv01.xy);</span><br><span class="line">		sum += tex2D(_MainTex, i.uv01.zw) * <span class="number">2</span>;</span><br><span class="line">		sum += tex2D(_MainTex, i.uv23.xy);</span><br><span class="line">		sum += tex2D(_MainTex, i.uv23.zw) * <span class="number">2</span>;</span><br><span class="line">		sum += tex2D(_MainTex, i.uv45.xy);</span><br><span class="line">		sum += tex2D(_MainTex, i.uv45.zw) * <span class="number">2</span>;</span><br><span class="line">		sum += tex2D(_MainTex, i.uv67.xy);</span><br><span class="line">		sum += tex2D(_MainTex, i.uv67.zw) * <span class="number">2</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> sum * <span class="number">0.0833</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	ENDCG</span><br><span class="line">	Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex(<span class="string">&quot;&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	SubShader</span><br><span class="line">	&#123;</span><br><span class="line">		Cull Off ZWrite Off ZTest Always</span><br><span class="line">		</span><br><span class="line">		Pass</span><br><span class="line">		&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex Vert_DownSample</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment Frag_DownSample	</span></span><br><span class="line">			ENDCG		</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Pass</span><br><span class="line">		&#123;</span><br><span class="line">			CGPROGRAM	</span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex Vert_UpSample</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment Frag_UpSample</span></span><br><span class="line">			ENDCG</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双重盒状模糊（Dual-Box-Blur）"><a href="#双重盒状模糊（Dual-Box-Blur）" class="headerlink" title="双重盒状模糊（Dual Box Blur）"></a>双重盒状模糊（Dual Box Blur）</h4><p>对原来的Box进行双重采样就行，最常用的算法。</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><h4 id="DualBoxBlur-cs"><a href="#DualBoxBlur-cs" class="headerlink" title="DualBoxBlur.cs"></a>DualBoxBlur.cs</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">[ExecuteInEditMode()]</span><br><span class="line">public class DualBoxBlur : MonoBehaviour &#123;</span><br><span class="line">    public Material material;</span><br><span class="line">    [Range(0, 10)]</span><br><span class="line">    public int _Iteration = 4;</span><br><span class="line">    [Range(0, 15)]</span><br><span class="line">    public float _BlurRadius = 5.0f;</span><br><span class="line">    [Range(1, 10)]</span><br><span class="line">    public float _DownSample = 2.0f;</span><br><span class="line"></span><br><span class="line">    void Start () &#123;</span><br><span class="line">        if (material == null || SystemInfo.supportsImageEffects == false</span><br><span class="line">            || material.shader == null || material.shader.isSupported == false)</span><br><span class="line">        &#123;</span><br><span class="line">            enabled = false;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void OnRenderImage(RenderTexture source, RenderTexture destination)</span><br><span class="line">    &#123;</span><br><span class="line">        int width = (int)(source.width / _DownSample);</span><br><span class="line">        int height = (int)(source.height / _DownSample);</span><br><span class="line">        RenderTexture RT1 = RenderTexture.GetTemporary(width,height);</span><br><span class="line">        RenderTexture RT2 = RenderTexture.GetTemporary(width, height);</span><br><span class="line"></span><br><span class="line">        Graphics.Blit(source, RT1);</span><br><span class="line"></span><br><span class="line">        material.SetVector(&quot;_BlurOffset&quot;, new Vector4(_BlurRadius / source.width, _BlurRadius / source.height, 0,0));</span><br><span class="line">        //降采样</span><br><span class="line">        for (int i = 0; i &lt; _Iteration; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            RenderTexture.ReleaseTemporary(RT2);</span><br><span class="line">            width = width / 2;</span><br><span class="line">            height = height / 2;</span><br><span class="line">            RT2 = RenderTexture.GetTemporary(width, height);</span><br><span class="line">            Graphics.Blit(RT1, RT2, material, 0);</span><br><span class="line"></span><br><span class="line">            RenderTexture.ReleaseTemporary(RT1);</span><br><span class="line">            width = width / 2;</span><br><span class="line">            height = height / 2;</span><br><span class="line">            RT1 = RenderTexture.GetTemporary(width, height);</span><br><span class="line">            Graphics.Blit(RT2, RT1, material, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        //升采样</span><br><span class="line">        for (int i = 0; i &lt; _Iteration; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            RenderTexture.ReleaseTemporary(RT2);</span><br><span class="line">            width = width * 2;</span><br><span class="line">            height = height * 2;</span><br><span class="line">            RT2 = RenderTexture.GetTemporary(width, height);</span><br><span class="line">            Graphics.Blit(RT1, RT2, material, 0);</span><br><span class="line"></span><br><span class="line">            RenderTexture.ReleaseTemporary(RT1);</span><br><span class="line">            width = width * 2;</span><br><span class="line">            height = height * 2;</span><br><span class="line">            RT1 = RenderTexture.GetTemporary(width, height);</span><br><span class="line">            Graphics.Blit(RT2, RT1, material, 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Graphics.Blit(RT1, destination);</span><br><span class="line"></span><br><span class="line">        //release</span><br><span class="line">        RenderTexture.ReleaseTemporary(RT1);</span><br><span class="line">        RenderTexture.ReleaseTemporary(RT2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>就之前的BoxBlur.shader。</p>
<h1 id="其余算法"><a href="#其余算法" class="headerlink" title="其余算法"></a>其余算法</h1><p>可以参考毛星云大佬的其他算法。</p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>后处理技术（下）</title>
    <url>/2022/02/24/TA5%E5%90%8E%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF3/</url>
    <content><![CDATA[<h1 id="HDRBloom（光晕）"><a href="#HDRBloom（光晕）" class="headerlink" title="HDRBloom（光晕）"></a>HDRBloom（光晕）</h1><p>取亮光部分，进行降采样，在升采样的过程中，叠加降采样对应尺寸的图片，合并效果图和源图片</p>
<h2 id="初处理"><a href="#初处理" class="headerlink" title="初处理"></a>初处理</h2><p>如果放入的是HDR图片，可以在shader里面加float4 _MainTex_HDR;   col.rgb  = DecodeHDR(col,_MainTex_HDR);进行解码。</p>
<h2 id="取光亮部分"><a href="#取光亮部分" class="headerlink" title="取光亮部分"></a>取光亮部分</h2><p>先进行均值模糊，取亮色部分。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float intensity = Mathf.Exp(_Intensity / 10.0f * 0.693f) - 1.0f;</span><br><span class="line"></span><br><span class="line">mat.SetFloat(&quot;_Threshold&quot;, _Threshold);</span><br><span class="line">mat.SetFloat(&quot;_Intensity&quot;, intensity);</span><br><span class="line"></span><br><span class="line">//取亮色</span><br><span class="line">Graphics.Blit(source, RT_Down[0], mat, 0);</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">half4 <span class="title">frag_PreFilter</span><span class="params">(v2f_img i)</span> : SV_Target<span class="comment">//0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    half4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">    half4 d=_MainTex_TexelSize.xyxy*half4(<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">    col.rgb+=tex2D(_MainTex,i.uv+d.xy).rgb;</span><br><span class="line">    col.rgb+=tex2D(_MainTex,i.uv+d.zy).rgb;</span><br><span class="line">    col.rgb+=tex2D(_MainTex,i.uv+d.xw).rgb;</span><br><span class="line">    col.rgb+=tex2D(_MainTex,i.uv+d.zw).rgb;</span><br><span class="line">    col.rgb*=<span class="number">0.25</span>;</span><br><span class="line">    <span class="keyword">float</span> br = max(max(col.r,col.g),col.b);</span><br><span class="line">    br =  max(<span class="number">0</span>,(br - _Threshold))/max(<span class="number">0.00001</span>,br);</span><br><span class="line">    col.rgb*=br;</span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="降采样"><a href="#降采样" class="headerlink" title="降采样"></a>降采样</h2><p>用双重盒状模糊的降采样方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//降采样</span><br><span class="line">for(int i=0;i&lt;_Iteration;i++) &#123;//0-i-1</span><br><span class="line">    Graphics.Blit(RT_Down[i], RT_Down[i + 1], mat, 1);</span><br><span class="line">   // print(&quot;downcode &quot; + i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">half4 <span class="title">frag_DownsampleBox</span><span class="params">(v2f_img i)</span> : SV_Target<span class="comment">//1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    half4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">    half4 d=_MainTex_TexelSize.xyxy*half4(<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">    col.rgb+=tex2D(_MainTex,i.uv+d.xy).rgb;</span><br><span class="line">    col.rgb+=tex2D(_MainTex,i.uv+d.zy).rgb;</span><br><span class="line">    col.rgb+=tex2D(_MainTex,i.uv+d.xw).rgb;</span><br><span class="line">    col.rgb+=tex2D(_MainTex,i.uv+d.zw).rgb;</span><br><span class="line">    col.rgb*=<span class="number">0.25</span>;</span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="升采样"><a href="#升采样" class="headerlink" title="升采样"></a>升采样</h2><p>升采样过程中加同尺寸的降采样贴图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Graphics.Blit(RT_Down[_Iteration], RT_Up[_Iteration]);</span><br><span class="line">for(int i=_Iteration;i&gt;0;i--) &#123;</span><br><span class="line">    mat.SetTexture(&quot;_BloomTex&quot;, RT_Down[i-1]);</span><br><span class="line">    Graphics.Blit(RT_Up[i], RT_Up[i-1], mat, 2);</span><br><span class="line">    //print(&quot;upcode &quot; + i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">half4 <span class="title">frag_UpsampleBox</span><span class="params">(v2f_img i)</span> : SV_Target<span class="comment">//2</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    half4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">    half4 d=_MainTex_TexelSize.xyxy*half4(<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">    col.rgb+=tex2D(_MainTex,i.uv+d.xy).rgb;</span><br><span class="line">    col.rgb+=tex2D(_MainTex,i.uv+d.zy).rgb;</span><br><span class="line">    col.rgb+=tex2D(_MainTex,i.uv+d.xw).rgb;</span><br><span class="line">    col.rgb+=tex2D(_MainTex,i.uv+d.zw).rgb;</span><br><span class="line">    col.rgb*=<span class="number">0.25</span>;</span><br><span class="line">    half4 color2 = tex2D(_BloomTex, i.uv);</span><br><span class="line">    <span class="keyword">return</span> col + color2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>把升采样的最后一张图和原图合并,和释放贴图。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mat.SetTexture(&quot;_BloomTex&quot;, RT_Up[0]);</span><br><span class="line">Graphics.Blit(source, destination, mat, 3);</span><br><span class="line">//Release</span><br><span class="line">//RenderTexture.ReleaseTemporary(RT1);</span><br><span class="line">for (int i = 0; i &lt; _Iteration+1; i++) &#123;</span><br><span class="line">   // print(&quot;Release &quot; + i);</span><br><span class="line"></span><br><span class="line">    RenderTexture.ReleaseTemporary(RT_Down[i]);</span><br><span class="line">    RenderTexture.ReleaseTemporary(RT_Up[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">half4 <span class="title">frag_Combine</span><span class="params">(v2f_img i)</span> : SV_Target<span class="comment">//3</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    half4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">    half3 color1 = tex2D(_BloomTex, i.uv).rgb;</span><br><span class="line">    col.rgb+= color1.rgb*_Intensity;</span><br><span class="line">    <span class="keyword">return</span> col ;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h2 id="最后小瑕疵"><a href="#最后小瑕疵" class="headerlink" title="最后小瑕疵"></a>最后小瑕疵</h2><p>在光晕的周围还有点不自然。可用如下解决方案。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">float3 <span class="title">ACES_Tonemapping</span><span class="params">(float3 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> a = <span class="number">2.51f</span>;</span><br><span class="line">	<span class="keyword">float</span> b = <span class="number">0.03f</span>;</span><br><span class="line">	<span class="keyword">float</span> c = <span class="number">2.43f</span>;</span><br><span class="line">	<span class="keyword">float</span> d = <span class="number">0.59f</span>;</span><br><span class="line">	<span class="keyword">float</span> e = <span class="number">0.14f</span>;</span><br><span class="line">	float3 encode_color = saturate((x*(a*x + b)) / (x*(c*x + d) + e));</span><br><span class="line">	<span class="keyword">return</span> encode_color;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">half4 <span class="title">frag</span> <span class="params">(v2f_img i)</span> : SV_Target</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	half4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">	half3 linear_color = <span class="built_in">pow</span>(col.rgb, <span class="number">2.2</span>);</span><br><span class="line">	half3 encode_color = ACES_Tonemapping(linear_color);</span><br><span class="line">	half3 final_color = <span class="built_in">pow</span>(encode_color, <span class="number">1.0</span> / <span class="number">2.2</span>);</span><br><span class="line">	<span class="keyword">return</span> float4(final_color,col.a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="后处理的顺序"><a href="#后处理的顺序" class="headerlink" title="后处理的顺序"></a>后处理的顺序</h1><p><img src="https://img-blog.csdnimg.cn/3c671e3fee7c4999bd942e25acf1ea62.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>调整顺序：Bloom-&gt;Vignette-&gt;Tonemapping-&gt;ColorGrading</p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>TA2.1光照模型与法线贴图</title>
    <url>/2022/02/14/TA2.1%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="渲染路径"><a href="#渲染路径" class="headerlink" title="渲染路径"></a>渲染路径</h1><h2 id="前向渲染"><a href="#前向渲染" class="headerlink" title="前向渲染"></a>前向渲染</h2><p>对每一个物体每一个光源进行渲染，超出范围的灯光以顶点灯光渲染，适用于灯光较少的情况</p>
<h3 id="ForwardBase"><a href="#ForwardBase" class="headerlink" title="ForwardBase"></a>ForwardBase</h3><p>在这个Pass里面，主方向灯以及超出范围的灯光作为顶点灯光传入SH，   LightMap，Reflection， Probe等计算均在这个Pass里面完成。</p>
<h3 id="ForwardAdd"><a href="#ForwardAdd" class="headerlink" title="ForwardAdd"></a>ForwardAdd</h3><p>数量范围内的灯光，每个灯光的计算，均会调用一次这个pass，计算的结果通过Blend one one 叠加起来。</p>
<h2 id="延迟渲染"><a href="#延迟渲染" class="headerlink" title="延迟渲染"></a>延迟渲染</h2><p> 使用MRT技术 ，RT0是物体的颜色，RT1是金属反射的颜色，RT2是法线数据，RT4是深度信息。</p>
<p>光源直接渲染一次。有带宽和设备支持的限制，ue4和HDRP默认。</p>
<h1 id="法线贴图"><a href="#法线贴图" class="headerlink" title="法线贴图"></a>法线贴图</h1><h2 id="法线"><a href="#法线" class="headerlink" title="法线"></a>法线</h2><p>顶点垂直模型的线NORMAL</p>
<h2 id="切线"><a href="#切线" class="headerlink" title="切线"></a>切线</h2><p>UV中u递增的线或者v递增的线，引擎帮我们生成的TANGENT</p>
<h2 id="副切线"><a href="#副切线" class="headerlink" title="副切线"></a>副切线</h2><p> 法线叉乘切线得到的。</p>
<h1 id="unity的无光照shader获得光源信息实战"><a href="#unity的无光照shader获得光源信息实战" class="headerlink" title="unity的无光照shader获得光源信息实战"></a>unity的无光照shader获得光源信息实战</h1>]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>TA6特效篇火焰</title>
    <url>/2022/03/01/TA6%E7%89%B9%E6%95%88%E7%AF%87%E7%81%AB%E7%84%B0/</url>
    <content><![CDATA[<h1 id="火焰"><a href="#火焰" class="headerlink" title="火焰"></a>火焰</h1><h2 id="制作原理"><a href="#制作原理" class="headerlink" title="制作原理"></a>制作原理</h2><p>利用裁剪方程，将噪点图进行向上流动达到火焰往上升的效果，用一张渐变图和噪点图相乘把上半部分进行裁剪，将颜色的HDR效果打开，现在得到初步的火焰加一点点细节，让火的边缘柔和一点。让噪声图减去一个变量，并钳制在0到1之间，调大变量会使边缘柔和化，接下来是让火焰外焰和内焰效果</p>
<h2 id="噪点值"><a href="#噪点值" class="headerlink" title="噪点值"></a>噪点值</h2><p><img src="https://img-blog.csdnimg.cn/a9f0ed3772e7465785f1f268de05ebd6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>噪点图往上移动取R通道</p>
<h2 id="渐变值和内焰边界"><a href="#渐变值和内焰边界" class="headerlink" title="渐变值和内焰边界"></a>渐变值和内焰边界</h2><p><img src="https://img-blog.csdnimg.cn/a3ecd9c74d574044aed2fc070e609e02.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="火焰边缘柔和"><a href="#火焰边缘柔和" class="headerlink" title="火焰边缘柔和"></a>火焰边缘柔和</h2><p><img src="https://img-blog.csdnimg.cn/62b84b85d65440458541ed1d72f8b0e5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>当Softness变大边缘柔和，注意必须要clamp函数</p>
<h2 id="外焰和内焰"><a href="#外焰和内焰" class="headerlink" title="外焰和内焰"></a>外焰和内焰</h2><p><img src="https://img-blog.csdnimg.cn/6533e690f9c94cdca1192da8e6e0e94f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="火焰的形状"><a href="#火焰的形状" class="headerlink" title="火焰的形状"></a>火焰的形状</h2><p><img src="https://img-blog.csdnimg.cn/d483b0aebd7344f38b4a56ab74ab0838.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p><img src="https://img-blog.csdnimg.cn/4f00d42d98774071b79471a128aaf7f9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉计算观后感</title>
    <url>/2022/03/13/%E8%A7%86%E8%A7%89%E8%AE%A1%E7%AE%97%E8%A7%82%E5%90%8E%E6%84%9F/</url>
    <content><![CDATA[<h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h2 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h2><p>从样本数据提取数据，等距提取就是均匀采样，不等距就是非均匀采样。</p>
<h2 id="噪声"><a href="#噪声" class="headerlink" title="噪声"></a>噪声</h2><p>椒盐噪点可以用中值滤波器消除，有条纹状的噪声可以用陷波滤波器，比较细致模糊的噪点可以用低通滤波器</p>
<h1 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h1><h2 id="线性滤波器"><a href="#线性滤波器" class="headerlink" title="线性滤波器"></a>线性滤波器</h2><h3 id="全通"><a href="#全通" class="headerlink" title="全通"></a>全通</h3><p>没有消除和阻止任何一个频率。作用未知。</p>
<h3 id="低通"><a href="#低通" class="headerlink" title="低通"></a>低通</h3><p>使频率越来越宽，可以让图片变得模糊和达到消除噪点的作用</p>
<h4 id="盒式滤波器"><a href="#盒式滤波器" class="headerlink" title="盒式滤波器"></a>盒式滤波器</h4><p>使用全为1的卷积核。</p>
<h4 id="高斯滤波器"><a href="#高斯滤波器" class="headerlink" title="高斯滤波器"></a>高斯滤波器</h4><p>特定的权重，离像素点越远权重越小</p>
<p>下图为高斯函数的3维图示：</p>
<p><img src="https://pic4.zhimg.com/80/v2-d6af23aafa14caec06b3a1790b6d92e3_720w.jpg"></p>
<p>0.05 0.25 0.40 0.25 0.05权值</p>
<h4 id="降低频率采样"><a href="#降低频率采样" class="headerlink" title="降低频率采样"></a>降低频率采样</h4><p>n层：1 x 1</p>
<p>···</p>
<p>n-1层：pow(2,n-1) x pow(2,n-1)</p>
<p>n层：pow(2,n) x pow(2,n)</p>
<p>高斯金字塔</p>
<p>n-1层的一个网格对应相应的n层的4个网格</p>
<h4 id="卷积细节"><a href="#卷积细节" class="headerlink" title="卷积细节"></a>卷积细节</h4><ol>
<li>将滤波器与图像进行卷积时，要每个像素对齐非常重要，每个卷积的结果要单独保存，否则会影响之后的卷积结果</li>
<li>运算时先转化为浮点数再进行滤波最后滤波取整</li>
<li>如果颜色超过0，255设定最大值和最小值s</li>
</ol>
<h3 id="高通"><a href="#高通" class="headerlink" title="高通"></a>高通</h3><p>留下高频去除低频，能得到图形边缘特征。</p>
<p>如核为 -1/3 2/3 -1/3的卷积核。</p>
<h3 id="带通"><a href="#带通" class="headerlink" title="带通"></a>带通</h3><p>指留下低频和高频之间的信号。</p>
<h2 id="非线性滤波器"><a href="#非线性滤波器" class="headerlink" title="非线性滤波器"></a>非线性滤波器</h2><h3 id="中值滤波器"><a href="#中值滤波器" class="headerlink" title="中值滤波器"></a>中值滤波器</h3><p>去核范围的中值代替像素，去椒盐噪点的，还可以制作腐蚀或膨胀效果。</p>
<h1 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h1><h2 id="平移旋转放缩"><a href="#平移旋转放缩" class="headerlink" title="平移旋转放缩"></a>平移旋转放缩</h2><p><a href="https://learnopengl-cn.github.io/01%20Getting%20started/07%20Transformations/">opengl</a>里面有 就不看了</p>
<h2 id="透视变换"><a href="#透视变换" class="headerlink" title="透视变换"></a>透视变换</h2><p>裁剪距阵的推导<br><img src="https://img-blog.csdnimg.cn/c190892dadc14693a1333ea6a36d8882.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"><br>取用这个坐标系，所以w是0 0 -1 0<br>$$<br>∠theta=fov/2 ,A=  N * tan (theta),B=  F * tan (theta) \ A’=N=ACot(theta),B’=F=BCot(theta)<br>$$<br>所以Y轴是 0 cot(theta) 0 0。<br><img src="https://img-blog.csdnimg.cn/882a9c5831444a61ab5f8edf4f74d502.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"><br>ASP是宽高比</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">C=A<span class="emphasis">*ASP \\</span></span><br><span class="line"><span class="emphasis">D=B*</span>ASP \\</span><br><span class="line">C&#x27;=N=C<span class="emphasis">*Cot(theta) / ASP \\ </span></span><br><span class="line"><span class="emphasis">D&#x27;=F=D*</span>Cot(theta) / ASP</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>

<p>所以x是=Cot(theta)/ASP 0  0 0。</p>
<p>假设矩阵是线性的<br>$$<br>f(-N)=-N,f(-F)=F代入方程y=sx+o<br>$$<br>解方程组<br>$$<br>s=(f+n)/(n-f),o=2fn/(n-f)<br>$$<br>z是0 0 s o；</p>
<p>得透视矩阵如下</p>
<p> <img src="https://img-blog.csdnimg.cn/fc31696d20124d45ae3f5291895b5e7b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="光照"><a href="#光照" class="headerlink" title="光照"></a>光照</h1>]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>Games104第2节记录</title>
    <url>/2022/03/22/Games104%E7%AC%AC2%E8%8A%82%E8%AE%B0%E5%BD%95%20/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Tool Layer    给予开发者使用的工具</p>
<p>Function Layer </p>
<p>Resource Layer </p>
<p>Core Layer   核心层</p>
<p>Platform Layer 为了适应各种平台</p>
<p>越往上越灵活</p>
<p>越往下越稳定</p>
<p>怎样做一个animation system</p>
<h1 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h1><p>将其他资源转化为引擎的资产，引擎化。</p>
<p>需要加载进入游戏的文件</p>
<p>将文件全局资产编号GUID</p>
<p>Handle管理所有的资源周期</p>
<p>延迟加载</p>
<h1 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h1><h3 id="Tick循环"><a href="#Tick循环" class="headerlink" title="Tick循环"></a>Tick循环</h3><p><img src="https://img-blog.csdnimg.cn/2dffc93fd10c4dfb9970d5078b6dac01.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p><img src="https://img-blog.csdnimg.cn/4d4628dbec9a431a8142490ebdedb01b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="核心层"><a href="#核心层" class="headerlink" title="核心层"></a>核心层</h1><p>数学库，基本线代，取决于你系统的效率。</p>
<p>simd，如下四个数据一次性处理。</p>
<p><img src="https://img-blog.csdnimg.cn/722c5c5e526b4502908f0edbda47c868.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_13,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>数据结构，无内存碎片，查找效率高</p>
<p>Memory Management，有点像操作系统，进行更高效率的处理。</p>
<p><img src="https://img-blog.csdnimg.cn/ca185ca9c61c45d8ae83704cefc2d4aa.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="平台层"><a href="#平台层" class="headerlink" title="平台层"></a>平台层</h1><p>去除平台差异</p>
<p>比如将常用的GraphicsAPI抽象出来，用多态解决不同平台的问题。</p>
<h1 id="工具层"><a href="#工具层" class="headerlink" title="工具层"></a>工具层</h1><p>允许任何人可以创造游戏，开发效率优先。</p>
<p>数据的导入器导出器，能支持其他的3d软件资产</p>
<h1 id="简单ecs框架"><a href="#简单ecs框架" class="headerlink" title="简单ecs框架"></a>简单ecs框架</h1><p><img src="https://img-blog.csdnimg.cn/c9374d62177542dea5f17856cf4146df.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>引擎是分层架构的</p>
<p>越底层越稳定，越上层越灵活</p>
<p>通过Ticks进行驱动虚拟世界</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>引擎制作</tag>
      </tags>
  </entry>
</search>
