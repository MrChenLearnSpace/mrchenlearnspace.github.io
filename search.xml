<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>搭建博客</title>
    <url>/2021/11/01/Hollow/</url>
    <content><![CDATA[<h1 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h1><p>文档格式<br><strong>需要git，Node.js，npm</strong></p>
<h2 id="做好准备"><a href="#做好准备" class="headerlink" title="做好准备"></a>做好准备</h2><p>安装好软件，配置好相关的环境</p>
<p>建立一个github仓库，由于在部署时未设置配置建议改成 用户名.github.io,方便网站进入导致只打开一个html，与整个页面脱节的情况</p>
<h2 id="寻找材料"><a href="#寻找材料" class="headerlink" title="寻找材料"></a>寻找材料</h2><p>到Hexo中找相关喜欢的主题，并找到相应的开源的GitHub，先hexo init在空文件夹中初始化，导入相关主题，修改全局中的theme变量</p>
<h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p><a href="https://hexo.io/zh-cn/docs/configuration">https://hexo.io/zh-cn/docs/configuration</a><br>具体配置连接</p>
<p><strong>网站</strong></p>
<p>参数  ||    描述</p>
<p>title ||    网站标题</p>
<p>subtitle ||    网站副标题</p>
<p>description ||    网站描述</p>
<p>keywords ||    网站的关键词。支持多个关键词。</p>
<p>author ||    您的名字</p>
<p>language  ||    网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 zh-Hans和 zh-CN。</p>
<p>timezone ||    网站时区。Hexo 默认使用您电脑的时区。请参考 时区列表 进行设置，如 America/New_York, Japan, 和 UTC 。一般的，对于中国大陆地区可以使用 Asia/Shanghai。</p>
<p><strong>网址</strong></p>
<p>url    || 网址, 必须以 http:// 或 https:// 开头    </p>
<p>root ||    网站根目录    url’s pathname</p>
<p>permalink ||    文章的 永久链接 格式    :year/:month/:day/:title/</p>
<p>permalink_defaults ||     永久链接中各部分的默认值    </p>
<p>pretty_urls ||    改写 permalink 的值来美化 URL    </p>
<p>pretty_urls.trailing_index ||    是否在永久链接中保留尾部的index.html，设置为 false 时去除    true</p>
<p>pretty_urls.trailing_html    是否在永久链接中保留尾部的 .html, 设置为 false 时去除 (对尾部的 index.html无效)</p>
<p><em>网站存放在子目录<br>如果您的网站存放在子目录中，例如 <a href="http://example.com/blog%EF%BC%8C%E5%88%99%E8%AF%B7%E5%B0%86%E6%82%A8%E7%9A%84">http://example.com/blog，则请将您的</a> url 设为 <a href="http://example.com/blog">http://example.com/blog</a> 并把 root 设为 /blog/。</em><br><em>例如：# 比如，一个页面的永久链接是 <a href="http://example.com/foo/bar/index.html">http://example.com/foo/bar/index.html</a><br>pretty_urls:<br>  trailing_index: false<br>此时页面的永久链接会变为 <a href="http://example.com/foo/bar/">http://example.com/foo/bar/</a></em></p>
<p><strong>目录</strong><br>参数  ||    描述  ||    默认值</p>
<p>source_dir ||    资源文件夹，这个文件夹用来存放内容。||    source</p>
<p>public_dir ||    公共文件夹，这个文件夹用于存放生成的站点文件。||    public</p>
<p>tag_dir  ||    标签文件夹 ||    tags</p>
<p>archive_dir    归档文件夹    archives</p>
<p>category_dir    分类文件夹    categories</p>
<p>code_dir    Include code 文件夹，source_dir 下的子目录    downloads/code</p>
<p>i18n_dir    国际化（i18n）文件夹    :lang</p>
<p>skip_render    跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 public 目录中。您可使用 glob 表达式来匹配路径。</p>
<p><strong>文章</strong><br>参数    描述    默认值</p>
<p>new_post_name    新文章的文件名称    :title.md</p>
<p>default_layout    预设布局    post</p>
<p>auto_spacing    在中文和英文之间加入空格    false</p>
<p>titlecase    把标题转换为 title case    false</p>
<p>external_link    在新标签中打开链接    true</p>
<p>external_link.enable    在新标签中打开链接    true</p>
<p>external_link.field    对整个网站（site）生效或仅对文章（post）生效    site</p>
<p>external_link.exclude    需要排除的域名。主域名和子域名如 www 需分别配置    []</p>
<p>filename_case    把文件名称转换为 (1) 小写或 (2) 大写    0</p>
<p>render_drafts    显示草稿    false</p>
<p>post_asset_folder    启动 Asset 文件夹    false</p>
<p>relative_link    把链接改为与根目录的相对位址    false</p>
<p>future    显示未来的文章    true</p>
<p>highlight    代码块的设置, 请参考 Highlight.js 进行设置    </p>
<p>prismjs    代码块的设置, 请参考 PrismJS 进行设置</p>
<p><em>默认情况下，Hexo 生成的超链接都是绝对地址。例如，如果您的网站域名为 example.com,您有一篇文章名为 hello，那么绝对链接可能像这样：<a href="http://example.com/hello.html%EF%BC%8C%E5%AE%83%E6%98%AF%E7%BB%9D%E5%AF%B9%E4%BA%8E%E5%9F%9F%E5%90%8D%E7%9A%84%E3%80%82%E7%9B%B8%E5%AF%B9%E9%93%BE%E6%8E%A5%E5%83%8F%E8%BF%99%E6%A0%B7%EF%BC%9A/hello.html%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%EF%BC%8C%E6%97%A0%E8%AE%BA%E7%94%A8%E4%BB%80%E4%B9%88%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE%E8%AF%A5%E7%AB%99%E7%82%B9%EF%BC%8C%E9%83%BD%E6%B2%A1%E6%9C%89%E5%85%B3%E7%B3%BB%EF%BC%8C%E8%BF%99%E5%9C%A8%E8%BF%9B%E8%A1%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%97%B6%E5%8F%AF%E8%83%BD%E7%94%A8%E5%88%B0%E3%80%82%E9%80%9A%E5%B8%B8%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E7%BB%9D%E5%AF%B9%E5%9C%B0%E5%9D%80%E3%80%82">http://example.com/hello.html，它是绝对于域名的。相对链接像这样：/hello.html，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。</a></em></p>
<p><strong>分类 &amp; 标签</strong></p>
<p>参数    描述    默认值</p>
<p>default_category    默认分类    uncategorized</p>
<p>category_map    分类别名    </p>
<p>tag_map    标签别名    </p>
<p><strong>日期 / 时间格式</strong></p>
<p>参数    描述    默认值</p>
<p>date_format    日期格式    YYYY-MM-DD</p>
<p>time_format    时间格式    HH:mm:ss</p>
<p>updated_option    当 Front Matter 中没有指定 updated 时 updated 的取值    mtime</p>
<p>updated_option<br><em>updated_option 控制了当 Front Matter 中没有指定 updated 时，updated 如何取值：</em></p>
<p><em>mtime: 使用文件的最后修改时间。这是从 Hexo 3.0.0 开始的默认行为。</em><br><em>date: 使用 date 作为 updated 的值。可被用于 Git 工作流之中，因为使用 Git 管理站点时，文件的最后修改日期常常会发生改变</em><br><em>empty: 直接删除 updated。使用这一选项可能会导致大部分主题和插件无法正常工作。</em><br><em>use_date_for_updated 选项已经被废弃，将会在下个重大版本发布时去除。请改为使用 updated_option: ‘date’。</em></p>
<p><em>use_date_for_updated | 启用以后，如果 Front Matter 中没有指定 updated， post.updated 将会使用 date 的值而不是文件的创建时间。在 Git 工作流中这个选项会很有用 | true</em></p>
<p><strong>分页</strong></p>
<p>参数    描述    默认值</p>
<p>per_page    每页显示的文章量 (0 = 关闭分页功能)    10</p>
<p>pagination_dir    分页目录    page</p>
<p><strong>扩展</strong><br>参数    描述</p>
<p>theme    当前主题名称。值为false时禁用主题</p>
<p>theme_config    主题的配置文件。在这里放置的配置会覆盖主题目录下的 _config.yml 中的配置</p>
<p>deploy    部署部分的设置</p>
<p>meta_generator    Meta generator 标签。 值为 false 时 Hexo 不会在头部插入该标签</p>
<ul>
<li>*<h3 id="特别注意，记得修改配置中的连接和主题"><a href="#特别注意，记得修改配置中的连接和主题" class="headerlink" title="特别注意，记得修改配置中的连接和主题"></a>特别注意，记得修改配置中的连接和主题</h3></li>
<li>*</li>
</ul>
<h2 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h2><p>配置好配置中的部署部分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/MrChenLreanSpace/MrChenLreanSpace.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure>
<p>用 npm 安装好hexo-deployer-git.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git </span><br></pre></td></tr></table></figure>
<p>有些加入搜索功能，需要插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>配置hexo全局配置文件（请将生成的索引文件放在网站根目录或修改主题js文件的path值）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>
<p>在主题配置文件启用本地搜索</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#本地搜索,请将索引文件放在网站根目录</span><br><span class="line">local_search:</span><br><span class="line">    #是否启用</span><br><span class="line">    enable: true</span><br></pre></td></tr></table></figure>
<p>开始生成本地站点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<p>本地测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s 或者 hexo serve</span><br></pre></td></tr></table></figure>
<p>完成之后，连上github，需要GitHub的令牌，令牌生成后记得记住密钥，之后会看不到<br>令牌在设置的开发者选项中第三个第一次上传需要登入和用用户名和令牌连上账户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean&amp;&amp;hexo d</span><br></pre></td></tr></table></figure>
<p>清除本地文件且部署到GitHub上</p>
]]></content>
      <categories>
        <category>博客开始</category>
      </categories>
      <tags>
        <tag>标签和分类可以多个</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL学习之路之窗口的建立</title>
    <url>/2021/11/02/OpenGL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E7%AA%97%E5%8F%A3%E7%9A%84%E5%BB%BA%E7%AB%8B/</url>
    <content><![CDATA[<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>先建立一个空项目，建立一个c++文件，然后设置解决方案的属性设置三个位置<br><strong>第一是c&#x2F;c++\常规\附加包含目录加入include的文件夹，glfw和glew都需要，第二，链接器\常规\附加库目录，lib文件夹，第三，链接器\输入\附加依赖库，opengl32.lib glfw3.lib glew32s.lib</strong></p>
<h1 id="创建自己的引擎"><a href="#创建自己的引擎" class="headerlink" title="创建自己的引擎"></a>创建自己的引擎</h1><p>将文件修改为main作为主函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GLEW_STATIC</span></span><br></pre></td></tr></table></figure>
<p>这个注意小心拼写错误，本人搞了几小时</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="声明版本号"><a href="#声明版本号" class="headerlink" title="声明版本号"></a>声明版本号</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glfwInit</span>();</span><br><span class="line">  <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span><br></pre></td></tr></table></figure>
<p>MacOSX系统加上这一句<br>以上是初始化Glfw，说明我们要使用的OPENGL版本是3.3，我们同样明确告诉GLFW我们使用的是核心模式(Core-profile)。明确告诉GLFW我们需要使用核心模式意味着我们只能使用OpenGL功能的一个子集。</p>
<h3 id="创建窗口指针"><a href="#创建窗口指针" class="headerlink" title="创建窗口指针"></a>创建窗口指针</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;LearnOPENGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//前两个参数代表生成窗口大小</span></span><br></pre></td></tr></table></figure>
<h3 id="接下来进行GLFW的初始化"><a href="#接下来进行GLFW的初始化" class="headerlink" title="接下来进行GLFW的初始化"></a>接下来进行GLFW的初始化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;GLFW窗口初始化失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();<span class="comment">//程序终止函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(window);</span><br></pre></td></tr></table></figure>
<h3 id="然后是GLEW的初始化"><a href="#然后是GLEW的初始化" class="headerlink" title="然后是GLEW的初始化"></a>然后是GLEW的初始化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">glewExperimental = GL_TRUE;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;GLEW初始化失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="确定渲染窗口"><a href="#确定渲染窗口" class="headerlink" title="确定渲染窗口"></a>确定渲染窗口</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>);<span class="comment">//渲染窗口大小</span></span><br><span class="line"><span class="built_in">glfwSetFramebufferSizeCallback</span>(window,framebuffer_size_callback);<span class="comment">//注册函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>framebuffer_size_callback自定义函数注册到当窗口大小改变的事件中能及时反映</p>
<h3 id="确定基本架构"><a href="#确定基本架构" class="headerlink" title="确定基本架构"></a>确定基本架构</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(!<span class="built_in">glfwWindowShouldClose</span>(window))&#123;</span><br><span class="line">    <span class="comment">//输入</span></span><br><span class="line">    <span class="comment">//渲染指令</span></span><br><span class="line">    <span class="comment">//检查并调用事件，交换缓冲</span></span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);<span class="comment">//进行屏幕缓冲</span></span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();<span class="comment">//检查函数有没有触发事件	</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="清理缓冲区颜色"><a href="#清理缓冲区颜色" class="headerlink" title="清理缓冲区颜色"></a>清理缓冲区颜色</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);<span class="comment">//来设置清空屏幕所用的颜色,表示清除板的颜色</span></span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);<span class="comment">//清除颜色缓冲之后</span></span><br></pre></td></tr></table></figure>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">processInput</span>(window)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//输入</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) &#123;</span><br><span class="line">    <span class="built_in">glfwSetWindowShouldClose</span>(window, GLFW_TRUE);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GLEW_STATIC</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">glfwInit</span>();</span><br><span class="line">  <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line">  <span class="comment">//glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);MacOSX系统加上这一句</span></span><br><span class="line">  <span class="comment">//以上是初始化Glfw，说明我们要使用的OPENGL版本是3.3，我们同样明确告诉GLFW我们使用的是核心模式(Core-profile)。明确告诉GLFW我们需要使用核心模式意味着我们只能使用OpenGL功能的一个子集。</span></span><br><span class="line"></span><br><span class="line">  GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;LearnOPENGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//前两个参数代表生成窗口大小</span></span><br><span class="line">  <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;GLFW窗口初始化失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();<span class="comment">//程序终止函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">  <span class="comment">//GLFW初始化</span></span><br><span class="line">  glewExperimental = GL_TRUE;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;GLEW初始化失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//Glew的初始化</span></span><br><span class="line">  <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>);<span class="comment">//渲染窗口大小</span></span><br><span class="line">  <span class="built_in">glfwSetFramebufferSizeCallback</span>(window,framebuffer_size_callback);<span class="comment">//注册函数</span></span><br><span class="line">  <span class="keyword">while</span>(!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//输入</span></span><br><span class="line">    <span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//渲染指令</span></span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);<span class="comment">//来设置清空屏幕所用的颜色,表示清除板的颜色</span></span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);<span class="comment">//清除颜色缓冲之后</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查并调用事件，交换缓冲</span></span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);<span class="comment">//进行屏幕缓冲</span></span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();<span class="comment">//检查函数有没有触发事件</span></span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">glfwTerminate</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//输入</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) &#123;</span><br><span class="line">    <span class="built_in">glfwSetWindowShouldClose</span>(window, GLFW_TRUE);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL学习之路之三角形绘制</title>
    <url>/2021/11/02/OpenGL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E4%B8%89%E8%A7%92%E5%BD%A2%E7%BB%98%E5%88%B6/</url>
    <content><![CDATA[<p><strong>先从几何阶段取出顶点转换成vbo转到vao如果有重复顶点可以转到EBo<br>openGL是一个状态机只能运行context的状态只能放一个vao<br>状态机中必须要一个vao</strong></p>
<h3 id="VAO"><a href="#VAO" class="headerlink" title="VAO"></a>VAO</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> VAO;</span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);<span class="comment">//注意</span></span><br></pre></td></tr></table></figure>
<h3 id="VBO"><a href="#VBO" class="headerlink" title="VBO"></a>VBO</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> VBO;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);<span class="comment">//一个缓冲ID生成一个VBO对象建立顶点缓冲对象</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);<span class="comment">//新创建的缓冲绑定到GL_ARRAY_BUFFER目标</span></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);<span class="comment">//它会把之前定义的顶点数据复制到缓冲的内存中</span></span><br></pre></td></tr></table></figure>
<p>一定要绑定顶点数组</p>
<h3 id="shader"><a href="#shader" class="headerlink" title="shader"></a>shader</h3><p>顶点着色器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> vertexShader;</span><br><span class="line">vertexShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);<span class="comment">//由于我们正在创建一个顶点着色器，传递的参数是GL_VERTEX_SHADER</span></span><br><span class="line"><span class="built_in">glShaderSource</span>(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);<span class="comment">//这个着色器源码附加到着色器对象上</span></span><br><span class="line"><span class="built_in">glCompileShader</span>(vertexShader);<span class="comment">//编译着色器</span></span><br></pre></td></tr></table></figure>
<p>片段着色器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> fragmentShader;</span><br><span class="line">fragmentShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line"><span class="built_in">glShaderSource</span>(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glCompileShader</span>(fragmentShader);</span><br></pre></td></tr></table></figure>
<p>着色器程序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> shaderProgram;</span><br><span class="line">shaderProgram = <span class="built_in">glCreateProgram</span>();<span class="comment">//建立着色器程序对象</span></span><br><span class="line"><span class="built_in">glAttachShader</span>(shaderProgram, vertexShader);</span><br><span class="line"><span class="built_in">glAttachShader</span>(shaderProgram, fragmentShader);<span class="comment">//附加着色器</span></span><br><span class="line"><span class="built_in">glLinkProgram</span>(shaderProgram);<span class="comment">//连接着色器</span></span><br><span class="line"><span class="built_in">glDeleteShader</span>(vertexShader);<span class="comment">//着色器对象链接到程序对象以后，记得删除着色器对象，我们不再需要它们了</span></span><br><span class="line"><span class="built_in">glDeleteShader</span>(fragmentShader);</span><br></pre></td></tr></table></figure>
<p>序列化数据，可以得到数据的属性，是uv图片还是顶点信息</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>


<p>EBO的使用<br>需要加人索引<br>unsigned int indices[] &#x3D; { &#x2F;&#x2F; 注意索引从0开始!<br>    0, 1, 3, &#x2F;&#x2F; 第一个三角形<br>    1, 2, 3  &#x2F;&#x2F; 第二个三角形<br>};来确定三角形<br>放发与VBO类似当有点点区别<br>绑定缓存时GL_ELEMENT_ARRAY_BUFFER，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br></pre></td></tr></table></figure>
<p>绑定缓存数据的是索引值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure>
<p>在具体绘画过程中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);<span class="comment">//这是vao没有的</span></span><br></pre></td></tr></table></figure>
<p>用的函数也是和VAO绘制有区别的<br>三角形不用EBO的代码</p>
<p>四边形代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GLEW_STATIC</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CheckCompileShaderSuccess</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> vertexShader)</span></span>;<span class="comment">//检查着色器是否编译成功</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CheckLinkShaderSuccess</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> shaderProgram)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//float vertices[] = &#123;</span></span><br><span class="line"><span class="comment">//  -0.5f, -0.5f, 0.0f,</span></span><br><span class="line"><span class="comment">//   0.5f, -0.5f, 0.0f,</span></span><br><span class="line"><span class="comment">//   0.0f,  0.5f, 0.0f</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">  <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右上角</span></span><br><span class="line">  <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">  <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下角</span></span><br><span class="line">  <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// 左上角</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> indices[] = &#123; <span class="comment">// 注意索引从0开始! </span></span><br><span class="line">  <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="comment">// 第一个三角形</span></span><br><span class="line">  <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment">// 第二个三角形</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* vertexShaderSource =</span><br><span class="line"><span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="string">&quot;layout(location = 0) in vec3 aPos;\n&quot;</span></span><br><span class="line"><span class="string">&quot;void main()&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);&#125;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* fragmentShaderSource =</span><br><span class="line"><span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="string">&quot;out vec4 FragColor;\n;&quot;</span></span><br><span class="line"><span class="string">&quot;void main()&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;    FragColor=vec4(1.0f,0.5f,0.2f,1.0f);&#125;\n&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">glfwInit</span>();</span><br><span class="line">  <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line">  <span class="comment">//glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);MacOSX系统加上这一句</span></span><br><span class="line">  <span class="comment">//以上是初始化Glfw，说明我们要使用的OPENGL版本是3.3，我们同样明确告诉GLFW我们使用的是核心模式(Core-profile)。明确告诉GLFW我们需要使用核心模式意味着我们只能使用OpenGL功能的一个子集。</span></span><br><span class="line"></span><br><span class="line">  GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;LearnOPENGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//前两个参数代表生成窗口大小</span></span><br><span class="line">  <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;GLFW窗口初始化失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();<span class="comment">//程序终止函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">  <span class="comment">//GLFW初始化</span></span><br><span class="line">  glewExperimental = GL_TRUE;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;GLEW初始化失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//Glew的初始化</span></span><br><span class="line">  <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>);<span class="comment">//渲染窗口大小</span></span><br><span class="line">  <span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);<span class="comment">//注册函数</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> VAO;</span><br><span class="line">  <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">  <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">  <span class="comment">//顶点数据绑定</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> VBO;</span><br><span class="line">  <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);<span class="comment">//一个缓冲ID生成一个VBO对象建立顶点缓冲对象</span></span><br><span class="line">  <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);<span class="comment">//新创建的缓冲绑定到GL_ARRAY_BUFFER目标</span></span><br><span class="line">  <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);<span class="comment">//它会把之前定义的顶点数据复制到缓冲的内存中</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">unsigned</span> EBO;</span><br><span class="line">  <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;EBO);</span><br><span class="line">  <span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">  <span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//顶点着色器</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> vertexShader;</span><br><span class="line">  vertexShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);<span class="comment">//由于我们正在创建一个顶点着色器，传递的参数是GL_VERTEX_SHADER</span></span><br><span class="line">  <span class="built_in">glShaderSource</span>(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);<span class="comment">//这个着色器源码附加到着色器对象上</span></span><br><span class="line">  <span class="built_in">glCompileShader</span>(vertexShader);<span class="comment">//编译着色器</span></span><br><span class="line">  <span class="built_in">CheckCompileShaderSuccess</span>(vertexShader);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//片段着色器</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> fragmentShader;</span><br><span class="line">  fragmentShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line">  <span class="built_in">glShaderSource</span>(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">glCompileShader</span>(fragmentShader);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//着色器程序</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> shaderProgram;</span><br><span class="line">  shaderProgram = <span class="built_in">glCreateProgram</span>();<span class="comment">//建立着色器程序对象</span></span><br><span class="line">  <span class="built_in">glAttachShader</span>(shaderProgram, vertexShader);</span><br><span class="line">  <span class="built_in">glAttachShader</span>(shaderProgram, fragmentShader);<span class="comment">//附加着色器</span></span><br><span class="line">  <span class="built_in">glLinkProgram</span>(shaderProgram);<span class="comment">//连接着色器</span></span><br><span class="line">  <span class="built_in">CheckLinkShaderSuccess</span>(shaderProgram);</span><br><span class="line">  <span class="built_in">glDeleteShader</span>(vertexShader);<span class="comment">//着色器对象链接到程序对象以后，记得删除着色器对象，我们不再需要它们了</span></span><br><span class="line">  <span class="built_in">glDeleteShader</span>(fragmentShader);</span><br><span class="line">  <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//输入</span></span><br><span class="line">    <span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//渲染指令</span></span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);<span class="comment">//来设置清空屏幕所用的颜色,表示清除板的颜色</span></span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);<span class="comment">//清除颜色缓冲之后</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">glUseProgram</span>(shaderProgram);<span class="comment">//调用着色器</span></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">    <span class="comment">//glDrawArrays(GL_TRIANGLES, 0, 3);</span></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(EBO);</span><br><span class="line">    <span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);<span class="comment">//这是vao没有的</span></span><br><span class="line">    <span class="comment">//检查并调用事件，交换缓冲</span></span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);<span class="comment">//进行屏幕缓冲</span></span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();<span class="comment">//检查函数有没有触发事件</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">glfwTerminate</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//输入</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) &#123;</span><br><span class="line">    <span class="built_in">glfwSetWindowShouldClose</span>(window, GLFW_TRUE);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CheckCompileShaderSuccess</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> vertexShader)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//检查着色器是否编译成功</span></span><br><span class="line">  <span class="type">int</span> success;</span><br><span class="line">  <span class="type">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">  <span class="built_in">glGetShaderiv</span>(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">  <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">    <span class="built_in">glGetShaderInfoLog</span>(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CheckLinkShaderSuccess</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> shaderProgram)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//检查shaderProgram连接成功</span></span><br><span class="line">  <span class="type">int</span> success;</span><br><span class="line">  <span class="type">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">  <span class="built_in">glGetProgramiv</span>(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line">  <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">    <span class="built_in">glGetProgramInfoLog</span>(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::Program::Link_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/11/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>全景图传输</title>
    <url>/2022/03/21/%E5%85%A8%E6%99%AF%E5%9B%BE%E4%BC%A0%E8%BE%93/</url>
    <content><![CDATA[<h1 id="全景图"><a href="#全景图" class="headerlink" title="全景图"></a>全景图</h1><h2 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h2><h3 id="将全景图转变为Byte数组"><a href="#将全景图转变为Byte数组" class="headerlink" title="将全景图转变为Byte数组"></a>将全景图转变为Byte数组</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Camera.main.RenderToCubemap(cm);</span><br><span class="line">texture2D = <span class="keyword">new</span> Texture2D(width, hight);</span><br><span class="line">texture2D.SetPixels(cm.GetPixels(CubemapFace.NegativeZ));</span><br><span class="line">texture2D.Apply();</span><br><span class="line">byt = texture2D.EncodeToPNG();</span><br></pre></td></tr></table></figure>

<h3 id="将Byte数组变成全景图"><a href="#将Byte数组变成全景图" class="headerlink" title="将Byte数组变成全景图"></a>将Byte数组变成全景图</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">texture2DFix.LoadImage(byt);</span><br><span class="line">texture2DFix.Apply</span><br><span class="line">cm1.SetPixels(texture2DFix.GetPixels(), CubemapFace.PositiveZ);</span><br><span class="line">cm1.Apply();</span><br></pre></td></tr></table></figure>

<h3 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a>网络传输</h3><p>名字设为 I P 地址名</p>
<p>1.发送连接信号并在服务器创建位置</p>
<h3 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; width + <span class="number">1</span>; i++) Array.Copy(cmmcolors, width * (width - i), ReCmmcolors, width * (i - <span class="number">1</span>), width);<span class="comment">//上下翻转</span></span><br></pre></td></tr></table></figure>

<h3 id="协议处理"><a href="#协议处理" class="headerlink" title="协议处理"></a>协议处理</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">print(point.Right.Length);</span><br><span class="line">      <span class="built_in">string</span> str = pos.x.ToString() + <span class="string">&quot; &quot;</span> + pos.y.ToString() + <span class="string">&quot; &quot;</span> + pos.z.ToString() + <span class="string">&quot; &quot;</span> + <span class="string">&quot;PX &quot;</span>;</span><br><span class="line">      <span class="built_in">byte</span>[] bytstr= System.Text.Encoding.UTF8.GetBytes(str);<span class="comment">//单独编译</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">byte</span>[] sendByt = <span class="keyword">new</span> <span class="built_in">byte</span>[point.Right.Length+ bytstr.Length];</span><br><span class="line">      bytstr.CopyTo(sendByt, <span class="number">0</span>);</span><br><span class="line">      point.Right.CopyTo(sendByt, bytstr.Length);<span class="comment">//合并编码</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"> Texture2D = <span class="keyword">new</span> Texture2D(width, width);</span><br><span class="line"> <span class="built_in">byte</span>[] image = sendByt.Skip(bytstr.Length).ToArray();<span class="comment">//需要using System.Linq;//截取字节</span></span><br><span class="line"> print(image.Length);</span><br><span class="line"><span class="comment">// Array.Reverse(image);//可以使图像旋转180度</span></span><br><span class="line"> print(Texture2D.LoadImage(image));</span><br><span class="line"> Texture2D.Apply();<span class="number">5.4</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>

<h3 id="获取本地-I-P-地址"><a href="#获取本地-I-P-地址" class="headerlink" title="获取本地 I P 地址"></a>获取本地 I P 地址</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetLocalIp</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment"><span class="doctag">///</span>获取本地的IP地址</span></span><br><span class="line">       <span class="built_in">string</span> AddressIP = <span class="built_in">string</span>.Empty;</span><br><span class="line">       <span class="keyword">foreach</span> (IPAddress _IPAddress <span class="keyword">in</span> Dns.GetHostEntry(Dns.GetHostName()).AddressList)</span><br><span class="line">       &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (_IPAddress.AddressFamily.ToString() == <span class="string">&quot;InterNetwork&quot;</span>)</span><br><span class="line">           &#123;</span><br><span class="line"></span><br><span class="line">               AddressIP = _IPAddress.ToString();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> AddressIP;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="基本网络架构"><a href="#基本网络架构" class="headerlink" title="基本网络架构"></a>基本网络架构</h2><h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><p><img src="https://pica.zhimg.com/80/v2-e5925782976fc81a36cca0f889cec93a_720w.png"></p>
<h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CloudService</span>()</span> &#123;</span><br><span class="line">       msgHandle = <span class="keyword">new</span> MsgHandle();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">NewIndex</span>()</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (conns == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; conns.Length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (conns[i] == <span class="literal">null</span>) &#123;</span><br><span class="line">               conns[i] = <span class="keyword">new</span> Conn();</span><br><span class="line">               <span class="keyword">return</span> i;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (conns[i].isUse == <span class="literal">false</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> i;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ServiceStart</span>(<span class="params"><span class="built_in">string</span> host, <span class="built_in">int</span> port</span>)</span> &#123;</span><br><span class="line">       conns = <span class="keyword">new</span> Conn[maxConn];</span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; maxConn; i++) &#123;</span><br><span class="line">           conns[i] = <span class="keyword">new</span> Conn();</span><br><span class="line">       &#125;</span><br><span class="line">       Listerfd = <span class="keyword">new</span> Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);</span><br><span class="line">       IPAddress ipAdr = IPAddress.Parse(host);</span><br><span class="line">       IPEndPoint ipEp = <span class="keyword">new</span> IPEndPoint(ipAdr, port);</span><br><span class="line">       Listerfd.Bind(ipEp);</span><br><span class="line">       Listerfd.Listen(maxConn);</span><br><span class="line">       Listerfd.BeginAccept(AcceptCb, <span class="literal">null</span>);</span><br><span class="line">       status = <span class="literal">true</span>;</span><br><span class="line">       NetCloudServerManager.instance.debug.text+=(<span class="string">&quot;\n&quot;</span>+<span class="string">&quot;[服务器]启动成功&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Accept-Cb-异步监听"><a href="#Accept-Cb-异步监听" class="headerlink" title="Accept Cb 异步监听"></a>Accept Cb 异步监听</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AcceptCb</span>(<span class="params">IAsyncResult ar</span>)</span> &#123;</span><br><span class="line">        Socket socket = Listerfd.EndAccept(ar);<span class="comment">//要放在try外面</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//接收客户端</span></span><br><span class="line">            <span class="built_in">int</span> index = NewIndex();</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                socket.Close();</span><br><span class="line">                Debug.Log(<span class="string">&quot;[警告]连接已满&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Conn conn = conns[index];</span><br><span class="line">                conn.Init(socket);</span><br><span class="line">                <span class="built_in">string</span> host = conn.GetAdress();</span><br><span class="line">                Debug.Log(<span class="string">&quot;客户端连接:[&quot;</span> + host + <span class="string">&quot;] conn池ID:&quot;</span> + index);</span><br><span class="line">                conn.socket.BeginReceive(conn.readBuff, conn.buffCount, conn.BuffRemain(), SocketFlags.None, ReciveCb, conn);<span class="comment">//接收的同时调用ReciveCb回调函数</span></span><br><span class="line">            &#125;</span><br><span class="line">            Listerfd.BeginAccept(AcceptCb, <span class="literal">null</span>);<span class="comment">//再次调用AcceprCb回调函数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;AccpetCb 失败:&quot;</span> + e.Message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>出现莫名其妙的问题，等待异步需要放在 try 外面，不然会抛出 AcceptCb只能在主线程调用，要我放在awake和start中</p>
<h3 id="Recive-Cb异步接收"><a href="#Recive-Cb异步接收" class="headerlink" title="Recive Cb异步接收"></a>Recive Cb异步接收</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReciveCb</span>(<span class="params">IAsyncResult ar</span>)</span> &#123;</span><br><span class="line">        Conn conn = (Conn)ar.AsyncState;<span class="comment">//这个AsyncState就是上面那个BeginRecive函数里面最后一个参数</span></span><br><span class="line">        <span class="keyword">lock</span> (conn) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">int</span> count = conn.socket.EndReceive(ar);<span class="comment">//返回接收的字节数</span></span><br><span class="line">                                                       <span class="comment">//没有信息就关闭</span></span><br><span class="line">                <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    Debug.Log(<span class="string">&quot;收到[&quot;</span> + conn.GetAdress() + <span class="string">&quot;] 断开连接&quot;</span>);</span><br><span class="line">                    conn.Close();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                conn.buffCount += count;</span><br><span class="line">                ProcessData(conn);</span><br><span class="line">               </span><br><span class="line">                <span class="comment">//继续接收</span></span><br><span class="line">                conn.socket.BeginReceive(conn.readBuff, conn.buffCount, conn.BuffRemain(), SocketFlags.None, ReciveCb, conn);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Debug.Log(<span class="string">&quot;Recive失败&quot;</span> + e.Message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ProcessData</span>(<span class="params">Conn conn</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//小于字节长度</span></span><br><span class="line">        <span class="keyword">if</span> (conn.buffCount &lt; <span class="keyword">sizeof</span>(Int32)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Debug.Log(<span class="string">&quot;接收到了 &quot;</span> + conn.buffCount + <span class="string">&quot; 个字节&quot;</span>);</span><br><span class="line">        Array.Copy(conn.readBuff, conn.lenByte, <span class="keyword">sizeof</span>(Int32));</span><br><span class="line">        conn.msgLength = BitConverter.ToInt32(conn.lenByte, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//小于最小要求长度则返回表示未接收完全</span></span><br><span class="line">        <span class="keyword">if</span> (conn.buffCount &lt; conn.msgLength + <span class="keyword">sizeof</span>(Int32)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里接收信息有个细节，因为之前发送回来的信息又被加了一次长度，相当于要把他所有的信息接收完了</span></span><br><span class="line">        <span class="comment">//才算接收成功，然后再把前面的sizeof(Int32)去掉，剩下的就是带长度的信息了</span></span><br><span class="line">        ProtocolByte proto = <span class="keyword">new</span> ProtocolByte();</span><br><span class="line">        ProtocolByte protoStr = <span class="keyword">new</span> ProtocolByte();</span><br><span class="line">        ProtocolByte protocol = proto.Decode(conn.readBuff, <span class="keyword">sizeof</span>(Int32), conn.msgLength) <span class="keyword">as</span> ProtocolByte;</span><br><span class="line">        protoStr.AddString(conn.GetAdress());</span><br><span class="line">        protocol.bytes = protoStr.bytes.Concat(protocol.bytes).ToArray();</span><br><span class="line">        <span class="keyword">lock</span>(msgHandle.msgList) &#123;</span><br><span class="line">            msgHandle.msgList.Add(protocol);</span><br><span class="line">        &#125;</span><br><span class="line">        Debug.Log( protocol.GetDesc());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//清除已处理的消息</span></span><br><span class="line">        <span class="built_in">int</span> count = conn.buffCount - conn.msgLength - <span class="keyword">sizeof</span>(Int32);</span><br><span class="line">        Array.Copy(conn.readBuff, <span class="keyword">sizeof</span>(Int32) + conn.msgLength, conn.readBuff, <span class="number">0</span>, count);</span><br><span class="line">        conn.buffCount = count;</span><br><span class="line">        <span class="comment">//如果还有多余信息就继续处理</span></span><br><span class="line">        <span class="keyword">if</span> (conn.buffCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ProcessData(conn);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Conn类"><a href="#Conn类" class="headerlink" title="Conn类"></a>Conn类</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Conn</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">int</span> BUFFER_SIZE = <span class="number">16384</span>;</span><br><span class="line">    <span class="keyword">public</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isUse = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">byte</span>[] readBuff = <span class="keyword">new</span> <span class="built_in">byte</span>[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> buffCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> Int32 msgLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">byte</span>[] lenByte = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="keyword">sizeof</span>(Int32)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ProtocolByte assistProtolByte;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Conn</span>()</span> &#123;</span><br><span class="line">        readBuff = <span class="keyword">new</span> <span class="built_in">byte</span>[BUFFER_SIZE];</span><br><span class="line">        assistProtolByte = <span class="keyword">new</span> ProtocolByte();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params">Socket socket</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        isUse = <span class="literal">true</span>;</span><br><span class="line">        buffCount = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">BuffRemain</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BUFFER_SIZE - buffCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetAdress</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isUse) &#123; <span class="keyword">return</span> <span class="string">&quot;无法获取地址&quot;</span>; &#125;</span><br><span class="line">        <span class="keyword">return</span> socket.RemoteEndPoint.ToString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Close</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isUse) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;[断开连接]&quot;</span> + GetAdress());</span><br><span class="line">        socket.Close();</span><br><span class="line">        isUse = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">SendMsg</span>(<span class="params">ProtocolBase protol</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> proName = protol.GetName(); ;</span><br><span class="line">        <span class="keyword">return</span> SendMsg(protol, proName);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">SendMsg</span>(<span class="params">ProtocolBase protol, <span class="built_in">string</span> protolName</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        ProtocolByte protocolByte1 = <span class="keyword">new</span> ProtocolByte();</span><br><span class="line">        protocolByte1.AddString(protolName);</span><br><span class="line">        <span class="built_in">byte</span>[] protolNameByte = protocolByte1.bytes;</span><br><span class="line">        <span class="built_in">byte</span>[] b = protol.Encode();</span><br><span class="line">        <span class="built_in">byte</span>[] len1 = BitConverter.GetBytes(protolNameByte.Length + b.Length);</span><br><span class="line">        <span class="built_in">byte</span>[] sendByte = len1.Concat(protolNameByte).Concat(b).ToArray();</span><br><span class="line">        socket.Send(sendByte);</span><br><span class="line">        Debug.Log(<span class="string">&quot;sendByte &quot;</span> + sendByte.Length);</span><br><span class="line">        Debug.Log(<span class="string">&quot;sendBytes &quot;</span> + GetDesc(sendByte));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="built_in">string</span> <span class="title">GetDesc</span>(<span class="params"><span class="built_in">byte</span>[] bytes</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="literal">null</span>) <span class="keyword">return</span> str;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; bytes.Length; i++) &#123;</span><br><span class="line">            <span class="built_in">int</span> b = (<span class="built_in">int</span>)bytes[i];</span><br><span class="line">            str += b.ToString() + <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消息处理类"><a href="#消息处理类" class="headerlink" title="消息处理类"></a>消息处理类</h3><p>区别于客户端消息类，处理消息时，需要在接收的消息中加入传来的消息IP地址防止找不到回溯玩家。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MsgHandle</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> num = NetCloudServerManager.instance.HandleMsgNum;</span><br><span class="line">    Dictionary&lt;<span class="built_in">string</span>, ProtocolBase&gt; oneMessager = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, ProtocolBase&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;ProtocolBase&gt; msgList = <span class="keyword">new</span> List&lt;ProtocolBase&gt;();</span><br><span class="line"></span><br><span class="line">    ProtocolByte assistProtocol;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Running</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(msgList.Count&gt;<span class="number">0</span>&amp;&amp;num&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            num--;</span><br><span class="line">            <span class="comment">//处理长度和将协议分开</span></span><br><span class="line">            assistProtocol = msgList[<span class="number">0</span>] <span class="keyword">as</span> ProtocolByte;</span><br><span class="line">            <span class="keyword">if</span>(assistProtocol==<span class="literal">null</span>) &#123;</span><br><span class="line">                Debug.Log(<span class="string">&quot;消息转化失败&quot;</span>);</span><br><span class="line">                <span class="keyword">lock</span> (msgList) &#123;</span><br><span class="line">                    msgList.RemoveAt(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">int</span> start = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">string</span> IpAddress = assistProtocol.GetString(start, <span class="keyword">ref</span> start);</span><br><span class="line">            <span class="built_in">string</span> protocolName=assistProtocol.GetString(start, <span class="keyword">ref</span> start);</span><br><span class="line">            <span class="comment">//int protocolNameLen=System.Text.Encoding.UTF8.GetBytes(protocolName).Length + sizeof(Int32);</span></span><br><span class="line">            <span class="keyword">switch</span> (protocolName) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;ProtocolCubeTexture&quot;</span>:</span><br><span class="line">                    ProtocolCubeTexture protocolCubeTexture = <span class="keyword">new</span> ProtocolCubeTexture();</span><br><span class="line">                    ProtocolCubeTexture aprotocol = protocolCubeTexture.Decode(assistProtocol.bytes, start, assistProtocol.bytes.Length) <span class="keyword">as</span> ProtocolCubeTexture;</span><br><span class="line">                    <span class="keyword">if</span> (aprotocol == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">                    PointMessage point = <span class="keyword">new</span> PointMessage();</span><br><span class="line">                    point.ResolveToPointMessage(aprotocol.Coord, aprotocol.CubemapFace, aprotocol.srcTexture);</span><br><span class="line">                    NetCloudServerManager.instance.PM.Add(point);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;Start&quot;</span>:</span><br><span class="line">                    StartProcessData(assistProtocol, start, IpAddress);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">lock</span>(msgList) &#123;</span><br><span class="line">                msgList.RemoveAt(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//ProtocolCubeTexture protocol = msgList[0] as ProtocolCubeTexture;</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        num = NetCloudServerManager.instance.HandleMsgNum;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">StartProcessData</span>(<span class="params">ProtocolByte protocol,<span class="built_in">int</span> start,<span class="built_in">string</span> SendIPAddress</span>)</span> &#123;</span><br><span class="line">        ProtocolStr protocolStr = <span class="keyword">new</span> ProtocolStr();</span><br><span class="line">        Debug.Log(<span class="string">&quot;start&quot;</span> + start + <span class="string">&quot; lenth&quot;</span> + assistProtocol.bytes.Length);</span><br><span class="line">        ProtocolStr protocolstr = protocolStr.Decode(assistProtocol.bytes, start, assistProtocol.bytes.Length-start) <span class="keyword">as</span> ProtocolStr;</span><br><span class="line">        NetCloudServerManager.instance.debug.text += (<span class="string">&quot;\n&quot;</span> + protocolstr.str);</span><br><span class="line">        <span class="built_in">string</span>[] CoordStrs = protocolstr.str.Split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        <span class="built_in">float</span>[] Coord = <span class="keyword">new</span> <span class="built_in">float</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">            Coord[i] = <span class="built_in">float</span>.Parse(CoordStrs[i]);</span><br><span class="line">        Camera camm = NetCloudServerManager.instance.cam;</span><br><span class="line">        camm.transform.position = <span class="keyword">new</span> Vector3( Coord[<span class="number">0</span>], Coord[<span class="number">1</span>], Coord[<span class="number">2</span>]);</span><br><span class="line">        PointMessage point = <span class="keyword">new</span> PointMessage();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ( camm.RenderToCubemap(point.cubemap)) &#123;</span><br><span class="line">            <span class="built_in">int</span> index = <span class="number">-1</span>;</span><br><span class="line">            Conn[] conns = NetCloudServerManager.cs.conns;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; conns.Length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (conns[i] == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (!conns[i].isUse)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(conns[i].GetAdress()==SendIPAddress) &#123;</span><br><span class="line">                    index = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//print(&quot; 将消息传播&quot; + conns[i].GetAdress());</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="built_in">int</span> width = NetCloudServerManager.instance.width;</span><br><span class="line">            ProtocolCubeTexture protocolCube = <span class="keyword">new</span> ProtocolCubeTexture();</span><br><span class="line">            protocolCube.srcTexture = <span class="keyword">new</span> Texture2D(width, width);</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">                protocolCube.Coord[i] = <span class="built_in">int</span>.Parse(CoordStrs[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++) &#123;</span><br><span class="line">                protocolCube.CubemapFace = i;</span><br><span class="line">                protocolCube.srcTexture.SetPixels(point.cubemap.GetPixels((CubemapFace)i));</span><br><span class="line">                protocolCube.srcTexture.Apply();</span><br><span class="line">                conns[index].SendMsg(protocolCube);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            NetCloudServerManager.instance.debug.text+= (<span class="string">&quot;\n&quot;</span> + protocolstr.str+<span class="string">&quot;渲染失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PointMessage-点消息类"><a href="#PointMessage-点消息类" class="headerlink" title="PointMessage 点消息类"></a>PointMessage 点消息类</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PointMessage</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Vector3 pos;</span><br><span class="line">    <span class="keyword">public</span> Cubemap cubemap;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">int</span> width;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PointMessage</span>()</span> &#123;</span><br><span class="line">        pos = Vector3.zero;</span><br><span class="line">        width = NetCloudServerManager.instance.width;</span><br><span class="line"></span><br><span class="line">        cubemap = <span class="keyword">new</span> Cubemap(width, TextureFormat.RGBA32, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="Connect-类"><a href="#Connect-类" class="headerlink" title="Connect 类"></a>Connect 类</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Connect</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Socket socket;</span><br><span class="line">    <span class="built_in">int</span> BUFFER_SIZE = NetCloudClientManager.instance.BUFFER_SIZE;</span><br><span class="line">    <span class="built_in">byte</span>[] readBuff ;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> buffCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Int32 msgLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">byte</span>[] lenByte = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="keyword">sizeof</span>(Int32)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ProtocolByte assistProtolByte;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MsgHandle msgHandle = <span class="keyword">new</span> MsgHandle();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">enum</span> Status &#123;</span><br><span class="line">        None,Connect</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> Status status = Status.None;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> width = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span>  <span class="title">Connect</span>()</span> &#123;</span><br><span class="line">        readBuff = <span class="keyword">new</span> <span class="built_in">byte</span>[BUFFER_SIZE];</span><br><span class="line">        assistProtolByte = <span class="keyword">new</span> ProtocolByte();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Connetion</span>(<span class="params"><span class="built_in">string</span> host, <span class="built_in">int</span> port</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//清理text</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Socket</span></span><br><span class="line">            socket = <span class="keyword">new</span> Socket(AddressFamily.InterNetwork,</span><br><span class="line">            SocketType.Stream, ProtocolType.Tcp);</span><br><span class="line">            <span class="keyword">if</span> (host.Length == <span class="number">0</span>) &#123;</span><br><span class="line">                host = <span class="string">&quot;192.168.50.142&quot;</span>;</span><br><span class="line">                port = <span class="number">1234</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            socket.Connect(host, port);</span><br><span class="line">            status = Status.Connect;</span><br><span class="line">            NetCloudClientManager.instance.debug.text += (<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;客户端地址&quot;</span> + socket.LocalEndPoint.ToString());</span><br><span class="line">            socket.BeginReceive(readBuff, buffCount, BUFFER_SIZE - buffCount, SocketFlags.None, ReceiveCb, readBuff);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            NetCloudClientManager.instance.debug.text += (<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;客户端失败&quot;</span>+e.Message );</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// clientText.text = &quot;客户端地址&quot; + socket.LocalEndPoint.ToString();</span></span><br><span class="line">        <span class="comment">//Recv</span></span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ReceiveCb</span>(<span class="params">IAsyncResult ar</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//count是接收数据的大小</span></span><br><span class="line">            <span class="built_in">int</span> count = socket.EndReceive(ar);</span><br><span class="line">            buffCount += count;</span><br><span class="line">            ProcessData();</span><br><span class="line">            socket.BeginReceive(readBuff,buffCount , BUFFER_SIZE-buffCount, SocketFlags.None, ReceiveCb, readBuff);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           <span class="comment">// recvText.text += &quot;连接已断开&quot;;</span></span><br><span class="line">            socket.Close();</span><br><span class="line">            status = Status.None;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ProcessData</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (buffCount &lt; <span class="keyword">sizeof</span>(Int32))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Array.Copy(readBuff, lenByte, <span class="keyword">sizeof</span>(Int32));</span><br><span class="line">        msgLength = BitConverter.ToInt32(lenByte, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (buffCount &lt; msgLength + <span class="keyword">sizeof</span>(Int32))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        ProtocolBase protocol = assistProtolByte.Decode(readBuff, <span class="keyword">sizeof</span>(Int32), msgLength);</span><br><span class="line">        <span class="keyword">lock</span>(msgHandle.msgList) &#123;</span><br><span class="line">            msgHandle.msgList.Add(protocol);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> count = buffCount - msgLength - <span class="keyword">sizeof</span>(Int32);</span><br><span class="line">        Array.Copy(readBuff, <span class="keyword">sizeof</span>(Int32) + msgLength, readBuff, <span class="number">0</span>, count);</span><br><span class="line">        buffCount = count;</span><br><span class="line">        <span class="keyword">if</span> (buffCount &gt; <span class="number">0</span>)</span><br><span class="line">            ProcessData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Close</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket.Close();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;关闭失败:&quot;</span> + e.Message);</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span>  <span class="title">SendMsg</span>(<span class="params"> ProtocolBase protol</span>)</span> &#123;    </span><br><span class="line">        <span class="built_in">string</span> proName = protol.GetName();  ;</span><br><span class="line">        <span class="keyword">return</span> SendMsg(protol, proName);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">SendMsg</span>(<span class="params">ProtocolBase protol,<span class="built_in">string</span> protolName</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (status != Status.Connect) &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;404 Not Found&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ProtocolByte protocolByte1 = <span class="keyword">new</span> ProtocolByte();</span><br><span class="line">        protocolByte1.AddString(protolName);</span><br><span class="line">        <span class="built_in">byte</span>[] protolNameByte = protocolByte1.bytes;</span><br><span class="line">        <span class="built_in">byte</span>[] b = protol.Encode();</span><br><span class="line">        <span class="built_in">byte</span>[] len1 = BitConverter.GetBytes(protolNameByte.Length + b.Length);</span><br><span class="line">        <span class="built_in">byte</span>[] sendByte = len1.Concat(protolNameByte).Concat(b).ToArray();</span><br><span class="line">        socket.Send(sendByte);</span><br><span class="line">        Debug.Log(GetStr(sendByte));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="built_in">string</span> <span class="title">GetStr</span>(<span class="params"><span class="built_in">byte</span>[] bytes</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="literal">null</span>) <span class="keyword">return</span> str;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; bytes.Length; i++) &#123;</span><br><span class="line">            <span class="built_in">int</span> b = (<span class="built_in">int</span>)bytes[i];</span><br><span class="line">            str += b.ToString() + <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 地址辅助方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetClientAddress</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> socket.LocalEndPoint.ToString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetLocalIp</span>()</span> &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span>获取本地的IP地址</span></span><br><span class="line">        <span class="built_in">string</span> AddressIP = <span class="built_in">string</span>.Empty;</span><br><span class="line">        <span class="keyword">foreach</span> (IPAddress _IPAddress <span class="keyword">in</span> Dns.GetHostEntry(Dns.GetHostName()).AddressList) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_IPAddress.AddressFamily.ToString() == <span class="string">&quot;InterNetwork&quot;</span>) &#123;</span><br><span class="line"></span><br><span class="line">                AddressIP = _IPAddress.ToString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> AddressIP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消息处理类-1"><a href="#消息处理类-1" class="headerlink" title="消息处理类"></a>消息处理类</h3><p>在处理消息队列时一定需要上lock</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MsgHandle</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> num = NetCloudClientManager.instance.HandleMsgNum;</span><br><span class="line">    <span class="keyword">public</span> List&lt;ProtocolBase&gt; msgList = <span class="keyword">new</span> List&lt;ProtocolBase&gt;();</span><br><span class="line"></span><br><span class="line">    ProtocolByte assistProtocol;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Running</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(msgList.Count&gt;<span class="number">0</span>&amp;&amp;num&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            num--;</span><br><span class="line">            <span class="comment">//处理长度和将协议分开</span></span><br><span class="line">            assistProtocol = msgList[<span class="number">0</span>] <span class="keyword">as</span> ProtocolByte;</span><br><span class="line">            <span class="keyword">if</span>(assistProtocol==<span class="literal">null</span>) &#123;</span><br><span class="line">                Debug.Log(<span class="string">&quot;消息转化失败&quot;</span>);</span><br><span class="line">                <span class="keyword">lock</span> (msgList) &#123;</span><br><span class="line">                    msgList.RemoveAt(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">string</span> protocolName=assistProtocol.GetName();</span><br><span class="line">            <span class="built_in">int</span> protocolNameLen=System.Text.Encoding.UTF8.GetBytes(protocolName).Length + <span class="keyword">sizeof</span>(Int32);</span><br><span class="line">            <span class="keyword">switch</span> (protocolName) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;ProtocolCubeTexture&quot;</span>:</span><br><span class="line">                    ProtocolCubeTexture protocolCubeTexture = <span class="keyword">new</span> ProtocolCubeTexture();</span><br><span class="line">                    ProtocolCubeTexture aprotocol = protocolCubeTexture.Decode(assistProtocol.bytes, protocolNameLen, assistProtocol.bytes.Length) <span class="keyword">as</span> ProtocolCubeTexture;</span><br><span class="line">                    <span class="keyword">if</span> (aprotocol == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">                    Vector3 pos = <span class="keyword">new</span> Vector3(aprotocol.Coord[<span class="number">0</span>], aprotocol.Coord[<span class="number">1</span>], aprotocol.Coord[<span class="number">2</span>]);</span><br><span class="line">                    PointMessage point = NetCloudClientManager.instance.PM.Find((PointMessage p) =&gt; p.pos.Equals(pos));</span><br><span class="line">                    <span class="keyword">if</span>(point==<span class="literal">null</span>) point = <span class="keyword">new</span> PointMessage();</span><br><span class="line">                    </span><br><span class="line">                    point.ResolveToPointMessage(aprotocol.Coord, aprotocol.CubemapFace, aprotocol.srcTexture);</span><br><span class="line">                    </span><br><span class="line">                    NetCloudClientManager.instance.PM.Add(point);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;Start&quot;</span>:</span><br><span class="line">                    ProtocolStr protocolStr = <span class="keyword">new</span> ProtocolStr();</span><br><span class="line">                    ProtocolStr protocolstr = protocolStr.Decode(assistProtocol.bytes, protocolNameLen, assistProtocol.bytes.Length) <span class="keyword">as</span> ProtocolStr;</span><br><span class="line">                    NetCloudClientManager.instance.debug.text += (<span class="string">&quot;\n&quot;</span> + protocolstr.str);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">lock</span>(msgList) &#123;</span><br><span class="line">                msgList.RemoveAt(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//ProtocolCubeTexture protocol = msgList[0] as ProtocolCubeTexture;</span></span><br><span class="line">        &#125;</span><br><span class="line">        num = NetCloudClientManager.instance.HandleMsgNum;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="PointMessage-点消息类-1"><a href="#PointMessage-点消息类-1" class="headerlink" title="PointMessage 点消息类"></a>PointMessage 点消息类</h3><p>区别于服务端，需要把相应的字节流变成texture，并将其贴到点消息的CubeMap上</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PointMessage</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Vector3 pos;</span><br><span class="line">    <span class="keyword">public</span> Cubemap cubemap;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">int</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span>[] FaceFlags ;</span><br><span class="line">    <span class="built_in">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PointMessage</span>()</span> &#123;</span><br><span class="line">        pos = Vector3.zero;</span><br><span class="line">        width = NetCloudClientManager.instance.width;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        FaceFlags = <span class="keyword">new</span> <span class="built_in">bool</span>[] &#123; <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span> &#125;;</span><br><span class="line">        cubemap = <span class="keyword">new</span> Cubemap(width, TextureFormat.RGBA32, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ResolveToPointMessage</span>(<span class="params"><span class="built_in">byte</span>[] byt </span>)</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> str = System.Text.Encoding.UTF8.GetString(byt);</span><br><span class="line">        <span class="built_in">string</span>[] strs = str.Split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        pos.x = <span class="built_in">float</span>.Parse(strs[<span class="number">0</span>]);</span><br><span class="line">        pos.y = <span class="built_in">float</span>.Parse(strs[<span class="number">1</span>]);</span><br><span class="line">        pos.z = <span class="built_in">float</span>.Parse(strs[<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">string</span> CF = strs[<span class="number">3</span>]; </span><br><span class="line">        <span class="built_in">int</span> bytCount = System.Text.Encoding.UTF8.GetBytes(pos.x.ToString() + <span class="string">&quot; &quot;</span> + pos.y.ToString() + <span class="string">&quot; &quot;</span> + pos.z.ToString() + <span class="string">&quot; &quot;</span> + CF + <span class="string">&quot; &quot;</span>).Length;</span><br><span class="line">        <span class="built_in">byte</span>[] image = byt.Skip(bytCount).ToArray();</span><br><span class="line">        <span class="keyword">switch</span> (CF) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;PX&quot;</span>: cubemap.SetPixels(ColorToCubemap(image), CubemapFace.PositiveX); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;NX&quot;</span>: cubemap.SetPixels(ColorToCubemap(image), CubemapFace.NegativeX); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;PY&quot;</span>: cubemap.SetPixels(ColorToCubemap(image), CubemapFace.PositiveY); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;NY&quot;</span>: cubemap.SetPixels(ColorToCubemap(image), CubemapFace.NegativeY); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;PZ&quot;</span>: cubemap.SetPixels(ColorToCubemap(image), CubemapFace.PositiveZ); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;NZ&quot;</span>: cubemap.SetPixels(ColorToCubemap(image), CubemapFace.NegativeZ); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cubemap.Apply();</span><br><span class="line">        size++;</span><br><span class="line">        <span class="comment">//Texture2DClient.LoadImage(image);</span></span><br><span class="line">        <span class="comment">//Texture2DClient.Apply();</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ResolveToPointMessage</span>(<span class="params"><span class="built_in">int</span>[] Coord,<span class="built_in">int</span> CubeMapFace,Texture2D texture</span>)</span> &#123;</span><br><span class="line">        pos.x = Coord[<span class="number">0</span>];</span><br><span class="line">        pos.y = Coord[<span class="number">1</span>];</span><br><span class="line">        pos.z = Coord[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">switch</span> (CubeMapFace) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: cubemap.SetPixels( texture.GetPixels(), CubemapFace.PositiveX); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: cubemap.SetPixels( texture.GetPixels(), CubemapFace.NegativeX); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: cubemap.SetPixels( texture.GetPixels(), CubemapFace.PositiveY); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: cubemap.SetPixels( texture.GetPixels(), CubemapFace.NegativeY); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>: cubemap.SetPixels( texture.GetPixels(), CubemapFace.PositiveZ); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>: cubemap.SetPixels( texture.GetPixels(), CubemapFace.NegativeZ); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Debug.Log(<span class="string">&quot;cubeface &quot;</span> + CubeMapFace);</span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">        FaceFlags[CubeMapFace] = <span class="literal">true</span>;</span><br><span class="line">        cubemap.Apply();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Color[] <span class="title">ColorToCubemap</span>(<span class="params"><span class="built_in">byte</span>[] byt</span>)</span> &#123;</span><br><span class="line">        Texture2D textureTest = <span class="keyword">new</span> Texture2D(width, width);</span><br><span class="line">        textureTest.LoadImage(byt);</span><br><span class="line">        textureTest.Apply();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> textureTest.GetPixels() ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="built_in">int</span>  <span class="title">GetSize</span>()</span> &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;FaceFlags.Length;i++) &#123; <span class="keyword">if</span> (FaceFlags[i]) size++; &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aa</span>()</span> &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;aaaaa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>个人理解：字节流协议和字符串流协议算是中间层协议，其他协议类可以聚合两个中间层协议进行编写。</p>
<h3 id="协议基类"><a href="#协议基类" class="headerlink" title="协议基类"></a>协议基类</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProtocolBase</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//解码器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> ProtocolBase <span class="title">Decode</span>(<span class="params"><span class="built_in">byte</span>[] readBuff,<span class="built_in">int</span> start,<span class="built_in">int</span> length</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProtocolBase();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//编码器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">byte</span>[] <span class="title">Encode</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">byte</span>[] &#123; &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">GetName</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Base&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">GetDesc</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字节流协议"><a href="#字节流协议" class="headerlink" title="字节流协议"></a>字节流协议</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProtocolByte</span> : <span class="title">ProtocolBase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">byte</span>[] bytes;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> ProtocolBase <span class="title">Decode</span>(<span class="params"><span class="built_in">byte</span>[] readBuff, <span class="built_in">int</span> start, <span class="built_in">int</span> length</span>)</span> &#123;</span><br><span class="line">        ProtocolByte proByte = <span class="keyword">new</span> ProtocolByte();</span><br><span class="line">        proByte.bytes = <span class="keyword">new</span> <span class="built_in">byte</span>[length];</span><br><span class="line">        Array.Copy(readBuff, start, proByte.bytes, <span class="number">0</span>, length);</span><br><span class="line">        <span class="keyword">return</span> (ProtocolBase)proByte;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">byte</span>[] <span class="title">Encode</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">GetName</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> GetString(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">GetDesc</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="literal">null</span>) <span class="keyword">return</span> str;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;bytes.Length;i++) &#123;</span><br><span class="line">            <span class="built_in">int</span> b = (<span class="built_in">int</span>)bytes[i];</span><br><span class="line">            str += b.ToString() + <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 字节辅助流</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddString</span>(<span class="params"><span class="built_in">string</span> str</span>)</span> &#123;</span><br><span class="line">        Int32 len = str.Length;</span><br><span class="line">        <span class="built_in">byte</span>[] lenBytes = BitConverter.GetBytes(len);</span><br><span class="line">        <span class="built_in">byte</span>[] strBytes = System.Text.Encoding.UTF8.GetBytes(str);</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="literal">null</span>)</span><br><span class="line">            bytes = lenBytes.Concat(strBytes).ToArray();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            bytes = bytes.Concat(lenBytes).Concat(strBytes).ToArray();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetString</span>(<span class="params"><span class="built_in">int</span> start, <span class="keyword">ref</span> <span class="built_in">int</span> end</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (bytes.Length &lt; start + <span class="keyword">sizeof</span>(Int32))</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        Int32 strLen = BitConverter.ToInt32(bytes, start);</span><br><span class="line">        <span class="keyword">if</span> (bytes.Length &lt; start + <span class="keyword">sizeof</span>(Int32) + strLen)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> str = System.Text.Encoding.UTF8.GetString(bytes, start + <span class="keyword">sizeof</span>(Int32) , strLen);</span><br><span class="line">        end = start + <span class="keyword">sizeof</span>(Int32) + strLen;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetString</span>(<span class="params"><span class="built_in">int</span> start</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> GetString(start,<span class="keyword">ref</span> end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddInt</span>(<span class="params"><span class="built_in">int</span> num</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">byte</span>[] numBytes = BitConverter.GetBytes(num);</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="literal">null</span>)</span><br><span class="line">            bytes = numBytes;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            bytes = bytes.Concat(numBytes).ToArray();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetInt</span>(<span class="params"><span class="built_in">int</span> start,<span class="keyword">ref</span> <span class="built_in">int</span> end</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (bytes.Length &lt; start + <span class="keyword">sizeof</span>(Int32))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        end = start + <span class="keyword">sizeof</span>(Int32);</span><br><span class="line">        <span class="keyword">return</span> BitConverter.ToInt32(bytes, start);</span><br><span class="line">    &#125;<span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetInt</span>(<span class="params"><span class="built_in">int</span> start</span>)</span> &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="built_in">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> GetInt(start,<span class="keyword">ref</span> end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddFloat</span>(<span class="params"><span class="built_in">float</span> num</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">byte</span>[] numBytes = BitConverter.GetBytes(num);</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="literal">null</span>)</span><br><span class="line">            bytes = numBytes;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            bytes = bytes.Concat(numBytes).ToArray();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">float</span> <span class="title">GetFloat</span>(<span class="params"><span class="built_in">int</span> start, <span class="keyword">ref</span> <span class="built_in">int</span> end</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (bytes.Length &lt; start + <span class="keyword">sizeof</span>(<span class="built_in">float</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        end = start + <span class="keyword">sizeof</span>(<span class="built_in">float</span>);</span><br><span class="line">        <span class="keyword">return</span> BitConverter.ToSingle(bytes, start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">float</span> <span class="title">GetFloat</span>(<span class="params"><span class="built_in">int</span> start</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> GetFloat(start, <span class="keyword">ref</span> end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串协议"><a href="#字符串协议" class="headerlink" title="字符串协议"></a>字符串协议</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProtocolStr</span> : <span class="title">ProtocolBase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> str;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> ProtocolBase <span class="title">Decode</span>(<span class="params"><span class="built_in">byte</span>[] readBuff, <span class="built_in">int</span> start, <span class="built_in">int</span> length</span>)</span> &#123;</span><br><span class="line">        ProtocolStr proStr = <span class="keyword">new</span> ProtocolStr();    </span><br><span class="line">        proStr.str = System.Text.Encoding.UTF8.GetString(readBuff, start, length);</span><br><span class="line">        <span class="keyword">return</span> (ProtocolBase) proStr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">byte</span>[] <span class="title">Encode</span>()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> System.Text.Encoding.UTF8.GetBytes(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">GetName</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.Length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> str.Split(<span class="string">&#x27;,&#x27;</span>)[<span class="number">0</span>];  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">GetDesc</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ProtocolCubeTexture-协议"><a href="#ProtocolCubeTexture-协议" class="headerlink" title="ProtocolCubeTexture 协议"></a>ProtocolCubeTexture 协议</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProtocolCubeTexture</span> : <span class="title">ProtocolBase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> width = NetCloudClientManager.instance.width;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[] Coord = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">public</span> Texture2D srcTexture;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> CubemapFace = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//解码器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> ProtocolBase <span class="title">Decode</span>(<span class="params"><span class="built_in">byte</span>[] readBuff, <span class="built_in">int</span> start, <span class="built_in">int</span> length</span>)</span> &#123;</span><br><span class="line">        ProtocolCubeTexture proTexture = <span class="keyword">new</span> ProtocolCubeTexture();</span><br><span class="line">        ProtocolByte proByte = <span class="keyword">new</span> ProtocolByte();</span><br><span class="line">        proByte.bytes = readBuff;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) &#123;</span><br><span class="line">            proTexture.Coord[i] = proByte.GetInt(start, <span class="keyword">ref</span> start);</span><br><span class="line">        &#125;</span><br><span class="line">        proTexture.CubemapFace = proByte.GetInt(start, <span class="keyword">ref</span> start);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//图片解析</span></span><br><span class="line">        <span class="built_in">int</span> srcStart = start;</span><br><span class="line">        <span class="built_in">int</span> srcLength = readBuff.Length-start;</span><br><span class="line">        <span class="built_in">byte</span>[] srcbyte = <span class="keyword">new</span> <span class="built_in">byte</span>[srcLength];</span><br><span class="line">        Array.Copy(readBuff, srcStart, srcbyte, <span class="number">0</span>, srcLength);</span><br><span class="line">        proTexture.srcTexture = <span class="keyword">new</span> Texture2D(width,width);</span><br><span class="line">        proTexture.srcTexture.LoadImage(srcbyte);</span><br><span class="line">        proTexture.srcTexture.Apply();</span><br><span class="line">        <span class="comment">//NetCloudClientManager.instance.tex[proTexture.CubemapFace] = proTexture.srcTexture;</span></span><br><span class="line">        <span class="keyword">return</span> (ProtocolBase) proTexture;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//编码器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">byte</span>[] <span class="title">Encode</span>()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//立方体面编译</span></span><br><span class="line">        </span><br><span class="line">        ProtocolByte proByte = <span class="keyword">new</span> ProtocolByte();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) &#123;</span><br><span class="line">            proByte.AddInt(Coord[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        proByte.AddInt(CubemapFace);</span><br><span class="line">        <span class="built_in">byte</span>[] cubeFaceBytes = proByte.Encode();</span><br><span class="line">        <span class="comment">//图片编译</span></span><br><span class="line">        <span class="keyword">if</span> (srcTexture == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">byte</span>[] srcTextureByte = srcTexture.EncodeToJPG();</span><br><span class="line">        <span class="comment">//byte[] lenByte = BitConverter.GetBytes(srcTextureByte.Length + cubeFaceBytes.Length);</span></span><br><span class="line">        <span class="built_in">byte</span>[] byt = cubeFaceBytes.Concat(srcTextureByte).ToArray();</span><br><span class="line">        <span class="keyword">return</span> byt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">GetName</span>()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ProtocolCubeTexture&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">GetDesc</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">byte</span>[] srcTextureByte = srcTexture.EncodeToJPG();</span><br><span class="line">        <span class="keyword">if</span> (srcTextureByte == <span class="literal">null</span>) <span class="keyword">return</span> str;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; srcTextureByte.Length; i++) &#123;</span><br><span class="line">            <span class="built_in">int</span> b = (<span class="built_in">int</span>)srcTextureByte[i];</span><br><span class="line">            str += b.ToString() + <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>全景图</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL学习之路之光照贴图</title>
    <url>/2021/12/07/OpenGL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E5%85%89%E7%85%A7%E8%B4%B4%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="Phong光照模型"><a href="#Phong光照模型" class="headerlink" title="Phong光照模型"></a>Phong光照模型</h1><p>效果混合相加：diffuse + ambient + specular</p>
<p>图片混和相乘：(diffuse + ambient + specular) * objColor</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FragColor =vec4((diffuse + ambient + specular) * objColor,<span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure>

<h1 id="环境光–ambient"><a href="#环境光–ambient" class="headerlink" title="环境光–ambient"></a>环境光–ambient</h1><p>ambient具体能表现无光照区域的颜色，在物体较暗的部分加上漫反射贴图会更真实</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vec3 ambient=texture(material.diffuse, TexCoord).rgb * ambientColor;</span><br></pre></td></tr></table></figure>

<h1 id="漫反射贴图—diffuse"><a href="#漫反射贴图—diffuse" class="headerlink" title="漫反射贴图—diffuse"></a>漫反射贴图—diffuse</h1><p>出现的大概像表面的纹理像木箱的表面，相当于简单反射到眼睛的获得的颜色</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vec3 diffuse=texture(material.diffuse,TexCoord).rgb * max( dot( lightDir, Normal), <span class="number">0</span>) * lightColor;</span><br><span class="line">    <span class="comment">//vec3 diffuse=texture(material.diffuse,TexCoord).rgb;</span></span><br></pre></td></tr></table></figure>
<h1 id="镜面反射—specular"><a href="#镜面反射—specular" class="headerlink" title="镜面反射—specular"></a>镜面反射—specular</h1><p>可以将光照和高光进行反射，提高真实度</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vec3 reflectVec=reflect(-lightDir,Normal);</span><br><span class="line"><span class="type">float</span> specularAmount=<span class="built_in">pow</span>(max(dot(reflectVec,cameraVec),<span class="number">0</span>),material.shininess); <span class="comment">//高光的集中度，倍数越高，同一视角高光点越小</span></span><br><span class="line">vec3 specular=texture(material.specular,TexCoord).rgb * specularAmount * lightColor;<span class="comment">//镜面反射图中为数值0或者为黑色表示不需要镜面反射，木块和铁最好对比</span></span><br></pre></td></tr></table></figure>

<h1 id="发射光贴图—emission"><a href="#发射光贴图—emission" class="headerlink" title="发射光贴图—emission"></a>发射光贴图—emission</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vec3 emission=texture(material.emission,TexCoord).rgb;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL学习之路之光源大总结</title>
    <url>/2021/12/19/OpenGL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E5%85%89%E6%BA%90%E5%A4%A7%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="光源所需条件"><a href="#光源所需条件" class="headerlink" title="光源所需条件"></a>光源所需条件</h1><h4 id="1-光照信息"><a href="#1-光照信息" class="headerlink" title="1.光照信息"></a>1.光照信息</h4><p>定向光 点光源 聚光灯的属性</p>
<h4 id="2-法线向量"><a href="#2-法线向量" class="headerlink" title="2.法线向量"></a>2.法线向量</h4><p>将顶点着色器的法线信息接收，并进行标准化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vec3 uNormal=<span class="built_in">normalize</span>(Normal);</span><br></pre></td></tr></table></figure>

<h4 id="3-片元到摄像头的位置"><a href="#3-片元到摄像头的位置" class="headerlink" title="3.片元到摄像头的位置"></a>3.片元到摄像头的位置</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vec3 dirToCamera=<span class="built_in">normalize</span>(cameraPos-FragPos);</span><br></pre></td></tr></table></figure>

<h2 id="定向光"><a href="#定向光" class="headerlink" title="定向光"></a>定向光</h2><h4 id="主要光照信息"><a href="#主要光照信息" class="headerlink" title="主要光照信息"></a>主要光照信息</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LightDirectional</span>&#123;</span><br><span class="line">  vec3 pos;<span class="comment">//光源坐标</span></span><br><span class="line">  vec3 color;<span class="comment">//光颜色</span></span><br><span class="line">  vec3 dirToLight;<span class="comment">//光照角度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>不需要光照衰弱，光照与位置无关</p>
<h4 id="diffuse"><a href="#diffuse" class="headerlink" title="diffuse"></a>diffuse</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">diffuseIntersity=<span class="built_in">max</span>(<span class="built_in">dot</span>(light.dirToLight,Normal),<span class="number">0</span>);</span><br><span class="line">diffuse=diffuseIntersity*light.color*<span class="built_in">texture</span>(material.diffuse,TexCoord).rgb;</span><br></pre></td></tr></table></figure>

<h4 id="specular"><a href="#specular" class="headerlink" title="specular"></a>specular</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">specularIntersity=<span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(<span class="built_in">normalize</span>(<span class="built_in">reflect</span>(-light.dirToLight,Normal)),dirToCamera),<span class="number">0</span>),material.shininess);</span><br><span class="line">vec3 specular=specularIntersity*light.color*<span class="built_in">texture</span>(material.specular,TexCoord).rgb;</span><br></pre></td></tr></table></figure>

<h2 id="点光源"><a href="#点光源" class="headerlink" title="点光源"></a>点光源</h2><h4 id="主要光照信息-1"><a href="#主要光照信息-1" class="headerlink" title="主要光照信息"></a>主要光照信息</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LightPoint</span>&#123;</span><br><span class="line">  vec3 pos;</span><br><span class="line">  vec3 color;</span><br><span class="line">  vec3 dirToLight;<span class="comment">//用不上</span></span><br><span class="line">    <span class="type">float</span> constant;<span class="comment">//1.0f</span></span><br><span class="line">    <span class="type">float</span> linear;<span class="comment">//0.09f</span></span><br><span class="line">    <span class="type">float</span> quadratic;<span class="comment">//0.032f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>与光照方向无关</p>
<h4 id="attenuation"><a href="#attenuation" class="headerlink" title="attenuation"></a>attenuation</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> distantes=<span class="built_in">length</span>(light.pos-FragPos);</span><br><span class="line"><span class="type">float</span> attenuation=<span class="number">1.0f</span>/light.constant+light.linear*distantes+light.quadratic*distantes*distantes;</span><br></pre></td></tr></table></figure>



<h4 id="diffuse-1"><a href="#diffuse-1" class="headerlink" title="diffuse"></a>diffuse</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">diffuseInyersity=<span class="built_in">max</span>(<span class="built_in">dot</span>(<span class="built_in">normalize</span>(light.pos-FragPos),Normal),<span class="number">0</span>);</span><br><span class="line">vec3 diffuse=diffuseIntensity*<span class="built_in">texture</span>(material.diffuse,TexCoord).rgb*light.color;</span><br></pre></td></tr></table></figure>

<h4 id="specular-1"><a href="#specular-1" class="headerlink" title="specular"></a>specular</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> specularIntersity=<span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(<span class="built_in">normalize</span>(<span class="built_in">reflect</span>(-<span class="built_in">normalize</span>(light.pos-FragPos),uNormal)),dirToCamera),<span class="number">0</span>),material.shininess);</span><br><span class="line">  vec3 specular=specularIntersity*light.color*<span class="built_in">texture</span>(material.specular,TexCoord).rgb;</span><br></pre></td></tr></table></figure>

<h2 id="聚光灯"><a href="#聚光灯" class="headerlink" title="聚光灯"></a>聚光灯</h2><h4 id="主要光照信息-2"><a href="#主要光照信息-2" class="headerlink" title="主要光照信息"></a>主要光照信息</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LightSpot</span>&#123;</span><br><span class="line">  vec3 pos;</span><br><span class="line">  vec3 color;</span><br><span class="line">  vec3 dirToLight;<span class="comment">//有用</span></span><br><span class="line">    <span class="type">float</span> constant;</span><br><span class="line">    <span class="type">float</span> linear;</span><br><span class="line">    <span class="type">float</span> quadratic;</span><br><span class="line">  <span class="type">float</span> cosPhyInner;</span><br><span class="line">  <span class="type">float</span> cosPhyOutter;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><p>边缘模糊化，对比点光源需要会受角度影响</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vec3 result=<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//attenuation</span></span><br><span class="line"><span class="type">float</span> distances= <span class="built_in">length</span>(light.pos - FragPos);</span><br><span class="line"><span class="type">float</span> attenuation=<span class="number">1.0f</span>/(light.constant+light.linear*distances+light.quadratic*distances*distances);</span><br><span class="line"><span class="type">float</span> spotRatio=<span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> cosTheta=<span class="built_in">dot</span>(<span class="built_in">normalize</span>(FragPos-light.pos),<span class="number">-1.0f</span>*light.dirToLight);</span><br><span class="line"><span class="comment">//cosTheta=1;</span></span><br><span class="line"><span class="keyword">if</span>(cosTheta &gt; light.cosPhyInner)</span><br><span class="line">&#123;</span><br><span class="line">  spotRatio=<span class="number">1.0f</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(cosTheta &gt; light.cosPhyOutter)&#123;</span><br><span class="line">  <span class="comment">//spotRatio=1.0f-(cosTheta-light.cosPhyInner)/(light.cosPhyOutter-light.cosPhyInner);</span></span><br><span class="line">  spotRatio=(light.cosPhyOutter-cosTheta)/(light.cosPhyOutter - light.cosPhyInner);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">  spotRatio=<span class="number">0.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line">attenuation*=spotRatio;</span><br><span class="line"><span class="comment">//diffuse</span></span><br><span class="line"><span class="type">float</span> diffuseIntensity=<span class="built_in">max</span>(<span class="built_in">dot</span>(<span class="built_in">normalize</span>(light.pos-FragPos),uNormal),<span class="number">0</span>);</span><br><span class="line">vec3 diffuse=<span class="built_in">texture</span>(material.diffuse,TexCoord).rgb*light.color*diffuseIntensity;</span><br><span class="line">result+=diffuse;</span><br><span class="line"></span><br><span class="line"><span class="comment">//specular</span></span><br><span class="line"><span class="type">float</span> specularIntersity=<span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(<span class="built_in">normalize</span>(<span class="built_in">reflect</span>(-<span class="built_in">normalize</span>(light.pos-FragPos),uNormal)),dirToCamera),<span class="number">0</span>),material.shininess);</span><br><span class="line">vec3 specular = specularIntersity*<span class="built_in">texture</span>(material.specular,TexCoord).rgb*light.color;</span><br><span class="line">result+=specular;</span><br><span class="line"><span class="comment">//result*=attenuation;</span></span><br><span class="line">result*=spotRatio;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity升级管线的注意事项</title>
    <url>/2022/01/18/Unity%E5%8D%87%E7%BA%A7%E7%AE%A1%E7%BA%BF%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<blockquote>
<h1 id="升级渲染管线在PM中下载-Universal-RP"><a href="#升级渲染管线在PM中下载-Universal-RP" class="headerlink" title="升级渲染管线在PM中下载 Universal RP"></a>升级渲染管线在PM中下载 Universal RP</h1></blockquote>
<p>材质记得替，不如会出现洋红色</p>
<blockquote>
<h1 id="使用的简单的建模工具"><a href="#使用的简单的建模工具" class="headerlink" title="使用的简单的建模工具"></a>使用的简单的建模工具</h1></blockquote>
<p>在pm包中有不错的东西</p>
<p>在游戏中进行简单的建模可以用ProBuilder和Polybrush这两个包进行修改地形的顶点</p>
<p>ProGrids做方格的校准</p>
<h1 id="阴影部分"><a href="#阴影部分" class="headerlink" title="阴影部分"></a>阴影部分</h1><p><a href="https://zhuanlan.zhihu.com/p/444286597">百人计划说的很详细了</a></p>
]]></content>
      <categories>
        <category>升级渲染管线</category>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Shader的主要节点介绍</title>
    <url>/2022/02/20/Shader%E7%9A%84%E4%B8%BB%E8%A6%81%E8%8A%82%E7%82%B9%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>虽然学习很久了，但没有好好总结过shader用到的数学，以至于在用的过程中总是忘记，然后花时间去找，裂开，没有搞完的发现后后续补充。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="长度length-a"><a href="#长度length-a" class="headerlink" title="长度length(a)"></a>长度length(a)</h2><p>简单的欧式距离，根号下平方的那个。</p>
<h2 id="点乘dot（-a，b）"><a href="#点乘dot（-a，b）" class="headerlink" title="点乘dot（ a，b）"></a>点乘dot（ a，b）</h2><p>点乘是通过将对应分量逐个相乘，然后再把所得积相加来计算的。就是高中学的向量的乘法</p>
<p>v¯⋅k¯=||v¯||⋅||k¯||⋅cosθ</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(a1,a2,a3)⋅(b1,b2,b3)=a1*b1+a2* b2+a3*b3</span><br></pre></td></tr></table></figure>

<h3 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h3><p>当两个向量都是单位向量时就是两个向量的夹角的余弦值，常用于计算角度。</p>
<h2 id="叉乘cross（Lhs，Rhs）"><a href="#叉乘cross（Lhs，Rhs）" class="headerlink" title="叉乘cross（Lhs，Rhs）"></a>叉乘cross（Lhs，Rhs）</h2><p>叉乘只在3D空间中有定义，它需要两个不平行向量作为输入，生成一个正交于两个输入向量的第三个向量。如果输入的两个向量也是正交的，那么叉乘之后将会产生3个互相正交的向量。接下来的教程中这会非常有用。下面的图片展示了3D空间中叉乘的样子    ：</p>
<p><img src="https://learnopengl-cn.github.io/img/01/07/vectors_crossproduct.png" alt="叉乘图"></p>
<p><strong>注意：</strong>顺序在此运算符上很重要，因为 <strong>AxB</strong> 输出的结果与 <strong>BxA</strong> 不同（其结果类似于 <strong>-AxB</strong> ）。</p>
<p>c=cross（a,b）</p>
<p>c1=a2b3-a3b2</p>
<p>c2=a3b1-a1b3</p>
<p>c3=a1b2-a2b1</p>
<h3 id="用处-1"><a href="#用处-1" class="headerlink" title="用处"></a>用处</h3><p>得到两个向量做成平面的法向量；</p>
<h2 id="Saturate"><a href="#Saturate" class="headerlink" title="Saturate"></a>Saturate</h2><p>饱和节点输出在其上设置的向量的值或单个分量饱和到[0 1]范围。</p>
<ul>
<li><p><strong>0：</strong>如果输入小于 0，则返回此值</p>
</li>
<li><p><strong>输入：</strong>如果值介于 0 和 1 之间，则返回此值</p>
</li>
<li><p><strong>1：</strong>如果值大于 1，则返回此值</p>
<p><img src="http://amplify.pt/NodeDetail/SaturateGraphicNode.png"></p>
</li>
</ul>
<h2 id="线性插值lerf（a-b-weight）"><a href="#线性插值lerf（a-b-weight）" class="headerlink" title="线性插值lerf（a,b,weight）"></a>线性插值lerf（a,b,weight）</h2><p>公式(1-weight)×a+weight×b比较均匀，比较生硬</p>
<h2 id="clamp（input-min-max）"><a href="#clamp（input-min-max）" class="headerlink" title="clamp（input,min,max）"></a>clamp（input,min,max）</h2><p>Clamp 节点输出其输入值或夹紧在 Min， Max范围之间的矢量的各个分量。</p>
<ul>
<li><strong>最小值：</strong>如果输入值小于 Min，则返回此值</li>
<li><em><strong>输入：</strong></em>如果输入值介于最小值和最大值之间，则返回此值</li>
<li><strong>最大值：</strong>如果输入值大于 Max，则返回此值</li>
</ul>
<h2 id="平滑阶梯smoothstep-min-max-input"><a href="#平滑阶梯smoothstep-min-max-input" class="headerlink" title="平滑阶梯smoothstep(min,max,input)"></a>平滑阶梯smoothstep(min,max,input)</h2><p>Clamp 节点输出其输入值或夹紧在 Min， Max范围之间的矢量的各个分量。</p>
<ul>
<li><strong>最小值：</strong>如果输入值小于 Min，则返回0</li>
<li><em><strong>输入：</strong></em>如果输入值介于最小值和最大值之间，则返回clamp（（input-min）/（max-min），0，1）</li>
<li><strong>最大值：</strong>如果输入值大于 Max，则返回1</li>
</ul>
<p><img src="http://amplify.pt/NodeDetail/SmoothstepGraphicNode.png"></p>
<h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>还在总结中</p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉计算观后感</title>
    <url>/2022/03/13/%E8%A7%86%E8%A7%89%E8%AE%A1%E7%AE%97%E8%A7%82%E5%90%8E%E6%84%9F/</url>
    <content><![CDATA[<h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h2 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h2><p>从样本数据提取数据，等距提取就是均匀采样，不等距就是非均匀采样。</p>
<h2 id="噪声"><a href="#噪声" class="headerlink" title="噪声"></a>噪声</h2><p>椒盐噪点可以用中值滤波器消除，有条纹状的噪声可以用陷波滤波器，比较细致模糊的噪点可以用低通滤波器</p>
<h1 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h1><h2 id="线性滤波器"><a href="#线性滤波器" class="headerlink" title="线性滤波器"></a>线性滤波器</h2><h3 id="全通"><a href="#全通" class="headerlink" title="全通"></a>全通</h3><p>没有消除和阻止任何一个频率。作用未知。</p>
<h3 id="低通"><a href="#低通" class="headerlink" title="低通"></a>低通</h3><p>使频率越来越宽，可以让图片变得模糊和达到消除噪点的作用</p>
<h4 id="盒式滤波器"><a href="#盒式滤波器" class="headerlink" title="盒式滤波器"></a>盒式滤波器</h4><p>使用全为1的卷积核。</p>
<h4 id="高斯滤波器"><a href="#高斯滤波器" class="headerlink" title="高斯滤波器"></a>高斯滤波器</h4><p>特定的权重，离像素点越远权重越小</p>
<p>下图为高斯函数的3维图示：</p>
<p><img src="https://pic4.zhimg.com/80/v2-d6af23aafa14caec06b3a1790b6d92e3_720w.jpg"></p>
<p>0.05 0.25 0.40 0.25 0.05权值</p>
<h4 id="降低频率采样"><a href="#降低频率采样" class="headerlink" title="降低频率采样"></a>降低频率采样</h4><p>n层：1 x 1</p>
<p>···</p>
<p>n-1层：pow(2,n-1) x pow(2,n-1)</p>
<p>n层：pow(2,n) x pow(2,n)</p>
<p>高斯金字塔</p>
<p>n-1层的一个网格对应相应的n层的4个网格</p>
<h4 id="卷积细节"><a href="#卷积细节" class="headerlink" title="卷积细节"></a>卷积细节</h4><ol>
<li>将滤波器与图像进行卷积时，要每个像素对齐非常重要，每个卷积的结果要单独保存，否则会影响之后的卷积结果</li>
<li>运算时先转化为浮点数再进行滤波最后滤波取整</li>
<li>如果颜色超过0，255设定最大值和最小值s</li>
</ol>
<h3 id="高通"><a href="#高通" class="headerlink" title="高通"></a>高通</h3><p>留下高频去除低频，能得到图形边缘特征。</p>
<p>如核为 -1&#x2F;3 2&#x2F;3 -1&#x2F;3的卷积核。</p>
<h3 id="带通"><a href="#带通" class="headerlink" title="带通"></a>带通</h3><p>指留下低频和高频之间的信号。</p>
<h2 id="非线性滤波器"><a href="#非线性滤波器" class="headerlink" title="非线性滤波器"></a>非线性滤波器</h2><h3 id="中值滤波器"><a href="#中值滤波器" class="headerlink" title="中值滤波器"></a>中值滤波器</h3><p>去核范围的中值代替像素，去椒盐噪点的，还可以制作腐蚀或膨胀效果。</p>
<h1 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h1><h2 id="平移旋转放缩"><a href="#平移旋转放缩" class="headerlink" title="平移旋转放缩"></a>平移旋转放缩</h2><p><a href="https://learnopengl-cn.github.io/01%20Getting%20started/07%20Transformations/">opengl</a>里面有 就不看了</p>
<h2 id="透视变换"><a href="#透视变换" class="headerlink" title="透视变换"></a>透视变换</h2><p>裁剪距阵的推导<br><img src="https://img-blog.csdnimg.cn/c190892dadc14693a1333ea6a36d8882.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"><br>取用这个坐标系，所以w是0 0 -1 0<br>$$<br>∠theta&#x3D;fov&#x2F;2 ,A&#x3D;  N * tan (theta),B&#x3D;  F * tan (theta) \ A’&#x3D;N&#x3D;ACot(theta),B’&#x3D;F&#x3D;BCot(theta)<br>$$<br>所以Y轴是 0 cot(theta) 0 0。<br><img src="https://img-blog.csdnimg.cn/882a9c5831444a61ab5f8edf4f74d502.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"><br>ASP是宽高比</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">C=A<span class="emphasis">*ASP \\</span></span><br><span class="line"><span class="emphasis">D=B*</span>ASP \\</span><br><span class="line">C&#x27;=N=C<span class="emphasis">*Cot(theta) / ASP \\ </span></span><br><span class="line"><span class="emphasis">D&#x27;=F=D*</span>Cot(theta) / ASP</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>

<p>所以x是&#x3D;Cot(theta)&#x2F;ASP 0  0 0。</p>
<p>假设矩阵是线性的<br>$$<br>f(-N)&#x3D;-N,f(-F)&#x3D;F代入方程y&#x3D;sx+o<br>$$<br>解方程组<br>$$<br>s&#x3D;(f+n)&#x2F;(n-f),o&#x3D;2fn&#x2F;(n-f)<br>$$<br>z是0 0 s o；</p>
<p>得透视矩阵如下</p>
<p> <img src="https://img-blog.csdnimg.cn/fc31696d20124d45ae3f5291895b5e7b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>Games104第2节记录</title>
    <url>/2022/03/22/Games104%E7%AC%AC2%E8%8A%82%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Tool Layer    给予开发者使用的工具</p>
<p>Function Layer </p>
<p>Resource Layer </p>
<p>Core Layer   核心层</p>
<p>Platform Layer 为了适应各种平台</p>
<p>越往上越灵活</p>
<p>越往下越稳定</p>
<p>怎样做一个animation system</p>
<h1 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h1><p>将其他资源转化为引擎的资产，引擎化。</p>
<p>需要加载进入游戏的文件</p>
<p>将文件全局资产编号GUID</p>
<p>Handle管理所有的资源周期</p>
<p>延迟加载</p>
<h1 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h1><p>1.Tick循环</p>
<p><img src="https://img-blog.csdnimg.cn/2dffc93fd10c4dfb9970d5078b6dac01.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>2.多线程</p>
<p><img src="https://img-blog.csdnimg.cn/4d4628dbec9a431a8142490ebdedb01b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="Core核心层"><a href="#Core核心层" class="headerlink" title="Core核心层"></a>Core核心层</h1><p>数学库，基本线代，取决于你系统的效率。</p>
<p>simd，如下四个数据一次性处理。</p>
<p><img src="https://img-blog.csdnimg.cn/722c5c5e526b4502908f0edbda47c868.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_13,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>数据结构，无内存碎片，查找效率高</p>
<p>Memory Management，有点像操作系统，进行更高效率的处理。</p>
<p><img src="https://img-blog.csdnimg.cn/ca185ca9c61c45d8ae83704cefc2d4aa.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="Platforms平台层"><a href="#Platforms平台层" class="headerlink" title="Platforms平台层"></a>Platforms平台层</h1><p>去除平台差异</p>
<p>比如将常用的GraphicsAPI抽象出来，用多态解决不同平台的问题。</p>
<h1 id="Tool工具层"><a href="#Tool工具层" class="headerlink" title="Tool工具层"></a>Tool工具层</h1><p>允许任何人可以创造游戏，开发效率优先。</p>
<p>数据的导入器导出器，能支持其他的3d软件资产</p>
<h1 id="简单ecs框架"><a href="#简单ecs框架" class="headerlink" title="简单ecs框架"></a>简单ecs框架</h1><p><img src="https://img-blog.csdnimg.cn/c9374d62177542dea5f17856cf4146df.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>引擎是分层架构的</p>
<p>越底层越稳定，越上层越灵活</p>
<p>通过Ticks进行驱动虚拟世界</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>引擎制作</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV的边缘计算</title>
    <url>/2022/03/22/OpenCV%E7%9A%84%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h1 id="基于梯度的检测器"><a href="#基于梯度的检测器" class="headerlink" title="基于梯度的检测器"></a>基于梯度的检测器</h1><p><img src="https://img-blog.csdn.net/20160911165855683?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p>
<p>梯边缘，顶边缘，坡边缘</p>
<h2 id="有限差分"><a href="#有限差分" class="headerlink" title="有限差分"></a>有限差分</h2><p>最简单的梯度算子<br>$$<br>gx&#x3D;f(x+1,y)-f(x,y) \<br>gy&#x3D;f(x,y+1)-f(x,y)<br>$$</p>
<h2 id="Sobel算子"><a href="#Sobel算子" class="headerlink" title="Sobel算子"></a>Sobel算子</h2><p>对于具有噪声的图有很好的效果<br>$$<br>gx&#x3D;\frac{1}{8}\left[ \begin{matrix} -1 &amp; 0 &amp; 1 \ -2 &amp; 0 &amp; 2 \ -1 &amp; 0 &amp; 1  \end{matrix} \right]\<br>gy&#x3D;\frac{1}{8}\left[ \begin{matrix} 1 &amp; 2 &amp; 1 \ 0 &amp; 0 &amp; 0 \ -1 &amp; -2 &amp; -1  \end{matrix} \right]<br>$$</p>
<h1 id="基于曲率的检测器"><a href="#基于曲率的检测器" class="headerlink" title="基于曲率的检测器"></a>基于曲率的检测器</h1><p>缺点，对于薄边缘在精准定位边缘没有优势</p>
<h2 id="Marr-Hildreth"><a href="#Marr-Hildreth" class="headerlink" title="Marr-Hildreth"></a>Marr-Hildreth</h2><p>$$<br>gx-g(x-1)&#x3D;f(x+1,y)-f(x,y) -(f(x,y)-f(x-1,y) )&#x3D;f(x+1,y)-f(x-1,y)-2f(x,y)<br>$$</p>
<h2 id="高斯的拉普拉斯滤波器LoG"><a href="#高斯的拉普拉斯滤波器LoG" class="headerlink" title="高斯的拉普拉斯滤波器LoG"></a>高斯的拉普拉斯滤波器LoG</h2><p>考虑四边的核<br>$$<br>\frac{1}{8}\left[ \begin{matrix} 0 &amp; -1 &amp; 0 \ -1 &amp; 4 &amp; -1 \ 0 &amp; -1 &amp; 0  \end{matrix} \right]<br>$$<br>考虑全部八个方向<br>$$<br>\frac{1}{8}\left[ \begin{matrix} -1 &amp; -1 &amp; -1 \ -1 &amp; 8 &amp; -1 \ -1 &amp; -1 &amp; -1  \end{matrix} \right]<br>$$</p>
<h1 id="Canny边缘检测"><a href="#Canny边缘检测" class="headerlink" title="Canny边缘检测"></a>Canny边缘检测</h1><p>canny的四步法</p>
<ol>
<li><p>使用低通滤波器抑制噪声</p>
</li>
<li><p>计算梯度幅度和方向图</p>
</li>
<li><p>对梯度幅度图使用非极大值抑制</p>
</li>
<li><p>运用迟滞和连通分析检测边缘</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Mat srcImage, grayImage;</span><br><span class="line"></span><br><span class="line">  srcImage = <span class="built_in">imread</span>(<span class="string">&quot;Lena.png&quot;</span>);</span><br><span class="line">  <span class="built_in">imshow</span>(<span class="string">&quot;Lena.png&quot;</span>, srcImage);</span><br><span class="line">  Mat srcImage1 = srcImage.<span class="built_in">clone</span>();</span><br><span class="line">  <span class="comment">//图形转换:</span></span><br><span class="line">  <span class="built_in">cvtColor</span>(srcImage, grayImage, COLOR_BGR2GRAY);</span><br><span class="line">  Mat dstImage, edge;</span><br><span class="line">  <span class="comment">//均值滤波</span></span><br><span class="line">  <span class="built_in">blur</span>(srcImage1, grayImage, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">imshow</span>(<span class="string">&quot;grayImage.png&quot;</span>, grayImage);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">GaussianBlur</span>(grayImage, grayImage, <span class="built_in">Size</span>(<span class="number">5</span>, <span class="number">5</span>), <span class="number">0.8</span>);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    边缘检测</span></span><br><span class="line"><span class="comment">    低于阈值1的像素点会被认为不是边缘；</span></span><br><span class="line"><span class="comment">    高于阈值2的像素点会被认为是边缘；</span></span><br><span class="line"><span class="comment">    在阈值1和阈值2之间的像素点,若与第2步得到的边缘像素点相邻，则被认为是边缘，否则被认为不是边缘。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="built_in">Canny</span>(grayImage, edge, <span class="number">150</span>, <span class="number">100</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  dstImage.<span class="built_in">create</span>(srcImage1.<span class="built_in">size</span>(), srcImage1.<span class="built_in">type</span>());</span><br><span class="line">  dstImage = Scalar::<span class="built_in">all</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  image.copyTo(imageROI)。作用是把image的内容复制粘贴到imageROI上；</span></span><br><span class="line"><span class="comment">  image.copyTo(imageROI，mask)。 作用是把mask和image重叠以后把mask中像素值为0（black）的点对应的image中的点变为透明，而保留其他点。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  srcImage1.<span class="built_in">copyTo</span>(dstImage, edge);</span><br><span class="line">  <span class="built_in">imwrite</span>(<span class="string">&quot;canny.jpg&quot;</span>, dstImage);</span><br><span class="line">  <span class="built_in">imshow</span>(<span class="string">&quot;canny.jpg&quot;</span>, dstImage);</span><br><span class="line">  <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="fast算子"><a href="#fast算子" class="headerlink" title="fast算子"></a>fast算子</h1><p><a href="https://blog.csdn.net/ssw_1990/article/details/70569871">参考这个代码</a></p>
<p>计算步骤</p>
<ol>
<li><p>从图片中选取一个坐标点,获取该点的像素值,接下来判定该点是否为特征点.</p>
</li>
<li><p>选取一个以选取点坐标为圆心的半径等于三的Bresenham圆(一个计算圆的轨迹的离散算法,得到整数级的圆的轨迹点),一般来说,这个圆上有16个点</p>
</li>
<li><p>现在选取一个阈值,假设为t,关键步骤,假设这16个点中,有N个连续的像素点,他们的亮度值与中心点的像素值的差大于或者小于t,那么这个点就是一个特征点.(n的取值一般取值12或者9,实验证明9可以取得更好的效果,因为可以获取更多的特征点,后面进行处理时,数据样本额相对多一些).</p>
</li>
<li><p>加入每个轨迹点都需要遍历的话,那么需要的时间比较长,有一种比较简单的方法可以选择,那就是仅仅检查在位置1，9，5和13四个位置的像素，首先检测位置1和位置9，如果它们都比阈值暗或比阈值亮，再检测位置5和位置13,该满足判断条件。如果不满足中心点不可能是一个角点。对于所有点做上面这一部分初步的检测后，符合条件的将成为候选的角点，我们再对候选的角点，做完整的测试，即检测圆上的所有点.</p>
</li>
</ol>
<p>但是,这种检测方法会带来一个问题,就是造成特征点的聚簇效应,多个特征点在图像的某一块重复高频率的出现,FAST算法提出了一种非极大值抑制的办法来消除这种情况,具体办法如下</p>
<ol>
<li><p>对所有检测到的角点构建一个打分函数。就是像素点与周围16个像素点差值的绝对值之和。</p>
</li>
<li><p>考虑两个相邻的角点，并比较它们的值。</p>
</li>
<li><p>值较低的角点将会被删除。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Mat srcImage, grayImage;</span><br><span class="line"></span><br><span class="line">  srcImage = <span class="built_in">imread</span>(<span class="string">&quot;Lena.png&quot;</span>);</span><br><span class="line">  <span class="built_in">imshow</span>(<span class="string">&quot;Lena.png&quot;</span>, srcImage);</span><br><span class="line"></span><br><span class="line">  Mat gray;</span><br><span class="line">  <span class="built_in">cvtColor</span>(srcImage, gray, COLOR_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">  Mat LenaFast;</span><br><span class="line">  vector&lt;KeyPoint&gt;detectKeyPoint;</span><br><span class="line">  Mat keyPointImage1;</span><br><span class="line">  Ptr&lt;FastFeatureDetector&gt; fast = FastFeatureDetector::<span class="built_in">create</span>();</span><br><span class="line">  fast-&gt;<span class="built_in">detect</span>(gray, detectKeyPoint);</span><br><span class="line">  <span class="built_in">drawKeypoints</span>(srcImage, detectKeyPoint, keyPointImage1, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), DrawMatchesFlags::DRAW_RICH_KEYPOINTS);</span><br><span class="line">  <span class="built_in">imshow</span>(<span class="string">&quot;keyPoint image1&quot;</span>, keyPointImage1);</span><br><span class="line">  <span class="comment">//imshow(&quot;keyPoint image2&quot;, keyPointImage2);</span></span><br><span class="line">  <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum struct</span> <span class="title class_">DrawMatchesFlags</span></span><br><span class="line">&#123;</span><br><span class="line">  DEFAULT = <span class="number">0</span>, <span class="comment">//!&lt; 将创建输出图像矩阵(Mat::create),</span></span><br><span class="line">               <span class="comment">//!&lt; i.e. 输出图像的现有内存可以重用.</span></span><br><span class="line">               <span class="comment">//!&lt; 将绘制两个源图像，匹配和单个关键点.</span></span><br><span class="line">               <span class="comment">//!&lt; 对于每个关键点，只有中心点将被绘制(没有带关键点大小和方向的圆点)</span></span><br><span class="line">  DRAW_OVER_OUTIMG = <span class="number">1</span>, <span class="comment">//!&lt; 输出图像矩阵将不会被创建 (Mat::create).</span></span><br><span class="line">                        <span class="comment">//!&lt; 匹配将绘制在输出图像的现有内容上.</span></span><br><span class="line">  NOT_DRAW_SINGLE_POINTS = <span class="number">2</span>, <span class="comment">//!&lt; 不会绘制单个关键点。</span></span><br><span class="line">  DRAW_RICH_KEYPOINTS = <span class="number">4</span> <span class="comment">//!&lt; 对于每个关键点，将绘制具有关键点大小和方向的圆。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Harris算子"><a href="#Harris算子" class="headerlink" title="Harris算子"></a>Harris算子</h1><p>步骤如下：</p>
<ol>
<li><p>生成梯度图像gx，gy</p>
</li>
<li><p>一个颜色块A，A1到A9 3x3，一个颜色块B，B1到B9 3x3 w x（Ai-Bi）的平方。w是权值比如A5到Ai的距离。</p>
</li>
<li><p>得到两个特征值下x，y如果两个值都很小，没有特征。如果一个很大就存在一条边，都很大，这个点有一个角点。</p>
</li>
</ol>
<p>c++的实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Mat srcImage, grayImage;</span><br><span class="line"></span><br><span class="line">  srcImage = <span class="built_in">imread</span>(<span class="string">&quot;Lena.png&quot;</span>);</span><br><span class="line">  <span class="built_in">imshow</span>(<span class="string">&quot;Lena.png&quot;</span>, srcImage);</span><br><span class="line"></span><br><span class="line">  Mat gray;</span><br><span class="line">  <span class="built_in">cvtColor</span>(srcImage, gray, COLOR_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">  Mat LenaHarris;</span><br><span class="line">  <span class="built_in">cornerHarris</span>(gray, LenaHarris, <span class="number">7</span>,<span class="number">7</span>, <span class="number">0.1</span>);</span><br><span class="line">  <span class="built_in">imshow</span>(<span class="string">&quot;LenaHarris.jpg&quot;</span>, LenaHarris);</span><br><span class="line">  <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>学习记录</title>
    <url>/2020/03/01/C++%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1><h2 id="流操纵算子"><a href="#流操纵算子" class="headerlink" title="流操纵算子"></a>流操纵算子</h2><p>需要头文件<br>#include<iomanip><br>整数dec10，oct8，hex16，setbase<br>小数点setiosflags(ios::fixed)或fixed<br>浮点精度precision，setprecision<br>取消小数点resetiosflags(ios::fixed)<br>科学计数法scientific<br>设置宽域setw，width<br>非负数显示正号showpos()<br>非负数不显示正号noshowpos()<br>填充符号setfill(‘’)<br>数字的位置left，right</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>templatea<class T>&#x2F;&#x2F;T就变成了某个数据类型</p>
<h1 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h1><h2 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h2><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">cout &lt;&lt;s1.<span class="built_in">length</span>()&lt;&lt;endl;<span class="comment">//string类型长度输出</span></span><br><span class="line">cout&lt;&lt;s1&lt;&lt;endl;</span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(<span class="number">8</span>,<span class="string">&#x27;x&#x27;</span>)</span></span>;<span class="comment">//s2是8个x</span></span><br><span class="line">cout&lt;&lt;s2&lt;&lt;endl;</span><br><span class="line">string month=<span class="string">&quot;march&quot;</span>;<span class="comment">//直接赋值</span></span><br><span class="line">cout &lt;&lt; month&lt;&lt;endl;</span><br><span class="line">string s;</span><br><span class="line">s=<span class="string">&#x27;n&#x27;</span>;<span class="comment">//可以单个赋值</span></span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<h3 id="string的复制"><a href="#string的复制" class="headerlink" title="string的复制"></a>string的复制</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span>,s3</span>;<span class="comment">//直接复制</span></span><br><span class="line">  s3.<span class="built_in">assign</span>(s1);</span><br><span class="line">  cout&lt;&lt;s3&lt;&lt;endl;</span><br><span class="line">  <span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span>,s2,s3</span>;</span><br><span class="line">  s3.<span class="built_in">assign</span>(s1,<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//从s1的第2个复制3个字符，2形同下标</span></span><br></pre></td></tr></table></figure>

<h3 id="读取string的字符"><a href="#读取string的字符" class="headerlink" title="读取string的字符"></a>读取string的字符</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s[<span class="number">0</span>]<span class="comment">//不会检测 ，可能会越界</span></span><br><span class="line">s.<span class="built_in">at</span>(<span class="number">0</span>)<span class="comment">//越界编译不会出错，但结果会提示出错</span></span><br></pre></td></tr></table></figure>

<h3 id="string连接"><a href="#string连接" class="headerlink" title="string连接"></a>string连接</h3><p>​    </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span>,<span class="title">s2</span><span class="params">(<span class="string">&quot;morning&quot;</span>)</span></span>;</span><br><span class="line">s1+=s2;<span class="comment">//直接连接</span></span><br><span class="line">cout&lt;&lt;s1&lt;&lt;endl;</span><br><span class="line">s1.<span class="built_in">append</span>(s2);<span class="comment">//append连接</span></span><br><span class="line">cout&lt;&lt;s1&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">s2.<span class="built_in">append</span>(s1,<span class="number">3</span>,s1.<span class="built_in">size</span>());<span class="comment">//从s1的第3个复制s1.size()在s2的尾部</span></span><br></pre></td></tr></table></figure>
<h3 id="比较string"><a href="#比较string" class="headerlink" title="比较string"></a>比较string</h3><p>可以直接比较用bool类型记录结果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span>,<span class="title">s2</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span>,<span class="title">s3</span><span class="params">(<span class="string">&quot;hell&quot;</span>)</span></span>;</span><br><span class="line">   <span class="type">int</span> f1=s1.<span class="built_in">compare</span>(s2);<span class="comment">//0   hello==hello</span></span><br><span class="line">   <span class="type">int</span> f2=s1.<span class="built_in">compare</span>(s3);<span class="comment">//1   hello&gt;hell</span></span><br><span class="line">   <span class="type">int</span> f3=s3.<span class="built_in">compare</span>(s1);<span class="comment">//-1 hell&lt;hello</span></span><br><span class="line">   <span class="type">int</span> f4=s1.<span class="built_in">compare</span>(<span class="number">1</span>,<span class="number">2</span>,s3,<span class="number">0</span>,<span class="number">3</span>);<span class="comment">//-1el&lt;hell   数字是代表下标</span></span><br><span class="line">   <span class="type">int</span> f5=s1.<span class="built_in">compare</span>(<span class="number">0</span>,s1.<span class="built_in">size</span>(),s3);<span class="comment">//1  hello&gt;hell第一个数是下标，第二个数字是s1比较的数量</span></span><br></pre></td></tr></table></figure>

<h3 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span>,s2</span>;</span><br><span class="line">s2=s1.<span class="built_in">substr</span>(<span class="number">4</span>,<span class="number">5</span>);<span class="comment">//下标4开始的5个字符</span></span><br><span class="line">cout&lt;&lt;s2&lt;&lt;endl;<span class="comment">//o wor</span></span><br></pre></td></tr></table></figure>

<h3 id="搜索find"><a href="#搜索find" class="headerlink" title="搜索find()"></a>搜索find()</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;hello worlld&quot;</span>)</span></span>;</span><br><span class="line">   cout&lt;&lt;s1.<span class="built_in">find</span>(<span class="string">&quot;ll&quot;</span>)&lt;&lt;endl;<span class="comment">//2</span></span><br><span class="line">   cout&lt;&lt;s1.<span class="built_in">find</span>(<span class="string">&quot;abc&quot;</span>)&lt;&lt;endl;<span class="comment">//4294967295正序查找没有的话出现一个很大的数</span></span><br><span class="line">   cout&lt;&lt;s1.<span class="built_in">rfind</span>(<span class="string">&quot;ll&quot;</span>)&lt;&lt;endl;<span class="comment">//9逆序查找</span></span><br><span class="line">   cout&lt;&lt;s1.<span class="built_in">find_first_of</span>(<span class="string">&quot;abcde&quot;</span>)&lt;&lt;endl;<span class="comment">//1  abcde中第一个字符的下标位置</span></span><br><span class="line">   cout&lt;&lt;s1.<span class="built_in">find_last_of</span>(<span class="string">&quot;abcde&quot;</span>)&lt;&lt;endl;<span class="comment">//11  abcde中最后一个字符下标位置</span></span><br><span class="line">   cout&lt;&lt;s1.<span class="built_in">find_first_not_of</span>(<span class="string">&quot;abcde&quot;</span>)&lt;&lt;endl;<span class="comment">//0在字符串中不是abcde的下标位置</span></span><br><span class="line">   cout&lt;&lt;s1.<span class="built_in">find_last_not_of</span>(<span class="string">&quot;abcde&quot;</span>)&lt;&lt;endl;<span class="comment">//10逆序在字符串中不是abcde的下标位置</span></span><br></pre></td></tr></table></figure>

<h3 id="删除string元素"><a href="#删除string元素" class="headerlink" title="删除string元素"></a>删除string元素</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s1.<span class="built_in">erase</span>(<span class="number">5</span>)<span class="comment">//会去掉下标5之后的字符</span></span><br></pre></td></tr></table></figure>

<h3 id="替换string元素"><a href="#替换string元素" class="headerlink" title="替换string元素"></a>替换string元素</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s1.<span class="built_in">replace</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="string">&quot;hahah&quot;</span>)<span class="comment">//将s1下标为2到3的字符换成hahah</span></span><br><span class="line">s1.<span class="built_in">replace</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="string">&quot;hahah&quot;</span>,<span class="number">1</span>,<span class="number">2</span>)<span class="comment">//将s1下标为2到3的字符换成hahah的下标1开始的2个字符</span></span><br></pre></td></tr></table></figure>

<h3 id="插入string元素"><a href="#插入string元素" class="headerlink" title="插入string元素"></a>插入string元素</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s1.<span class="built_in">insert</span>(<span class="number">5</span>,s2)<span class="comment">//将s2插入下标5的位置</span></span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">2</span>,s2,<span class="number">5</span>,<span class="number">3</span>)<span class="comment">//将s2中下标5开始的3个字符插入s1下标2的位置</span></span><br></pre></td></tr></table></figure>

<h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><h3 id="c-str"><a href="#c-str" class="headerlink" title="c_str()"></a>c_str()</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,s1.<span class="built_in">c_str</span>());<span class="comment">//s1.c_str()返回传统的const char*类型字符串，且该字符串以\0结尾</span></span><br></pre></td></tr></table></figure>

<h3 id="data"><a href="#data" class="headerlink" title="data()"></a>data()</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*p1=s1.<span class="built_in">data</span>();<span class="comment">//s1.data()返回char*类型的字符串，对s1的修改可能会使p1出错</span></span><br></pre></td></tr></table></figure>

<h2 id="STL库（一）"><a href="#STL库（一）" class="headerlink" title="STL库（一）"></a>STL库（一）</h2><p>容器：可容纳各种数据类型的通用数据结构，是类模板<br>迭代器：可用于依次存取容器中的元素，类似于指针<br>算法：用来操作容器中的元素的函数模板</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>1.顺序容器 vector动态数组 ，deque双向队列，list双向链表<br>2.关联容器set multset map multmap<br>3.容器适配器stack queue priority_queue</p>
<h4 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h4><h5 id="vector动态数组"><a href="#vector动态数组" class="headerlink" title="vector动态数组"></a>vector动态数组</h5><p>头文件：<vector><br>常数时间尾部性能最佳</p>
<h5 id="deque双向队列"><a href="#deque双向队列" class="headerlink" title="deque双向队列"></a>deque双向队列</h5><p>头文件：<deque><br>随机存取任何元素常数时间，但次于vector，两端删减性能最佳<br>head头  tail尾，空元素</p>
<h5 id="list双向链表"><a href="#list双向链表" class="headerlink" title="list双向链表"></a>list双向链表</h5><p>头文件<list><br>元素不能在内存不连续存放，在任何位置都能常数时间，不支持随机存取</p>
<h4 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h4><p>元素是排序的<br>插入任何元素，都是按相应的排序规则来确定其位置<br>在查找时具有非常好的性能<br>通常以平衡二叉树实现，时间logN</p>
<h5 id="set-x2F-multiset"><a href="#set-x2F-multiset" class="headerlink" title="set&#x2F;multiset"></a>set&#x2F;multiset</h5><p>头文件<set><br>set不允许相同的元素，multiset允许相同的元素</p>
<h5 id="map-x2F-multimap"><a href="#map-x2F-multimap" class="headerlink" title="map&#x2F;multimap"></a>map&#x2F;multimap</h5><p>头文件：<map><br>一个名为first另一个名为second，multimap允许相同的first值</p>
<h4 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h4><h5 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h5><p>头文件：<stack><br>栈，是项的有限序列只能修改删除检索最佳插入的项后进后出</p>
<h5 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h5><p>头文件<queue><br>队列，插入只能从尾部，删除修改检索只能在头部进行先进先出</p>
<h5 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h5><p>头文件<queue><br>优先级队列，最高优先级的元素总是第一个出列</p>
<p>顺序容器和关联容器中都有的成员函数<br>begin 返回指向容器中第一个元素的迭代器<br>end   返回指向容器中最后一个元素后面的位置的迭代器<br>rbegin返回指向容器中最后一个元素的迭代器<br>rend返回指向容器中第一个元素前面位置的迭代器<br>erase 从容器中删除一个或几个元素<br>clear 从容器中删除所有元素</p>
<p>顺序容器的常用成员函数<br>front 返回容器中第一个元素的引用<br>back 返回容器中最后一个元素的引用<br>push_back 在容器末尾增加新元素<br>pop_back删除容器末尾的元素<br>erase 删除迭代器指向的元素（可能会使该迭代器失效），或删除一个区间，返回那个元素的迭代器</p>
<h2 id="STL库（二）"><a href="#STL库（二）" class="headerlink" title="STL库（二）"></a>STL库（二）</h2><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>用于指向顺序容器和关联容器的元素<br>迭代器的用法和指针类似<br>有const 和非const两种<br>通过迭代器可以读取它指向的元素<br>通过非const迭代器还能修改其指向的元素</p>
<h3 id="定义迭代器"><a href="#定义迭代器" class="headerlink" title="定义迭代器"></a>定义迭代器</h3><p>容器类名::iterator  变量名;<br>容器类名::const_iterator  变量名;&#x2F;&#x2F;常量迭代器<br>访问迭代器指向的元素<br>*迭代器变量名<br>容器类名::reverse_iterator  变量;&#x2F;&#x2F;反向迭代器</p>
<h2 id="STL库（三）"><a href="#STL库（三）" class="headerlink" title="STL库（三）"></a>STL库（三）</h2><p>所有的vector都适用于deque<br>list<br>特有的成员函数<br>push_front 在前面插入<br>pop_front删除前面的元素<br>sort 排序（list不支持stl的算法sort）<br>remove 删除和指定值相同的所有元素<br>unique 删除所有和前一个元素相同的元素（做到不重复需要unique之前需要sort）<br>merge合并两个链表，并清空被合并的那个<br>reverse 颠倒链表<br>splice在指定位置前面插入另一个链表中的一个或多个元素，并在另一个链表删除被插入的元素<br>lst1.splice(p1,lst2,p2,p3)&#x2F;&#x2F;将[p2,p3)插入p1之前，并从lst2中删除[p2,p3)</p>
<h1 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h1><h2 id="set与multiset"><a href="#set与multiset" class="headerlink" title="set与multiset"></a>set与multiset</h2><p>iterator find:查找等于某个值的元素<br>iterator lower_bound:查找某个下界<br>iterator upper_bound:查找某个上界<br>equal_range: 同时查找上界和下界<br>int  count:计算等于某个值的元素个数<br>void insert：插入某个元素或某个区间</p>
<h2 id="map与multimap"><a href="#map与multimap" class="headerlink" title="map与multimap"></a>map与multimap</h2><p>1直接赋值，例如 mp[“Tom”]&#x3D;0<br>2通过插入一个类型为 pair&lt;Key, T&gt; 的值，例如 mp.insert(pair&lt;string,int&gt;(“Alan”,100));<br>map&lt;string, int&gt;::iterator it;&#x2F;&#x2F;迭代器<br>cout &lt;&lt; iter-&gt;first &lt;&lt; “ “ &lt;&lt; iter-&gt;second &lt;&lt; endl;&#x2F;&#x2F;不能用iter.first<br>但是可以重载&lt;&lt;<br>template&lt;class Key,class Value&gt;<br>ostream&amp;operator&lt;&lt;(ostream&amp;o,const pair&lt;Key,Value&gt;&amp;p)<br>{<br>    o&lt;&lt;”(“&lt;&lt;p.first&lt;&lt;”,”&lt;&lt;p.second&lt;&lt;”)”;<br>}<br>cout&lt;&lt;*s;<br>&#x2F;&#x2F;map专用</p>
<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>push  插入元素<br>pop  弹出元素<br>top   返回栈顶的元素的引用<br>queue<br>push  插入元素发生在尾部<br>pop  弹出元素对头<br>top   返回栈顶的元素的引用对头<br>back  返回栈顶的元素的引用尾部<br>priority_queue<br>保证优先级最大的在前面，保证最大的在前面<br>size   还有多少数<br>empty   是否空</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="1不变序列算法"><a href="#1不变序列算法" class="headerlink" title="1不变序列算法"></a>1不变序列算法</h3><p>min   求两个对象中较小的1<br>max   求两个对象较大的<br>min_element求区间最小的1<br>max_element求区间最大的&#x2F;&#x2F;1有点问题<br>for_each对区间每个元素都做这种操作<br>count计算区间等于某值的元素个数<br>count_if计算区间符合某种条件的元素个数<br>find在区间查找某值的元素<br>find_if区间符合某种条件的元素<br>find_end从区间查找另一个区间出现的最后一次位置<br>find_first_of从区间查找另一个区间出现的第一次的元素<br>adjacent_find从区间查找第一次出现连续两个相等元素的位置<br>search在区间查找另一个区间第一次出现的位置<br>search_n在区间查找第一次出现等于某值的连续n个元素<br>equal判断两个区间是否相等<br>mismatch逐个比较两个区间的元素，返回第一次发生不相等的位置<br>lexicographical_compare按字典比较两个区间的大小</p>
<h3 id="2-变值算法"><a href="#2-变值算法" class="headerlink" title="2.变值算法"></a>2.变值算法</h3><p>for_each 对区间中的每个元素都做某种操作<br>copy复制一个区间到别处<br>copy_backward复制一个区间到别处但目标区前是从后往前被修改的<br>transform将一个区间的元素变形后拷贝到另一个区间&#x2F;&#x2F;迭代器<br>swap_ranges交换两个区间的内容<br>fill用某个值填充区间<br>fill_n用某个值代替区间的n个元素<br>generate用某个操作的结果填充区间<br>generate_n用某个操作的结果替换区间中的n个元素<br>replace将区间中某个值替换为另一个值<br>replace_if将区间中符合某种条件的值替换成另一个值<br>replace_copy将一个区间拷贝到另一个区间，拷贝时某个值要换成新值拷过去<br>replace_copy_if将一个区间拷贝到另一个区间，拷贝时符合某种条件的值要换成新值拷过去</p>
<p>accumulate(first,last,累加的数);求和</p>
<h3 id="3删除算法"><a href="#3删除算法" class="headerlink" title="3删除算法"></a>3删除算法</h3><p>remove 删除区间中等于某个值的元素<br>unique删除区间中连续相等的元素，只留下一个</p>
<h3 id="4变序算法"><a href="#4变序算法" class="headerlink" title="4变序算法"></a>4变序算法</h3><p>random_shuffle(first,last);随机打乱<br>reverse 颠倒区间次序<br>next_permutation将区间改为下一个排列<br>prev_permutation将区间改为上一个排列&#x2F;&#x2F;可以list</p>
<h3 id="5排序算法"><a href="#5排序算法" class="headerlink" title="5排序算法"></a>5排序算法</h3><p>随机访问迭代器 不支持关联容器和list<br>sort()从小到大排序</p>
<h3 id="6有序区间算法"><a href="#6有序区间算法" class="headerlink" title="6有序区间算法"></a>6有序区间算法</h3><p>要求是从小到大排好的随机访问迭代器 不支持关联容器和list<br>binary_search判断区间是否又某个元素<br>lower_bound查找最后一个不小于某个值的元素的位置<br>upper_bound查找第一个大于某个值的元素位置<br>equal_range同时获取upper_bound，lower_bound</p>
<h3 id="7bitset"><a href="#7bitset" class="headerlink" title="7bitset"></a>7bitset</h3><p>bitset<N>&amp;set();全部为1<br>bitset<N>&amp;set(size_t pos,bool val&#x3D;true);设置某位<br>bitset<N>&amp;reset();全部为0<br>bitset<N>&amp;reset(size_t pos);某位设为0<br>bitset<N>&amp;flip();全部翻转<br>bitset<N>&amp;flip(size_t pos)翻转某位</p>
<h1 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h1><h2 id="c-11的新特性"><a href="#c-11的新特性" class="headerlink" title="c++11的新特性"></a>c++11的新特性</h2><ol>
<li><p>数组，容器可以直接用花括号初始化.</p>
</li>
<li><p>auto关键字<br>迭代器的时候可以用auto</p>
</li>
<li><p>decltype关键字<br>返回数据类型</p>
</li>
<li><p>智能指针shared_ptr<br>头文件<memory><br>会自动delete，不能是指针数组</p>
</li>
<li><p>空指针nullpr<br>转化bool等于false</p>
</li>
<li><p>基于范围for循环<br>int ary[]&#x3D;{1,2,3,4,5};<br>for(int &amp;e:ary)<br>e*&#x3D;10&#x2F;&#x2F;输出10，20，30，40，50*</p>
</li>
<li><p>*右值引用<br>&amp;&amp;是右值引用<br>减少进行深拷贝的次数</p>
</li>
<li><p>无序容器（哈希表）<br>头文件<unordered_map><br>用法和map一样，效率更高</p>
</li>
<li><p>正则表达式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">头文件&lt;regex&gt;</span><br><span class="line"><span class="function">regex <span class="title">reg</span><span class="params">(<span class="string">&quot;b.?p.*k&quot;</span>)</span></span></span><br><span class="line"><span class="function">regex_match<span class="comment">//匹配成功1匹配失败0</span></span></span><br><span class="line"><span class="function">10。lambda表达式</span></span><br><span class="line"><span class="function">[外部变量访问方式说明符]<span class="params">(参数表)</span>-&gt;返回值类型</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        语句组</span><br><span class="line">&#125;</span><br><span class="line">[=]以传值的方式使用外部变量</span><br><span class="line">[]  不使用任何外部变量</span><br><span class="line">[&amp;]以引用的方式使用所有的外部变量</span><br><span class="line">[x,&amp;y]x传值，有引用</span><br><span class="line">[=,&amp;x,&amp;y]x，y引用，其他传值</span><br><span class="line">[&amp;,x,y]x，y传值，其他引用</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h2><p>static_cast  reinterpret_cast<br>const_cast  dynamic_cast<br>1.static_cast<br>用于整型，实数型，字符型<br>static_cast&lt;类型&gt;(数)<br>2.reinterpret_cast<br>不同类型的指针之间的转换，不同类型的引用之间的转换<br>3.const_cast<br>去除const的转换<br>4.dynamic_cast<br>将多态基类的指针或引用强制转换为派生类的指针和引用<br>必须是多态</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>try{throw 类型}处理<br>catch(参数){}<br>多个catch<br>如果程序异常没有被catch捕获，程序崩溃<br>catch(…){}属于任何异常<br>exception类<br>bad_typeid<br>转换异常<br>bad_cast<br>多态基类指针转换异常<br>bad_alloc<br>在用new运算符进行动态内存分配时，没有足够的内存<br>ios_base::failure</p>
<p>bad_error–&gt;out_of_range<br>下标越界</p>
<h1 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>可以将子类赋值给父类，在继承时注意需要加public才能让子类继承父类，不然父类就成了私有类了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> :<span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Class C&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>override是在c++11的时候加的在c++中可以全用virtual也可以子类在函数名后加override</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Class B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> :<span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Class C&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="用子类指针调用基类"><a href="#用子类指针调用基类" class="headerlink" title="用子类指针调用基类"></a>用子类指针调用基类</h2><p>其一是强制转换但可以是不安全的</p>
<p>个人觉得其二还是有很大局限性的，需要基类要虚函数<br>其二是用dynamic_cast<br>将多态基类的指针或引用强制转换为派生类的指针和引用<br>必须是多态</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Games104第2节记录</title>
    <url>/2022/03/22/Games104%E7%AC%AC3%E8%8A%82%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="如何构建游戏世界"><a href="#如何构建游戏世界" class="headerlink" title="如何构建游戏世界"></a>如何构建游戏世界</h1><h1 id="如何让游戏世界活起来"><a href="#如何让游戏世界活起来" class="headerlink" title="如何让游戏世界活起来"></a>如何让游戏世界活起来</h1><p>将物体变成GO（ Game Object）</p>
<p>动态物体</p>
<p><img src="https://img-blog.csdnimg.cn/ecc483da75994bb9a6fe64b7a709b970.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>静态物体</p>
<p><img src="https://img-blog.csdnimg.cn/0f44a362a514421287f5bb72021a117d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>环境</p>
<p>​    天空，地形，植被</p>
<p><img src="https://img-blog.csdnimg.cn/c65850254e2647f186d66c4bc77886d5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>其他物体</p>
<p>​    空气墙，规则</p>
<p><img src="C:\Users\27371\AppData\Roaming\Typora\typora-user-images\image-20220330164946213.png" alt="image-20220330164946213"></p>
<h1 id="如何去描述虚拟世界的物体"><a href="#如何去描述虚拟世界的物体" class="headerlink" title="如何去描述虚拟世界的物体"></a>如何去描述虚拟世界的物体</h1><p>将物体的属性和行为封装在一起，成为一个对象。</p>
<p>假如但有两个功能时我怎么处理</p>
<h2 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h2><p>每一个Component类都需要一个tick()函数</p>
<p>多功能物体我们用组合方法来解决。</p>
<p><img src="https://img-blog.csdnimg.cn/ded04fd6b0544d6099e8575a3bdb44a6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/c20590192bd44886b2a15c36a9906d04.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="怎么让游戏动起来"><a href="#怎么让游戏动起来" class="headerlink" title="怎么让游戏动起来"></a>怎么让游戏动起来</h1><p>进行单个系统进行tick()。</p>
<p><img src="https://img-blog.csdnimg.cn/f62c230d4d0f4af28c6e47528f9b373c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>一个一个系统进行tick，而不是一个物体一个物体进行tick，这样的架构会更高效</p>
<h1 id="如何在游戏引爆炸弹"><a href="#如何在游戏引爆炸弹" class="headerlink" title="如何在游戏引爆炸弹"></a>如何在游戏引爆炸弹</h1><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>如果写在一个爆炸类里用switch判断，随着系统的复杂类会越来越大。变得不可调试。爆炸类只需要将这给消息传给其他组件让其他类添加相关方法。</p>
<h1 id="如何管理Game-Object"><a href="#如何管理Game-Object" class="headerlink" title="如何管理Game Object"></a>如何管理Game Object</h1><h2 id="Scene-Management"><a href="#Scene-Management" class="headerlink" title="Scene Management"></a>Scene Management</h2><p>每一个物体都需要一个特别的UID</p>
<p>每个物体都需要一个位置</p>
<h3 id="简单的空间分割"><a href="#简单的空间分割" class="headerlink" title="简单的空间分割"></a>简单的空间分割</h3><h4 id="不需要划分"><a href="#不需要划分" class="headerlink" title="不需要划分"></a>不需要划分</h4><p>物体较少的情况下直接遍历</p>
<p>优点：特别简单，无脑</p>
<p>缺点：但物体多就效率低</p>
<h4 id="进行网格划分"><a href="#进行网格划分" class="headerlink" title="进行网格划分"></a>进行网格划分</h4><p>对格子进行编号，发生事件找邻近格子的部分物体</p>
<p>优点：对比上一种方法能减轻弊端</p>
<p>缺点：对于空间不均匀不适用</p>
<h4 id="四叉树"><a href="#四叉树" class="headerlink" title="四叉树"></a>四叉树</h4><p>对目标块不断的划分。</p>
<p><img src="https://img-blog.csdnimg.cn/26e21d25bf784fca866a120365a6113c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="空间数据管理"><a href="#空间数据管理" class="headerlink" title="空间数据管理"></a>空间数据管理</h3><p>最常用的是BVH方法。</p>
<p><img src="https://img-blog.csdnimg.cn/59b9a5d92205484d98395d4e5c178e37.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>一切都是对象</p>
<p>游戏对象可以用基于组件的方式来描述</p>
<p>游戏对象的状态会在tick循环中更新</p>
<p>游戏对象是通过有效的策略在场景中管理的</p>
<h1 id="物体tick的先后顺序"><a href="#物体tick的先后顺序" class="headerlink" title="物体tick的先后顺序"></a>物体tick的先后顺序</h1><p>多线程通信问题，当你访问其他线程时先通过一个邮局，然后由邮局统一相互发送消息。保证时序一定一致。比如你的精彩时刻是记录玩家的输入，如果是多核执行可能导致结果不一样。</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>引擎制作</tag>
      </tags>
  </entry>
  <entry>
    <title>Games104第4节记录</title>
    <url>/2022/04/04/Games104%E7%AC%AC4%E8%8A%82%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="游戏渲染的挑战"><a href="#游戏渲染的挑战" class="headerlink" title="游戏渲染的挑战"></a>游戏渲染的挑战</h1><p><img src="https://img-blog.csdnimg.cn/89157de1c7774ef1aa07522e078e9dad.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/23dfe2cb80ac45288e9f972fa8d0c9b1.png" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/c5076d29a380491493992c71ead34a7c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>渲染只能占最多20%</p>
<h1 id="渲染在游戏引擎中"><a href="#渲染在游戏引擎中" class="headerlink" title="渲染在游戏引擎中"></a>渲染在游戏引擎中</h1><p><img src="https://img-blog.csdnimg.cn/864a17f45d4f40b6b7951841e767337e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h1><h2 id="SIMD-and-SIMT"><a href="#SIMD-and-SIMT" class="headerlink" title="SIMD and SIMT"></a>SIMD and SIMT</h2><p><img src="https://img-blog.csdnimg.cn/7642173d71924ba189add8d655e916ad.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/253a2ce07ae944838a253c4e725c7ba5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="数据从cpu到GPU"><a href="#数据从cpu到GPU" class="headerlink" title="数据从cpu到GPU"></a>数据从cpu到GPU</h2><p><img src="https://img-blog.csdnimg.cn/70216ab2815342018a2c2003cf095ec1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="缓存的影响"><a href="#缓存的影响" class="headerlink" title="缓存的影响"></a>缓存的影响</h2><p><img src="https://img-blog.csdnimg.cn/3642871673eb444fa52cdf9247996a56.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/f526d65995164481b1be3f88ec161c2e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="其他平台的显卡架构"><a href="#其他平台的显卡架构" class="headerlink" title="其他平台的显卡架构"></a>其他平台的显卡架构</h2><p><img src="https://img-blog.csdnimg.cn/0e790c8ca84342b28b908c5aa276d6b8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="可绘制的"><a href="#可绘制的" class="headerlink" title="可绘制的"></a>可绘制的</h1><h2 id="网格渲染组件"><a href="#网格渲染组件" class="headerlink" title="网格渲染组件"></a>网格渲染组件</h2><p><img src="https://img-blog.csdnimg.cn/a164ee1a5c8d4bb3b81cf07ce3cb181f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="C:\Users\27371\AppData\Roaming\Typora\typora-user-images\image-20220404203718480.png" alt="image-20220404203718480"></p>
<h1 id="法线"><a href="#法线" class="headerlink" title="法线"></a>法线</h1><p>顶点存法线</p>
<p>防止正方形的角部分的法线</p>
<h1 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h1><h1 id="绘制物体在引擎中"><a href="#绘制物体在引擎中" class="headerlink" title="绘制物体在引擎中"></a>绘制物体在引擎中</h1><h2 id="坐标系统和转换"><a href="#坐标系统和转换" class="headerlink" title="坐标系统和转换"></a>坐标系统和转换</h2><p>MVP转化</p>
<h2 id="提高性能"><a href="#提高性能" class="headerlink" title="提高性能"></a>提高性能</h2><p>实例化</p>
<p>如果可以复用的化</p>
<p><img src="https://img-blog.csdnimg.cn/1fc9d34fb69b45b0b61ce665c02b5631.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="材质排序"><a href="#材质排序" class="headerlink" title="材质排序"></a>材质排序</h2><p>哇，GPU：你他妈就这样换数据，到底烦不烦呀</p>
<p><img src="https://img-blog.csdnimg.cn/a70c8d19e9eb4765a6f842c76232b9b3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="GPU批处理渲染"><a href="#GPU批处理渲染" class="headerlink" title="GPU批处理渲染"></a>GPU批处理渲染</h2><p><img src="https://img-blog.csdnimg.cn/a46a1351fb894a2592f8f0b962addea5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="使用包围盒裁剪"><a href="#使用包围盒裁剪" class="headerlink" title="使用包围盒裁剪"></a>使用包围盒裁剪</h2><p><img src="https://img-blog.csdnimg.cn/106511939432458597771d80305b6805.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="四叉树进行裁剪"><a href="#四叉树进行裁剪" class="headerlink" title="四叉树进行裁剪"></a>四叉树进行裁剪</h2><p><img src="https://img-blog.csdnimg.cn/6c61e38da9e54420b26a188cebec6ace.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="PVS"><a href="#PVS" class="headerlink" title="PVS"></a>PVS</h3><p><img src="https://img-blog.csdnimg.cn/aaef94f0698943bbb04cb280e42d10e1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/e507aff76f8d4e98852bc465f6196067.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="GPU-Culling"><a href="#GPU-Culling" class="headerlink" title="GPU Culling"></a>GPU Culling</h2><p><img src="https://img-blog.csdnimg.cn/6d836e7b3b4d4a419a8a6f5a8b9fd591.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="纹理压缩"><a href="#纹理压缩" class="headerlink" title="纹理压缩"></a>纹理压缩</h1><p><img src="https://img-blog.csdnimg.cn/efda019f0d1b40908021735e87db6214.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/26ed47d54b7d4a83be7a2e94e9ccf0f5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="美术工具"><a href="#美术工具" class="headerlink" title="美术工具"></a>美术工具</h1><p><img src="https://img-blog.csdnimg.cn/f9d3c48e556547bb93e171f3179cc031.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="网格管线"><a href="#网格管线" class="headerlink" title="网格管线"></a>网格管线</h1><p><img src="https://img-blog.csdnimg.cn/07815bc68a484e2c8f23d90c8e472e4f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/0d86c673dc0c484f840e1741faa3344d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/a4e82a9e71114b62babc725699a98831.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://img-blog.csdnimg.cn/48330c71f9c3424ea621d36015dc3223.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>引擎制作</tag>
      </tags>
  </entry>
  <entry>
    <title>Games104第5节记录</title>
    <url>/2022/04/11/Games104%E7%AC%AC5%E8%8A%82%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="光照，材质，着色"><a href="#光照，材质，着色" class="headerlink" title="光照，材质，着色"></a>光照，材质，着色</h1><p><img src="https://img-blog.csdnimg.cn/6741651a20b34bf2bef50909951cc455.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="光照"><a href="#光照" class="headerlink" title="光照"></a>光照</h1><h2 id="第一个挑战"><a href="#第一个挑战" class="headerlink" title="第一个挑战"></a>第一个挑战</h2><p>多样的光</p>
<p>复杂的光照信息</p>
<h2 id="第二个挑战"><a href="#第二个挑战" class="headerlink" title="第二个挑战"></a>第二个挑战</h2><p>半球光照和散射信息收集的困难</p>
<h2 id="第三个挑战"><a href="#第三个挑战" class="headerlink" title="第三个挑战"></a>第三个挑战</h2><p>任何物体会变成光源</p>
<h1 id="从简单开始"><a href="#从简单开始" class="headerlink" title="从简单开始"></a>从简单开始</h1><h2 id="简单的光照解决方案"><a href="#简单的光照解决方案" class="headerlink" title="简单的光照解决方案"></a>简单的光照解决方案</h2><p>结果 &#x3D; 环境光 + 单一光照</p>
<h2 id="环境反射贴图"><a href="#环境反射贴图" class="headerlink" title="环境反射贴图"></a>环境反射贴图</h2><p>结果 &#x3D; 主要光 + 环境光 +环境贴图</p>
<p>Phong光照模型缺陷 </p>
<p>能量不守恒</p>
<p><img src="https://img-blog.csdnimg.cn/fe3dafdeb556433b9c8934ac5fdd7994.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>Phone光照模型会有点像塑料</p>
<h1 id="Shadow"><a href="#Shadow" class="headerlink" title="Shadow"></a>Shadow</h1><p><img src="https://img-blog.csdnimg.cn/b0b2458b0b0f4f1bbe44caf1ecff7844.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="shadow-map"><a href="#shadow-map" class="headerlink" title="shadow map"></a>shadow map</h1><p>问题</p>
<p><img src="https://img-blog.csdnimg.cn/f2ad9befe50148ee8494c44b103568c6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>基础着色解决方案</p>
<p><img src="C:\Users\27371\AppData\Roaming\Typora\typora-user-images\image-20220411203056074.png" alt="image-20220411203056074"></p>
<h1 id="3A质量"><a href="#3A质量" class="headerlink" title="3A质量"></a>3A质量</h1><h2 id="预先计算全局照明"><a href="#预先计算全局照明" class="headerlink" title="预先计算全局照明"></a>预先计算全局照明</h2><p>直接光照加间接光照</p>
<h2 id="傅里叶变化"><a href="#傅里叶变化" class="headerlink" title="傅里叶变化"></a>傅里叶变化</h2><p>能够提高卷积的效率</p>
<h2 id="SH（球面谐波）"><a href="#SH（球面谐波）" class="headerlink" title="SH（球面谐波）"></a>SH（球面谐波）</h2><p>球面谐函数，一个数学系统，类似于傅里叶变换，但定义在球面上。SH函数通常是在虚数上定义的</p>
<p><img src="https://img-blog.csdnimg.cn/41f77871571d4b4f8b56ddfe434af638.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>将低频表示出来，一阶就够了</p>
<p><img src="https://img-blog.csdnimg.cn/df7d5be03bfa409fbc34fb6adcb26853.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/c379c8ddc1bd49d98c85ad1e0ecbb46f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="光照贴图优化"><a href="#光照贴图优化" class="headerlink" title="光照贴图优化"></a>光照贴图优化</h2><h3 id="UV-Atlas"><a href="#UV-Atlas" class="headerlink" title="UV Atlas"></a>UV Atlas</h3><p><img src="https://img-blog.csdnimg.cn/5b6b84084bdf4cc991d0865f3eefa11c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="Lighting"><a href="#Lighting" class="headerlink" title="Lighting"></a>Lighting</h3><p><img src="C:\Users\27371\AppData\Roaming\Typora\typora-user-images\image-20220411205330810.png" alt="image-20220411205330810"></p>
<h2 id="Lightmap"><a href="#Lightmap" class="headerlink" title="Lightmap"></a>Lightmap</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>运行时非常高效在环境上烘烤Gl的很多细节</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>长时间和昂贵的预计算(灯光地图农场)只能处理静态场景和静态灯光封装和GPU的存储成本</p>
<h2 id="光照探针"><a href="#光照探针" class="headerlink" title="光照探针"></a>光照探针</h2><p><img src="https://img-blog.csdnimg.cn/81bb800a1c7543c082076f786fbdde39.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="光照点生成"><a href="#光照点生成" class="headerlink" title="光照点生成"></a>光照点生成</h3><p>尽量自动生成</p>
<h2 id="反射探针"><a href="#反射探针" class="headerlink" title="反射探针"></a>反射探针</h2><p>高质量立体贴图</p>
<h2 id="光探头-反射探头混合"><a href="#光探头-反射探头混合" class="headerlink" title="光探头+反射探头混合"></a>光探头+反射探头混合</h2><p>优点</p>
<p>运行时非常高效可以应用于静态和动态对象吗处理漫反射和镜面阴影</p>
<p>缺点</p>
<p>一堆SH光探测器需要预先计算不能处理gl的细节，比如重叠结构上的软阴影</p>
<h1 id="PBR"><a href="#PBR" class="headerlink" title="PBR"></a>PBR</h1><h2 id="微平面理论"><a href="#微平面理论" class="headerlink" title="微平面理论"></a>微平面理论</h2><p><img src="https://img-blog.csdnimg.cn/d515da23062d4913960d9a7e2fd08c5c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="BRDF"><a href="#BRDF" class="headerlink" title="BRDF"></a>BRDF</h2><p><img src="https://img-blog.csdnimg.cn/1d613748bc65403fa137299ae018fa90.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="DFG"><a href="#DFG" class="headerlink" title="DFG"></a>DFG</h2><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p><img src="https://img-blog.csdnimg.cn/b3f6b32d45b34d93a9eedda8bdb1844a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="G"><a href="#G" class="headerlink" title="G"></a>G</h3><p><img src="https://img-blog.csdnimg.cn/476531531130486f93f87cbbe9d3fb3a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p><img src="https://img-blog.csdnimg.cn/80ac8bec11674c04890038c1746d1225.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/bb52c7e0ca7a4dd9a54d9ef3b83e4ce8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="迪士尼"><a href="#迪士尼" class="headerlink" title="迪士尼"></a>迪士尼</h2><p><img src="https://img-blog.csdnimg.cn/68989c7ed1684bd388f9ff4bd22d94ec.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>Dinesy原则</p>
<p>BRDF执行模型时应遵循的原则:</p>
<p>•应使用直观而非物理参数</p>
<p>•参数越少越好</p>
<p>•参数应该在合理范围内为0到1</p>
<p>•应该允许参数超出其合理范围</p>
<p>•所有参数的组合应该尽可能地稳健和合理</p>
<p>迪士尼材质参数</p>
<h1 id="PBR镜面光泽"><a href="#PBR镜面光泽" class="headerlink" title="PBR镜面光泽"></a>PBR镜面光泽</h1><p><img src="https://img-blog.csdnimg.cn/4ce31f35d1f9487e84ba2456929d7da7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/0ff28578fc4c49b59319399319d438fd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>非金属尽量不使用菲涅尔，金属用菲涅尔</p>
<p><img src="https://img-blog.csdnimg.cn/5ff15209ea2a49beb2c049ac3bfd93ed.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>MR会有白边</p>
<p><img src="https://img-blog.csdnimg.cn/668dcac02ccf4bdc8d41d10d12afb6a5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/9eb4249424b748fea69b6ffc424e151f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>《大世界》和《阶梯阴影》</p>
<p>将截锥分割成多个截锥</p>
<p>为每个子截锥渲染阴影地图</p>
<p>然后像素着色器从最接近所需分辨率的地图中采样</p>
<p><img src="https://img-blog.csdnimg.cn/5e71e258778e4de19ca09395e9cc5116.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>级联层之间的混合1. 在级联重叠的地方可以看到可见的接缝2. 级联层之间，因为分辨率不匹配。3.然后着色器根据像素在混合带中的位置在这两个值之间线性插值。</p>
<p><img src="https://img-blog.csdnimg.cn/e9a879de12624b2ba7db3897ef476609.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>Cascade Shadow的利弊</p>
<p>优点</p>
<p>最好的方法与普遍的阴影错误</p>
<p>:透视混叠快速生成深度图，3倍时，深度写入只能提供相当好的结果</p>
<p>缺点</p>
<p>几乎不可能产生高质量的区域阴影没有颜色的阴影。半透明的表面投射不透明的阴影</p>
<p><img src="https://img-blog.csdnimg.cn/6ee78475120541aca0072ff9063bd788.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/47ca3771bbd64fd88ede4cbce667f6fe.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/3ac0349412e54b7db41b89bada0e8a89.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/b2258fa5556a42ccb062615cf3ea6786.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>GPU的快速发展．</p>
<p>更灵活的新着色器模型计算着色器网状材质．Ray-tracying材质</p>
<p>高性能并行架构翘曲或波浪结构</p>
<p>完全开放的图形API．DirectX 12和Vulkan</p>
<h1 id="实时光追"><a href="#实时光追" class="headerlink" title="实时光追"></a>实时光追</h1><p><img src="https://img-blog.csdnimg.cn/21c364067b974556b3226ec83de6ae67.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="实时全局光照"><a href="#实时全局光照" class="headerlink" title="实时全局光照"></a>实时全局光照</h1><p><img src="https://img-blog.csdnimg.cn/1da2f07801504c3b97aa1d9bed146be6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="更复杂的材质模型"><a href="#更复杂的材质模型" class="headerlink" title="更复杂的材质模型"></a>更复杂的材质模型</h1><p><img src="https://img-blog.csdnimg.cn/c1bd49ec81ef4eef9be60243f836ca7b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="虚拟阴影图"><a href="#虚拟阴影图" class="headerlink" title="虚拟阴影图"></a>虚拟阴影图</h1><p><img src="https://img-blog.csdnimg.cn/0537f8c88672470daf415cd4dd2b84b9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="shader管理"><a href="#shader管理" class="headerlink" title="shader管理"></a>shader管理</h1><p>优步着色器和变体</p>
<p><img src="https://img-blog.csdnimg.cn/e499e3f8bd0e424fa05ec3d3f28f6337.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/a4475af0d8a54c7c8d1f3ecd63098676.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/1757c9d159c04cd3b82e88a04b8b12c8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>引擎制作</tag>
      </tags>
  </entry>
  <entry>
    <title>Imgui学习</title>
    <url>/2022/04/12/Imgui%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="让控制台消失"><a href="#让控制台消失" class="headerlink" title="让控制台消失"></a>让控制台消失</h1><p>GetConsoleWindow()&#x2F;&#x2F;获取控制台窗口句柄</p>
<p>SW_HIDE             0<br>SW_SHOWNORMAL       1<br>SW_NORMAL           1<br>SW_SHOWMINIMIZED    2<br>SW_SHOWMAXIMIZED    3<br>SW_MAXIMIZE         3<br>SW_SHOWNOACTIVATE   4<br>SW_SHOW             5<br>SW_MINIMIZE         6<br>SW_SHOWMINNOACTIVE  7<br>SW_SHOWNA           8<br>SW_RESTORE          9<br>SW_SHOWDEFAULT      10<br>SW_FORCEMINIMIZE    11<br>SW_MAX              11</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span>, <span class="type">char</span>**)</span></span>&#123;</span><br><span class="line">     <span class="built_in">ShowWindow</span>(<span class="built_in">GetConsoleWindow</span>(), SW_HIDE);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="导入Imgui"><a href="#导入Imgui" class="headerlink" title="导入Imgui"></a>导入Imgui</h1><p>下载docking的版本有停靠窗口和拿出原窗口的功能</p>
<p>将初始目录下的文件放在解决方案下，将backends和glfw文件夹复制到相应文件夹下。</p>
<p>并将初始目录下的文件放入解决方案的imgui文件夹中</p>
<p>关于平台的backends中的头文件放入头文件夹中</p>
<p>在项目新建main.cpp文件，修改配置</p>
<p><strong>C&#x2F;C++的常规里的附加包含目录</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">.\.</span><br><span class="line">.\glfw\include</span><br><span class="line">.\backends</span><br><span class="line">%(AdditionalIncludeDirectories)<span class="comment">//可不写系统自带</span></span><br></pre></td></tr></table></figure>

<p><strong>链接器常规</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">64</span>架构</span><br><span class="line">.\glfw\lib-vc2010<span class="number">-64</span></span><br><span class="line">%(AdditionalLibraryDirectories)</span><br><span class="line"><span class="number">32</span>架构</span><br><span class="line">.\glfw\lib-vc2010<span class="number">-32</span></span><br><span class="line">%(AdditionalLibraryDirectories)</span><br></pre></td></tr></table></figure>

<p><strong>链接器输入</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">opengl32.lib</span><br><span class="line">glfw3.lib</span><br><span class="line">%(AdditionalDependencies)</span><br></pre></td></tr></table></figure>

<h1 id="导入样例中代码是否报错"><a href="#导入样例中代码是否报错" class="headerlink" title="导入样例中代码是否报错"></a>导入样例中代码是否报错</h1><p>能跑就说明装好了</p>
<h2 id="Global-h"><a href="#Global-h" class="headerlink" title="Global.h"></a>Global.h</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imgui.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imgui_internal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imstb_rectpack.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imstb_textedit.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imstb_truetype.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imgui_impl_glfw.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imgui_impl_opengl3.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="comment">// Dear ImGui: standalone example application for GLFW + OpenGL 3, using programmable pipeline</span></span><br><span class="line"><span class="comment">// (GLFW is a cross-platform general purpose library for handling windows, inputs, OpenGL/Vulkan/Metal graphics context creation, etc.)</span></span><br><span class="line"><span class="comment">// If you are new to Dear ImGui, read documentation from the docs/ folder + read the top of imgui.cpp.</span></span><br><span class="line"><span class="comment">// Read online: https://github.com/ocornut/imgui/tree/master/docs</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(IMGUI_IMPL_OPENGL_ES2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLES2/gl2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span> <span class="comment">// Will drag system OpenGL headers</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [Win32] Our example includes a copy of glfw3.lib pre-compiled with VS2010 to maximize ease of testing and compatibility with old VS compilers.</span></span><br><span class="line"><span class="comment">// To link with VS2010-era libraries, VS2015+ requires linking with legacy_stdio_definitions.lib, which we do using this pragma.</span></span><br><span class="line"><span class="comment">// Your own project should not be affected, as you are likely to link with a newer binary of GLFW that is adequate for your version of Visual Studio.</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1900) &amp;&amp; !defined(IMGUI_DISABLE_WIN32_FUNCTIONS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;legacy_stdio_definitions&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">glfw_error_callback</span><span class="params">(<span class="type">int</span> error, <span class="type">const</span> <span class="type">char</span>* description)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Glfw Error %d: %s\n&quot;</span>, error, description);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span>, <span class="type">char</span>**)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Setup window</span></span><br><span class="line">    <span class="built_in">glfwSetErrorCallback</span>(glfw_error_callback);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decide GL+GLSL versions</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(IMGUI_IMPL_OPENGL_ES2)</span></span><br><span class="line">    <span class="comment">// GL ES 2.0 + GLSL 100</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* glsl_version = <span class="string">&quot;#version 100&quot;</span>;</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CLIENT_API, GLFW_OPENGL_ES_API);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(__APPLE__)</span></span><br><span class="line">    <span class="comment">// GL 3.2 + GLSL 150</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* glsl_version = <span class="string">&quot;#version 150&quot;</span>;</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);  <span class="comment">// 3.2+ only</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);            <span class="comment">// Required on Mac</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// GL 3.0 + GLSL 130</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* glsl_version = <span class="string">&quot;#version 130&quot;</span>;</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);  // 3.2+ only</span></span><br><span class="line">    <span class="comment">//glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);            // 3.0+ only</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create window with graphics context</span></span><br><span class="line">    GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">1280</span>, <span class="number">720</span>, <span class="string">&quot;Dear ImGui GLFW+OpenGL3 example&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">    <span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>); <span class="comment">// Enable vsync</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setup Dear ImGui context</span></span><br><span class="line">    <span class="built_in">IMGUI_CHECKVERSION</span>();</span><br><span class="line">    ImGui::<span class="built_in">CreateContext</span>();</span><br><span class="line">    ImGuiIO&amp; io = ImGui::<span class="built_in">GetIO</span>(); (<span class="type">void</span>)io;</span><br><span class="line">    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;       <span class="comment">// Enable Keyboard Controls</span></span><br><span class="line">    <span class="comment">//io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;      // Enable Gamepad Controls</span></span><br><span class="line">    io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;           <span class="comment">// Enable Docking</span></span><br><span class="line">    io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable;         <span class="comment">// Enable Multi-Viewport / Platform Windows</span></span><br><span class="line">    <span class="comment">//io.ConfigViewportsNoAutoMerge = true;</span></span><br><span class="line">    <span class="comment">//io.ConfigViewportsNoTaskBarIcon = true;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setup Dear ImGui style</span></span><br><span class="line">    ImGui::<span class="built_in">StyleColorsDark</span>();</span><br><span class="line">    <span class="comment">//ImGui::StyleColorsClassic();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// When viewports are enabled we tweak WindowRounding/WindowBg so platform windows can look identical to regular ones.</span></span><br><span class="line">    ImGuiStyle&amp; style = ImGui::<span class="built_in">GetStyle</span>();</span><br><span class="line">    <span class="keyword">if</span> (io.ConfigFlags &amp; ImGuiConfigFlags_ViewportsEnable) &#123;</span><br><span class="line">        style.WindowRounding = <span class="number">0.0f</span>;</span><br><span class="line">        style.Colors[ImGuiCol_WindowBg].w = <span class="number">1.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setup Platform/Renderer backends</span></span><br><span class="line">    <span class="built_in">ImGui_ImplGlfw_InitForOpenGL</span>(window, <span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">ImGui_ImplOpenGL3_Init</span>(glsl_version);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load Fonts</span></span><br><span class="line">    <span class="comment">// - If no fonts are loaded, dear imgui will use the default font. You can also load multiple fonts and use ImGui::PushFont()/PopFont() to select them.</span></span><br><span class="line">    <span class="comment">// - AddFontFromFileTTF() will return the ImFont* so you can store it if you need to select the font among multiple.</span></span><br><span class="line">    <span class="comment">// - If the file cannot be loaded, the function will return NULL. Please handle those errors in your application (e.g. use an assertion, or display an error and quit).</span></span><br><span class="line">    <span class="comment">// - The fonts will be rasterized at a given size (w/ oversampling) and stored into a texture when calling ImFontAtlas::Build()/GetTexDataAsXXXX(), which ImGui_ImplXXXX_NewFrame below will call.</span></span><br><span class="line">    <span class="comment">// - Read &#x27;docs/FONTS.md&#x27; for more instructions and details.</span></span><br><span class="line">    <span class="comment">// - Remember that in C/C++ if you want to include a backslash \ in a string literal you need to write a double backslash \\ !</span></span><br><span class="line">    <span class="comment">//io.Fonts-&gt;AddFontDefault();</span></span><br><span class="line">    <span class="comment">//io.Fonts-&gt;AddFontFromFileTTF(&quot;../../misc/fonts/Roboto-Medium.ttf&quot;, 16.0f);</span></span><br><span class="line">    <span class="comment">//io.Fonts-&gt;AddFontFromFileTTF(&quot;../../misc/fonts/Cousine-Regular.ttf&quot;, 15.0f);</span></span><br><span class="line">    <span class="comment">//io.Fonts-&gt;AddFontFromFileTTF(&quot;../../misc/fonts/DroidSans.ttf&quot;, 16.0f);</span></span><br><span class="line">    <span class="comment">//io.Fonts-&gt;AddFontFromFileTTF(&quot;../../misc/fonts/ProggyTiny.ttf&quot;, 10.0f);</span></span><br><span class="line">    <span class="comment">//ImFont* font = io.Fonts-&gt;AddFontFromFileTTF(&quot;c:\\Windows\\Fonts\\ArialUni.ttf&quot;, 18.0f, NULL, io.Fonts-&gt;GetGlyphRangesJapanese());</span></span><br><span class="line">    <span class="comment">//IM_ASSERT(font != NULL);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Our state</span></span><br><span class="line">    <span class="type">bool</span> show_demo_window = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> show_another_window = <span class="literal">false</span>;</span><br><span class="line">    ImVec4 clear_color = <span class="built_in">ImVec4</span>(<span class="number">0.45f</span>, <span class="number">0.55f</span>, <span class="number">0.60f</span>, <span class="number">1.00f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Main loop</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window)) &#123;</span><br><span class="line">        <span class="comment">// Poll and handle events (inputs, window resize, etc.)</span></span><br><span class="line">        <span class="comment">// You can read the io.WantCaptureMouse, io.WantCaptureKeyboard flags to tell if dear imgui wants to use your inputs.</span></span><br><span class="line">        <span class="comment">// - When io.WantCaptureMouse is true, do not dispatch mouse input data to your main application, or clear/overwrite your copy of the mouse data.</span></span><br><span class="line">        <span class="comment">// - When io.WantCaptureKeyboard is true, do not dispatch keyboard input data to your main application, or clear/overwrite your copy of the keyboard data.</span></span><br><span class="line">        <span class="comment">// Generally you may always pass all inputs to dear imgui, and hide them from your application based on those two flags.</span></span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start the Dear ImGui frame</span></span><br><span class="line">        <span class="built_in">ImGui_ImplOpenGL3_NewFrame</span>();</span><br><span class="line">        <span class="built_in">ImGui_ImplGlfw_NewFrame</span>();</span><br><span class="line">        ImGui::<span class="built_in">NewFrame</span>();</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 1. Show the big demo window (Most of the sample code is in ImGui::ShowDemoWindow()! You can browse its code to learn more about Dear ImGui!).</span></span><br><span class="line">        <span class="keyword">if</span> (show_demo_window)</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Show a simple window that we create ourselves. We use a Begin/End pair to created a named window.</span></span><br><span class="line">             ImGui::<span class="built_in">ShowDemoWindow</span>(&amp;show_demo_window);</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">static</span> <span class="type">float</span> f = <span class="number">0.0f</span>;</span><br><span class="line">            <span class="type">static</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            ImGui::<span class="built_in">Begin</span>(<span class="string">&quot;Hello, world!&quot;</span>);                          <span class="comment">// Create a window called &quot;Hello, world!&quot; and append into it.</span></span><br><span class="line"></span><br><span class="line">            ImGui::<span class="built_in">Text</span>(<span class="string">&quot;This is some useful text.&quot;</span>);               <span class="comment">// Display some text (you can use a format strings too)</span></span><br><span class="line">            ImGui::<span class="built_in">Checkbox</span>(<span class="string">&quot;Demo Window&quot;</span>, &amp;show_demo_window);      <span class="comment">// Edit bools storing our window open/close state</span></span><br><span class="line">            ImGui::<span class="built_in">Checkbox</span>(<span class="string">&quot;Another Window&quot;</span>, &amp;show_another_window);</span><br><span class="line"></span><br><span class="line">            ImGui::<span class="built_in">SliderFloat</span>(<span class="string">&quot;float&quot;</span>, &amp;f, <span class="number">0.0f</span>, <span class="number">1.0f</span>);            <span class="comment">// Edit 1 float using a slider from 0.0f to 1.0f</span></span><br><span class="line">            ImGui::<span class="built_in">ColorEdit3</span>(<span class="string">&quot;clear color&quot;</span>, (<span class="type">float</span>*)&amp;clear_color); <span class="comment">// Edit 3 floats representing a color</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(<span class="string">&quot;Button&quot;</span>))                            <span class="comment">// Buttons return true when clicked (most widgets return true when edited/activated)</span></span><br><span class="line">                counter++;</span><br><span class="line">            ImGui::<span class="built_in">SameLine</span>();</span><br><span class="line">            ImGui::<span class="built_in">Text</span>(<span class="string">&quot;counter = %d&quot;</span>, counter);</span><br><span class="line"></span><br><span class="line">            ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Application average %.3f ms/frame (%.1f FPS)&quot;</span>, <span class="number">1000.0f</span> / ImGui::<span class="built_in">GetIO</span>().Framerate, ImGui::<span class="built_in">GetIO</span>().Framerate);</span><br><span class="line">            ImGui::<span class="built_in">End</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Show another simple window.</span></span><br><span class="line">        <span class="keyword">if</span> (show_another_window) &#123;</span><br><span class="line">            ImGui::<span class="built_in">Begin</span>(<span class="string">&quot;Another Window&quot;</span>, &amp;show_another_window);   <span class="comment">// Pass a pointer to our bool variable (the window will have a closing button that will clear the bool when clicked)</span></span><br><span class="line">            ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Hello from another window!&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(<span class="string">&quot;Close Me&quot;</span>))</span><br><span class="line">                show_another_window = <span class="literal">false</span>;</span><br><span class="line">            ImGui::<span class="built_in">End</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Rendering</span></span><br><span class="line">        ImGui::<span class="built_in">Render</span>();</span><br><span class="line">        <span class="type">int</span> display_w, display_h;</span><br><span class="line">        <span class="built_in">glfwGetFramebufferSize</span>(window, &amp;display_w, &amp;display_h);</span><br><span class="line">        <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, display_w, display_h);</span><br><span class="line">        <span class="built_in">glClearColor</span>(clear_color.x * clear_color.w, clear_color.y * clear_color.w, clear_color.z * clear_color.w, clear_color.w);</span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">        <span class="built_in">ImGui_ImplOpenGL3_RenderDrawData</span>(ImGui::<span class="built_in">GetDrawData</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update and Render additional Platform Windows</span></span><br><span class="line">        <span class="comment">// (Platform functions may change the current OpenGL context, so we save/restore it to make it easier to paste this code elsewhere.</span></span><br><span class="line">        <span class="comment">//  For this specific demo app we could also call glfwMakeContextCurrent(window) directly)</span></span><br><span class="line">        <span class="keyword">if</span> (io.ConfigFlags &amp; ImGuiConfigFlags_ViewportsEnable) &#123;</span><br><span class="line">            GLFWwindow* backup_current_context = <span class="built_in">glfwGetCurrentContext</span>();</span><br><span class="line">            ImGui::<span class="built_in">UpdatePlatformWindows</span>();</span><br><span class="line">            ImGui::<span class="built_in">RenderPlatformWindowsDefault</span>();</span><br><span class="line">            <span class="built_in">glfwMakeContextCurrent</span>(backup_current_context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cleanup</span></span><br><span class="line">    <span class="built_in">ImGui_ImplOpenGL3_Shutdown</span>();</span><br><span class="line">    <span class="built_in">ImGui_ImplGlfw_Shutdown</span>();</span><br><span class="line">    ImGui::<span class="built_in">DestroyContext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwDestroyWindow</span>(window);</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="建立窗口"><a href="#建立窗口" class="headerlink" title="建立窗口"></a>建立窗口</h1><p>ImGuiWindowFlags参数可直接用加法叠加效果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ImGuiWindowFlags_None          = <span class="number">0</span>,</span><br><span class="line">ImGuiWindowFlags_NoTitleBar    = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,   <span class="comment">// 禁用标题栏</span></span><br><span class="line">ImGuiWindowFlags_NoResize      = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,   <span class="comment">// 使用右下角手柄禁用用户调整大小</span></span><br><span class="line">ImGuiWindowFlags_NoMove        = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,   <span class="comment">// 禁止用户移动窗口</span></span><br><span class="line">ImGuiWindowFlags_NoCollapse    = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,   <span class="comment">// 禁用用户折叠窗口双击它。也被称为窗口菜单按钮(例如在停靠节点内)  </span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (isOpen) &#123;</span><br><span class="line">          ImGui::Begin(&quot;my&quot;, &amp;isOpen, ImGuiWindowFlags_None);</span><br><span class="line">          ImGui::End();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h1 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h1><p>放入begin和end中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isOpen) &#123;</span><br><span class="line">          ImGui::<span class="built_in">Begin</span>(<span class="string">&quot;my&quot;</span>, &amp;isOpen, ImGuiWindowFlags_None);</span><br><span class="line">          <span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(<span class="string">&quot;asd1&quot;</span>)) &#123;</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;dsads&quot;</span>);<span class="comment">//按下</span></span><br><span class="line">          &#125;</span><br><span class="line">          ImGui::<span class="built_in">End</span>();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>按钮不换行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ImGui::<span class="built_in">Button</span>(<span class="string">&quot;asd1&quot;</span>);</span><br><span class="line">         ImGui::<span class="built_in">SameLine</span>();</span><br><span class="line">         ImGui::<span class="built_in">Button</span>(<span class="string">&quot;asd1&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="单选框和复选框"><a href="#单选框和复选框" class="headerlink" title="单选框和复选框"></a>单选框和复选框</h1><h2 id="单选框"><a href="#单选框" class="headerlink" title="单选框"></a>单选框</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ImGui::<span class="built_in">RadioButton</span>(<span class="string">&quot;01&quot;</span>, &amp;num, <span class="number">1</span>);</span><br><span class="line">ImGui::<span class="built_in">RadioButton</span>(<span class="string">&quot;02&quot;</span>, &amp;num, <span class="number">2</span>);</span><br><span class="line">ImGui::<span class="built_in">RadioButton</span>(<span class="string">&quot;03&quot;</span>, &amp;num, <span class="number">3</span>);</span><br><span class="line">ImGui::<span class="built_in">RadioButton</span>(<span class="string">&quot;04&quot;</span>, &amp;inta, intb);<span class="comment">//如果选到这一栏&amp;a=b</span></span><br></pre></td></tr></table></figure>

<h2 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ImGui::<span class="built_in">Checkbox</span>(<span class="string">&quot;03&quot;</span>, &amp;isOpen);</span><br><span class="line">ImGui::<span class="built_in">Checkbox</span>(<span class="string">&quot;03&quot;</span>, &amp;<span class="type">bool</span>);</span><br></pre></td></tr></table></figure>



<h1 id="折叠框"><a href="#折叠框" class="headerlink" title="折叠框"></a>折叠框</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ImGui::<span class="built_in">CollapsingHeader</span>(<span class="string">&quot;CollapsingHeader1&quot;</span> )) &#123;</span><br><span class="line">    ImGui::<span class="built_in">RadioButton</span>(<span class="string">&quot;01&quot;</span>, &amp;num, <span class="number">1</span>);</span><br><span class="line">    ImGui::<span class="built_in">RadioButton</span>(<span class="string">&quot;02&quot;</span>, &amp;num, <span class="number">2</span>);</span><br><span class="line">    ImGui::<span class="built_in">RadioButton</span>(<span class="string">&quot;03&quot;</span>, &amp;num, <span class="number">3</span>);</span><br><span class="line">    ImGui::<span class="built_in">Checkbox</span>(<span class="string">&quot;03&quot;</span>, &amp;isOpen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="文本框"><a href="#文本框" class="headerlink" title="文本框"></a>文本框</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ImGui::<span class="built_in">Text</span>(<span class="string">&quot;dsadsa&quot;</span>,<span class="string">&quot;tyt&quot;</span>);<span class="comment">//最简单的</span></span><br><span class="line">ImGui::<span class="built_in">BulletText</span>(<span class="string">&quot;BulletText&quot;</span>);<span class="comment">//带点的</span></span><br></pre></td></tr></table></figure>

<p>HelpMarker</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">HelpMarker</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* desc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ImGui::<span class="built_in">TextDisabled</span>(<span class="string">&quot;(?)&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ImGui::<span class="built_in">IsItemHovered</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ImGui::<span class="built_in">BeginTooltip</span>();</span><br><span class="line">        ImGui::<span class="built_in">PushTextWrapPos</span>(ImGui::<span class="built_in">GetFontSize</span>() * <span class="number">35.0f</span>);</span><br><span class="line">        ImGui::<span class="built_in">TextUnformatted</span>(desc);</span><br><span class="line">        ImGui::<span class="built_in">PopTextWrapPos</span>();</span><br><span class="line">        ImGui::<span class="built_in">EndTooltip</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="滑块条"><a href="#滑块条" class="headerlink" title="滑块条"></a>滑块条</h1><p>name不能一样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ImGui::<span class="built_in">SliderFloat</span>(<span class="string">&quot;float&quot;</span>, &amp;f, <span class="number">0.0f</span>, <span class="number">1.0f</span>); </span><br><span class="line">ImGui::<span class="built_in">SliderInt</span>(<span class="string">&quot;SliderInt&quot;</span>, &amp;i, <span class="number">0</span>, <span class="number">100</span>);    </span><br><span class="line">ImGui::<span class="built_in">SliderFloat</span>(<span class="string">&quot;float&quot;</span>, &amp;<span class="type">float</span>, min, max);    </span><br><span class="line">ImGui::<span class="built_in">SliderInt</span>(<span class="string">&quot;SliderInt&quot;</span>, &amp;<span class="type">int</span>, min, max); </span><br></pre></td></tr></table></figure>

<h1 id="切换中文"><a href="#切换中文" class="headerlink" title="切换中文"></a>切换中文</h1><p>c:\Windows\Fonts\选一款字体，GetGlyphRangesChineseFull（）换成这个。在字符前面加u8</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ImFont* font = io.Fonts-&gt;<span class="built_in">AddFontFromFileTTF</span>(<span class="string">&quot;c:\\Windows\\Fonts\\simkai.ttf&quot;</span>, <span class="number">18.0f</span>, <span class="literal">NULL</span>, io.Fonts-&gt;<span class="built_in">GetGlyphRangesChineseFull</span>());</span><br><span class="line">    <span class="built_in">IM_ASSERT</span>(font != <span class="literal">NULL</span>);</span><br><span class="line">ImGui::<span class="built_in">CollapsingHeader</span>(<span class="string">u8&quot;集合 CollapsingHeader1&quot;</span> );</span><br></pre></td></tr></table></figure>

<p>方法二</p>
<p>通过binary_to_compressed_c.cpp转化为数组然后建立一个头文件复制进去</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ImFont* font = io.Fonts-&gt;<span class="built_in">AddFontFromMemoryTTF</span>((<span class="type">void</span>*)font_h_data,font_h_size, <span class="number">18.0f</span>,<span class="literal">NULL</span>, io.Fonts-&gt;<span class="built_in">GetGlyphRangesChineseFull</span>());</span><br><span class="line">ImGui::<span class="built_in">CollapsingHeader</span>(<span class="string">u8&quot;集合 CollapsingHeader1&quot;</span> );</span><br></pre></td></tr></table></figure>

<h1 id="切换控件颜色"><a href="#切换控件颜色" class="headerlink" title="切换控件颜色"></a>切换控件颜色</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">style.Colors[ImGuiCol_TitleBgCollapsed] = <span class="built_in">ImColor</span>(<span class="number">180</span>, <span class="number">180</span>, <span class="number">180</span>);</span><br><span class="line">style.Colors[ImGuiCol_枚举类型] = <span class="built_in">ImColor</span>(<span class="number">180</span>, <span class="number">180</span>, <span class="number">180</span>);</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Imgui</tag>
      </tags>
  </entry>
  <entry>
    <title>Games104第6节记录</title>
    <url>/2022/04/18/Games104%E7%AC%AC6%E8%8A%82%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="地形渲染"><a href="#地形渲染" class="headerlink" title="地形渲染"></a>地形渲染</h1><h1 id="height-field-高层图"><a href="#height-field-高层图" class="headerlink" title="height field 高层图"></a>height field 高层图</h1><p><img src="https://img-blog.csdnimg.cn/1f3a296315884eb2bebd6322557d20a4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>渲染地形高层图，地形分成不同的网格，通过高层图修改相关顶点。不适用于开饭大世界</p>
<h1 id="地形渲染的方法"><a href="#地形渲染的方法" class="headerlink" title="地形渲染的方法"></a>地形渲染的方法</h1><p><img src="https://img-blog.csdnimg.cn/95f3dc406ae44389b2b7d03cb6c5ba27.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/9e3bbfc8f4754a57a3d50061e8743f46.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="三角形剖分"><a href="#三角形剖分" class="headerlink" title="三角形剖分"></a>三角形剖分</h1><h2 id="通过二叉树的结构"><a href="#通过二叉树的结构" class="headerlink" title="通过二叉树的结构"></a>通过二叉树的结构</h2><p><img src="C:\Users\27371\AppData\Roaming\Typora\typora-user-images\image-20220418201527934.png" alt="image-20220418201527934"></p>
<p><img src="C:\Users\27371\AppData\Roaming\Typora\typora-user-images\image-20220418201604789.png" alt="image-20220418201604789"></p>
<h2 id="通过四叉树的结构"><a href="#通过四叉树的结构" class="headerlink" title="通过四叉树的结构"></a>通过四叉树的结构</h2><p><img src="https://img-blog.csdnimg.cn/51c8a70b127f4ec7b9cd7de907f863cd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="求解四边形网格中的t节点"><a href="#求解四边形网格中的t节点" class="headerlink" title="求解四边形网格中的t节点"></a>求解四边形网格中的t节点</h1><p><img src="https://img-blog.csdnimg.cn/b2772608d45748c8a0016e6d7152ef1b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>多出来的点吸附连接到相邻的点，形成没面积的三角形。</p>
<h1 id="GPU表面细化"><a href="#GPU表面细化" class="headerlink" title="GPU表面细化"></a>GPU表面细化</h1><p><img src="https://img-blog.csdnimg.cn/b28bc10545384d10a5a28ff03703a71c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/9973b7fe3f6944f0b2663f382bffb3d5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="网格着色管线"><a href="#网格着色管线" class="headerlink" title="网格着色管线"></a>网格着色管线</h2><p><img src="https://img-blog.csdnimg.cn/ee1f4ad67da04b3db0d6bc5198f5c615.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="实时变化的地形"><a href="#实时变化的地形" class="headerlink" title="实时变化的地形"></a>实时变化的地形</h1><p><img src="https://img-blog.csdnimg.cn/f7b46ae2308942288b188d709b0ce8bf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="静态地形"><a href="#静态地形" class="headerlink" title="静态地形"></a>静态地形</h1><p><img src="https://img-blog.csdnimg.cn/52c5c383a1a8484eac0b5f8afc158fa2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="私货"><a href="#私货" class="headerlink" title="私货"></a>私货</h1><p><img src="https://img-blog.csdnimg.cn/4e62a23ac0574d4faea1895b691e0d57.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/80924f77f4ca481686b569caeb3e4303.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>切片合成</p>
<p><img src="https://img-blog.csdnimg.cn/c53e7148e90c4dbf88a5a95fd789a1e6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="地表材质"><a href="#地表材质" class="headerlink" title="地表材质"></a>地表材质</h1><p>极大数量的材质处理</p>
<p><img src="https://img-blog.csdnimg.cn/5ca01a86a19844acad4fc56ac26a7b57.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/b53d66dca6e043c68c82e0e44a832fdf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/4d945a74fe41480d9bfcc12d6df121cd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>通过高度的权重进行插值。</p>
<p><img src="https://img-blog.csdnimg.cn/eb0ec948ea7f44e48e9c6b48c1e614e2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/c8cfcf51ef3c4457a095436796c1003c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="视差贴图"><a href="#视差贴图" class="headerlink" title="视差贴图"></a>视差贴图</h1><p><img src="https://img-blog.csdnimg.cn/41e0bda072a24d1289c76b0be08705b5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/5115f2f8430348c68dd910106bb04ee2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="虚拟纹理"><a href="#虚拟纹理" class="headerlink" title="虚拟纹理"></a>虚拟纹理</h1><p><img src="https://img-blog.csdnimg.cn/5a030a524d1144bfae8f0909275172c4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/c3b477b063e04b67805a380b4170c489.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="浮点数的精度溢出"><a href="#浮点数的精度溢出" class="headerlink" title="浮点数的精度溢出"></a>浮点数的精度溢出</h1><p><img src="https://img-blog.csdnimg.cn/712a7a7757c74c1ea8b14199f5698895.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p> <img src="https://img-blog.csdnimg.cn/ee8d19be7f4d4299bbcd34d0c5ebd713.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="树渲染"><a href="#树渲染" class="headerlink" title="树渲染"></a>树渲染</h1><p><img src="https://img-blog.csdnimg.cn/262589ac9e6d4371a3554433d6ab5fd4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="装饰渲染"><a href="#装饰渲染" class="headerlink" title="装饰渲染"></a>装饰渲染</h1><p><img src="https://img-blog.csdnimg.cn/0959414e0e444fe1a145f87c193df974.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="道路系统和贴片系统"><a href="#道路系统和贴片系统" class="headerlink" title="道路系统和贴片系统"></a>道路系统和贴片系统</h1><p><img src="https://img-blog.csdnimg.cn/10d93029215c461b959eb59ba1f4add6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="天空之神"><a href="#天空之神" class="headerlink" title="天空之神"></a>天空之神</h1><p><img src="https://img-blog.csdnimg.cn/87c63836742249bd938a4909ebf25827.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="大气"><a href="#大气" class="headerlink" title="大气"></a>大气</h1><p><img src="https://img-blog.csdnimg.cn/3bb850a1751043b6b51ab54be40f2237.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/854fe9d678a548da83d805afe396430d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>进入物体进行光源散射</p>
<p><img src="https://img-blog.csdnimg.cn/c5ceb72545cc49c0b1da6ea57d91e80e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/1713c46533144b7eb454870ed605e303.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/86b7a14d47e84564ba7ae43552ba9dd4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/de0546578d844d95be9046335ba5761f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/1808ff9b4dd841458005bdf98e9b8b8f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/f39389db7e0b4573a67d31a3af6e9942.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>h海拔高度，1+cos的平方是腰果状</p>
<h2 id="米氏散射"><a href="#米氏散射" class="headerlink" title="米氏散射"></a>米氏散射</h2><p>气溶胶是米氏散射</p>
<p><img src="https://img-blog.csdnimg.cn/d4283b7eac4d48c4806762f6699756ed.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/7e94e41425104bb6a0329a72c464ba18.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="能力的吸收"><a href="#能力的吸收" class="headerlink" title="能力的吸收"></a>能力的吸收</h1><p><img src="https://img-blog.csdnimg.cn/690abb6572d24dd2a1d5fd0a187c8bc5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="单次散射和多次散射"><a href="#单次散射和多次散射" class="headerlink" title="单次散射和多次散射"></a>单次散射和多次散射</h1><p><img src="https://img-blog.csdnimg.cn/01b91e0debde4438a4837a4ee5c82b80.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>对比</p>
<p><img src="https://img-blog.csdnimg.cn/097ce9f8070e49498442952fd1cd0803.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><p><img src="https://img-blog.csdnimg.cn/8e98b05c9d2348aa8bf2fc2de088fea3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="空气通透度"><a href="#空气通透度" class="headerlink" title="空气通透度"></a>空气通透度</h1><p><img src="https://img-blog.csdnimg.cn/53b71c9f42d84bcd85601340b61fba13.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/f6b3dd98eeec4af3aa5951ad119bfdac.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/31cd0e5e28ef44bea7453fc983271fa7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>预计算大气散射的挑战</p>
<p>预先计算成本</p>
<p>​    ．多次散射迭代是非常昂贵的</p>
<p>难在低端设备上生成大气LUT移动)环境的创作和动态调整艺术家不能随意改变散射系数很难渲染像天气从阳光到雨雾，行星之间的太空旅行运行时渲染成本昂贵的逐像素多维高维纹理采样用于透光性LUT和多散射LUT(总是需要向下采样以提高效率)</p>
<p><img src="https://img-blog.csdnimg.cn/e97186500fa04251a32fd4a548efb5eb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/283cb8dab0924a3187f20c45654c70bf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/6244c6d8142b4b5f80ef314513a95297.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="画云"><a href="#画云" class="headerlink" title="画云"></a>画云</h1><p><img src="https://img-blog.csdnimg.cn/0ead17ada0284ad3beb5c644f29904a8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="用网格形成云"><a href="#用网格形成云" class="headerlink" title="用网格形成云"></a>用网格形成云</h2><p><img src="https://img-blog.csdnimg.cn/1247df66765e4c30928dc6378e5cab21.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="贴图"><a href="#贴图" class="headerlink" title="贴图"></a>贴图</h2><p><img src="https://img-blog.csdnimg.cn/b798204efc5c4c4d807c0c7d01ee5fa1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="体积云"><a href="#体积云" class="headerlink" title="体积云"></a>体积云</h2><p><img src="https://img-blog.csdnimg.cn/2a15650d38f54599bea990859653a365.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>优点．真实的云的形状可能出现大规模云支持动态天气动态体积照明和阴影</p>
<p>缺点必须考虑效率</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="https://img-blog.csdnimg.cn/b2e765a167e5499f86102f8c001f0264.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/a990f509fefb431ea179c753a8e6cdc2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/f4f2ae4748a54d5884ba5f9b53c3dc42.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/9a96e0497ecc4f9b807176f6449a78c4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>引擎制作</tag>
      </tags>
  </entry>
  <entry>
    <title>大话设计模式观后感之创建型模式</title>
    <url>/2022/04/22/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%82%E5%90%8E%E6%84%9F%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><h2 id="为什么我们需要创建型模式"><a href="#为什么我们需要创建型模式" class="headerlink" title="为什么我们需要创建型模式?"></a>为什么我们需要创建型模式?</h2><p><strong>创建型模式隐藏了这些类的实例是如何被创建和放在一起，整个系统关于这些对象所知道的是由抽象类所定义的接口。这样，创建型模式在创建了什么、谁创建它、它是怎么被创建的，以及何时创建这些方面提供了很大的灵活性。</strong></p>
<p>当一个系统应该独立于它的产品创建、构成和表示时，应该考虑用创建性模式。<strong>建立相应数目的原型并克隆它们通常比每次用合适的状态手工实例化该类更方便一些</strong></p>
<h2 id="松耦合的理解"><a href="#松耦合的理解" class="headerlink" title="松耦合的理解"></a>松耦合的理解</h2><p>这个问题首先要谈谈<strong>内聚性与耦合性</strong><br><strong>内聚性</strong>描述的是一个例程内部组成部分之间相互联系的紧密程度。<br><strong>耦合性</strong>描述的是一个例程与其他例程之间联系的紧密程度。<br>软件开发的目标应该是创建这样的例程:<strong>内部完整，也就是高内聚</strong>，而与<strong>其他例程之间的联系则是小巧、直接、可见、灵活的，这就是松耦合</strong>。</p>
<h2 id="如何理解创建型模式存在的意义"><a href="#如何理解创建型模式存在的意义" class="headerlink" title="如何理解创建型模式存在的意义?"></a>如何理解创建型模式存在的意义?</h2><p><strong>创建型模式抽象了实例化的过程</strong>。它们帮助一个系统独立于如何创建、组合和表示它的那些对象。创建型模式都会将关于该系统使用哪些具体的类的信息封装起来。<strong>允许客户用结构和功能差别很大的‘产品’对象配置一个系统</strong>。<strong>配置</strong>可以是静态的，即在编译时指定，也可以是动态的,就是运行时再指定。</p>
<h2 id="工厂方法的优势"><a href="#工厂方法的优势" class="headerlink" title="工厂方法的优势"></a>工厂方法的优势</h2><p>我觉得她们几位都可能设计出比我更加灵活的代码，但她们的实现也相对就更加复杂。<strong>通常设计应该是从工厂方法开始</strong>，<strong>当设计者发现需要更大的灵活性时，设计便会向其他创建型模式演化。当设计者在设计标准之间进行权衡的时候,了解多个创建型模式可以给设计者更多的选择余地.</strong></p>
<h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p><strong>简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。</strong><br>解决如何实例化对象的问题<br>不属于23种GOF设计模式之一，不符合开放封闭原则每一次都要修改类。<br><img src="https://img-blog.csdnimg.cn/c6b12a7fb0d74c63a771e811a73208db.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><p><strong>工厂方法模式，定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</strong><br>将实例化方法写在concreteCreator类里面<br><strong>工厂方法模式和简单工厂的区别</strong>：简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。</p>
<p><strong>缺点</strong>：由于每加一个产品，就需要加一个产品工厂的类，增加了额外的开发量。”<img src="https://img-blog.csdnimg.cn/80939d98d2f84c4aa4bcff62bed03321.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>通过加分工厂实例化加法运算类</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IFactory</span>&#123;</span><br><span class="line">  <span class="function">Operation <span class="title">CreateOperation</span> ()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">AddFactory</span> : <span class="title">IFactory</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Operation <span class="title">Create0peration</span> ()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OperationAdd ();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/7e1c91e63d1d400fb705934cd6d1fcc4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><h2 id="原版"><a href="#原版" class="headerlink" title="原版"></a>原版</h2><p><strong>抽象工厂模式是提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</strong><br>多个产品有一个或多个实现方式，就把同产品系列的抽象。工厂和产品都进行抽象<br> <strong>优点</strong></p>
<ol>
<li>最大的好处便是易于交换产品系列，由于具体工厂类，例如IFactory factory &#x3D;new AccessFactory().在一个应用中只需要在初始化的时候出现一次，这就使得改变一个应用的具体工厂变得非常容易，它只需要改变具体工厂即可使用不同的产品配置。</li>
<li>它让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户代码中。</li>
</ol>
<p><strong>缺点</strong>修改时需要添加三个类，并需要修改抽象工厂类及抽象工厂子类。<br><img src="https://img-blog.csdnimg.cn/dad02109c712469195f3ce0e0f7cf5bf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="简单工厂来改进"><a href="#简单工厂来改进" class="headerlink" title="简单工厂来改进"></a>简单工厂来改进</h2><p>与其用那么多工厂类，不如直接用一个简单工厂来实现，抛弃了IFactory、SqlserverFactory和 AccessFactory三个工厂类，取而代之的是DataAccess类，由于事先设置了db的值(Sqlserver或Access)，所以简单工厂的方法都不需要输入参数，这样在客户端就只需要 DataAccess.CreateUser()和 DataAccess.CreateDepartment()来生成具体的数据库访问类实例，客户端没有出现任何一个SOL Server或 Access的字样，达到了解耦的目的。这样就需要在 DataAccess类中每个方法的swicth 中加 case了。<br><img src="https://img-blog.csdnimg.cn/4a8bdc7ec84741f9a0c9a5365d62c2b0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="男人的浪漫–反射"><a href="#男人的浪漫–反射" class="headerlink" title="男人的浪漫–反射"></a>男人的浪漫–反射</h2><p>Assembly.Load(“程序集名称”).CreateInstance(“命名空间.类名称”)<br><strong>所有在用简单工厂的地方，都可以考虑用反射技术来去除switch或 if，解除分支判断带来的耦合。</strong><br><img src="https://img-blog.csdnimg.cn/73e8c0b4d68f4590adbd43fd7cad44cf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Syetem.Reflection<span class="comment">//引入反射，必须要写</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">DataAccess</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">string</span> AssemblyName = <span class="string">&quot;抽象工厂模式&quot;</span>;<span class="comment">//程序集名称</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">string</span> db = <span class="string">&quot;Sqlserver&quot;</span>;<span class="comment">//数据库名称，可替换成Access</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IUser <span class="title">CreateUser</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">string</span> className = AssemblyName + <span class="string">&quot;.&quot;</span> +db +<span class="string">&quot;User&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> (IUser)Assembly.Load (AssemblyName).CreateInstance (className);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IDepartment <span class="title">CreateDepartment</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">string</span> className = AssemblyName + <span class="string">&quot;.&quot;</span> +db+ <span class="string">&quot;Department&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> (IDepartment)Assembly.Load (AssemblyName).CreateInstance (className) ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p><strong>单例模式（Singleton)，保证一个类仅有一个实例，并提供一个访问它的全局访问点。</strong><br>通常我们可以让一个全局变量使得一个对象被访问，但它不能防止你实例化多个对象。一个最好的办法就是，让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的方法。<br><img src="https://img-blog.csdnimg.cn/e16551597fad446794fc216bf01469fe.png" alt="在这里插入图片描述"></p>
<h2 id="单线程的实现"><a href="#单线程的实现" class="headerlink" title="单线程的实现"></a>单线程的实现</h2><p>Singleton类,定义一个GetInstance操作，允许客户访问它的唯一实例。GetInstance是一个静态方法，主要负责创建自己的唯一实例。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> singleton instance;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> ()</span>&#123;<span class="comment">//构造方法让其private，这就堵死了外界利用</span></span><br><span class="line">            <span class="comment">//new创建此类实例的可能</span></span><br><span class="line">  )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> singleton <span class="title">GetInstance</span> ()</span>&#123;</span><br><span class="line">  <span class="comment">//此方法是获得本类实例的唯一全局访问点</span></span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="comment">//若实例不存在，则new一个新实例，</span></span><br><span class="line">    <span class="comment">//否则返回已有的实例</span></span><br><span class="line">      instance =<span class="keyword">new</span> Singleton ();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端代码</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span> (<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function">Singleton s1</span> = Singleton.GetInstance();Singleton s2 -Singleton.GetInstance ();</span><br><span class="line"><span class="keyword">if</span> (s1 ==s2)</span><br><span class="line">&#123;</span><br><span class="line">Console.writeLine(<span class="string">&quot;两个对象是相同的实例。&quot;</span>);</span><br><span class="line">)</span><br><span class="line">Console.Read() ;</span><br></pre></td></tr></table></figure>
<h2 id="多线程单例"><a href="#多线程单例" class="headerlink" title="多线程单例"></a>多线程单例</h2><p><strong>lock 是确保当一个线程位于代码的临界区时，另一个线程不进入临界区。如果其他线程试图进入锁定的代码，则它将一直等待(即被阻止)，直到该对象被释放。</strong><br>双重锁定</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">singleton</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> singleton instance;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">object</span> syncRoot= <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">singleton</span> ()</span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> singleton <span class="title">GetInstance</span>()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;<span class="comment">//先判断实例是否存在，不存在再加锁处理</span></span><br><span class="line">      <span class="keyword">lock</span> (syncRoot)&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">          instance = <span class="keyword">new</span> singleton ();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p><strong>建造者模式（Builder)，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</strong><br>如果我们用了建造者模式，那么用户就只需指定需要建造的类型就可以得到它们，而具体建造的过程和细节就不需知道了。<br><strong>用处</strong>创建一些复杂的对象，这些对象内部构建间的建造顺序通常是稳定的，但对象内部的构建通常面临着复杂的变化。<br>建造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时适用的模式。<br><strong>好处</strong>就是使得建造代码与表示代码分离，由于建造者隐藏了该产品是如何组装的，所以若需要改变一个产品的内部表示，只需要再定义一个具体的建造者就可以了。<br><img src="https://img-blog.csdnimg.cn/2a78395f84ae4b99a70a8a9f2a816d88.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>Product类——产品类，由多个部件组成。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Product</span>&#123;</span><br><span class="line">  IList&lt;<span class="built_in">string</span>&gt; parts =<span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span> (<span class="params"><span class="built_in">string</span> part</span>)<span class="comment">//添加产品部件&#123;</span></span></span><br><span class="line"><span class="function">    parts. <span class="title">Add</span> (<span class="params">part</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span> ()</span>&#123;</span><br><span class="line">    console.writeLine(<span class="string">&quot;\n产品创建―-—-&quot;</span>);<span class="comment">//列举所有的产品部件</span></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">string</span> part <span class="keyword">in</span> parts)&#123;</span><br><span class="line">      Console.writeLine (part);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Builder类——抽象建造者类，确定产品由两个部件 PartA和PartB组成，并声明一个得到产品建造后结果的方法GetResult。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Builder</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">BuildPartA</span> ()</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">BuildPartB</span> ()</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">GetResult</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConcreteBuilder1类——具体建造者类。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteBuilder1</span> : <span class="title">Builder</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Product product = <span class="keyword">new</span> Product ();</span><br><span class="line">  <span class="comment">//建造具体的两个部件是部件A和部件B</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">BuildPartA</span> ()</span>&#123;</span><br><span class="line">    product.Add(<span class="string">&quot;部件A&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">BuildPartB</span>()</span>&#123;</span><br><span class="line">    product. Add(<span class="string">&quot;部件B&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Product <span class="title">GetResult</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> product;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConcreteBuilder2类——具体建造者类。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteBuilder2</span> :<span class="title">Builder</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Product product = <span class="keyword">new</span> Product ();</span><br><span class="line">  <span class="comment">//建造具体的两个部件是部件X和部件Y</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">BuildPartA</span>()</span>&#123;</span><br><span class="line">    product. Add(<span class="string">&quot;部件x&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">BuildPartB</span>()</span>&#123;</span><br><span class="line">    product.Add(<span class="string">&quot;部件Y&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Product <span class="title">GetResult</span>()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> product;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Director类——指挥者类。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Director</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Construct</span>(<span class="params">Builder builder</span>)</span>&#123;<span class="comment">//用来指挥建造过程</span></span><br><span class="line">    builder .BuildPartA ();</span><br><span class="line">    builder. BuildPartB();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>例子</strong><br><img src="https://img-blog.csdnimg.cn/a5801e7081774062bcb0c9fbc8366f13.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><p><strong>原型模式（Prototype)，用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</strong><br>“原型模式其实就是从一个对象再创建另外一个可定制的对象，而且不需知道任何创建的细节。</p>
<h2 id="原版-1"><a href="#原版-1" class="headerlink" title="原版"></a>原版</h2><p><img src="https://img-blog.csdnimg.cn/c2b2dd35ce324cbcbaf37f8d69c08b8d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>原型类</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Prototype</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">string</span> id;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Prototype</span> (<span class="params"><span class="built_in">string</span> id</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">string</span> Id&#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; <span class="keyword">return</span> id; )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Prototype <span class="title">Clone</span> ()</span>; <span class="comment">//抽象类关键就是有这样一个Clone方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体原型类</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcretePrototypel</span> : <span class="title">Prototype</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConcretePrototype1</span> (<span class="params"><span class="built_in">string</span> id</span>): <span class="title">base</span> (<span class="params">id</span>)</span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Prototype <span class="title">Clone</span> ()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Prototype)<span class="keyword">this</span>.MemberwiseClone() ;</span><br><span class="line">    <span class="comment">//创建当前对象的浅表副本。方法是创建一个新对象，然后将当前对象</span></span><br><span class="line">    <span class="comment">//的非静态字段复制到该新对象。如果字段是值类型的，则对该字段执</span></span><br><span class="line">    <span class="comment">//行逐位复制。如果字段是引用类型,则复制引用但不复制引用的对象;</span></span><br><span class="line">    <span class="comment">//因此,原始对象及其副本引用同对象[MSDN]</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端代码</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span> (<span class="params"><span class="built_in">string</span>[]args</span>)</span>&#123;</span><br><span class="line">ConcretePrototypel p1 = <span class="keyword">new</span> ConcretePrototype1(<span class="string">&quot;I&quot;</span>);</span><br><span class="line">ConcretePrototypel cl =(ConcretePrototype1)p1.clone() ;</span><br><span class="line">Console.writeLine ( <span class="string">&quot;cloned: &#123;0&#125;&quot;</span>, c1.Id);</span><br><span class="line">Console.Read() ;<span class="comment">//克隆类ConcretePrototype1的对象pl就能得到新的实例cl</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="浅复制和深复制"><a href="#浅复制和深复制" class="headerlink" title="浅复制和深复制"></a>浅复制和深复制</h2><p><strong>浅复制</strong>，被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。<br><strong>深复制</strong>，深复制把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。</p>
<h2 id="Csharp更新"><a href="#Csharp更新" class="headerlink" title="Csharp更新"></a>Csharp更新</h2><p>.NET在System命名空间中提供了ICloneable接口,其中就是唯一的一个方法Clone()，这样你就只需要实现这个接口就可以完成原型模式了。<br><img src="https://img-blog.csdnimg.cn/f85765cd1eff48dd939b77c297a1dfaf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>大话设计模式观后感之设计原则</title>
    <url>/2022/04/18/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%82%E5%90%8E%E6%84%9F%E4%B9%8B%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h1 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h1><p><strong>就一个类而言，应该仅有一个引起它变化的原因</strong></p>
<p>一个类不应该搞得很复杂，当傅老师黑魂教程中处理玩家数据时新建一个ActorData来装载玩家数据，ActorController来改变数据。一个类承担某种职责。</p>
<h1 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h1><p><strong>子类型必须能够代替掉它们的父类型</strong></p>
<p>可以理解为多态，只有子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正的被复用，而子类也能够在父类的基础上增加新行为。如果鸟类里面加入了飞的功能，那么企鹅类是不会飞的，所以不能继承。由于子类型的可替换性才使得使用父类类型的模块无需修改的情况下可以扩展</p>
<p><img src="https://img-blog.csdnimg.cn/1a66f8085c694ae5a3461d73d0d931e1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h1><p><strong>软件实体（类、模块、函数等）应该可以扩展，但是不可修改</strong></p>
<p>原来的代码能跑就不要去动它，要修改可以将其组合或者继承变成新的类进行扩展，书上有一点说的很好，在最开始的时候假设程序不会发生变化，当变化发生时再去创建抽象隔离，以此简化发生的同类变化，emm，虽然重构麻烦，如果项目不是很大可以考虑，毕竟为了后面长期变化做准备，刚看完的时候就是想太多，设计来设计去根本没动手，不如先动手做一个原型以后再改</p>
<h1 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h1><ol>
<li><p><strong>高层模块不应该依赖低层模块，应该都依赖于抽象</strong></p>
</li>
<li><p><strong>抽象不应该依赖于细节，细节应该依赖于抽象</strong></p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/df184bf1522545cd93f707a36ae41786.png" alt="在这里插入图片描述"></p>
<p>高层模块通过调用低层模块中的函数进行数据处理。</p>
<p><img src="https://img-blog.csdnimg.cn/e42fbe4c143a43ac84a250da25209b85.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>高层模块关联抽象，高层模块可以调用抽象类中的函数，而不同低层模块可以复用函数，只需要实例化不同的低层模块便能达到灵活切换不同的低层模块函数。</p>
<p>也叫依赖倒转原则，依赖倒转是面向对象设计的标志，整个程序所有的依赖关系都应该是终止于抽象类或接口。</p>
<h1 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h1><p><strong>如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，如果一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</strong></p>
<p>也叫最少知识原则，就像mvc架构升级到mvp架构一样，取消了m到v的直接联系。在类的结构设计上，每一个类都应当尽量降低成员的访问权限。</p>
<p>迪米特法则其根本思想，是强调了类之间的松耦合。我们在程序设计时，类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。也就是说,信息的隐藏促进了软件的复用。”</p>
<h1 id="合成-x2F-聚合复用原则"><a href="#合成-x2F-聚合复用原则" class="headerlink" title="合成&#x2F;聚合复用原则"></a>合成&#x2F;聚合复用原则</h1><p><strong>尽量使用合成&#x2F;聚合，尽量不要使用类继承</strong></p>
<p>合成(Composition，也有翻译成组合）和聚合(Aggregation)都是关联的特殊种类。<strong>聚合</strong>表示一种<strong>弱的‘拥有’关系</strong>，体现的是A对象可以包含B对象，但B对象不是A对象的一部分;<strong>合成</strong>则是<strong>一种强的‘拥有’关系</strong>，体现了严格的部分和整体的关系，部分和整体的生命周期一样。优先使用对象的合成&#x2F;聚合将有助你保持每个类被封装，并集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。</p>
<p><img src="https://img-blog.csdnimg.cn/301f6b5c5831472ebfbf265c5245d7f3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_13,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>大雁有两个翅膀，翅膀与大雁是部分和整体的关系，并且它们的生命周期是相同的，于是大雁和翅膀就是合成关系。而大雁是群居动物，所以每只大雁都是属于一个雁群，一个雁群可以有多只大雁，所以大雁和雁群是聚合关系。”</p>
<p><img src="https://img-blog.csdnimg.cn/b5d25abb73f649078c4d01c5620d5c58.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/eb3dfee399464d04b1f99aac7a2511fa.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h1><p>大话设计模式没讲此原则，个人猜测作者应该是认为和单一职责原则差不多吧</p>
<p><strong>客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。</strong></p>
<p>将一个复杂且大的接口拆分成小的几个接口，是每一个接口的功能更单一。更灵活。</p>
<h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p><img src="https://img-blog.csdnimg.cn/cc94713d128847099c666cfec66c7a30.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>-Model(数据层):负责管理业务逻辑和处理网络或数据库API。<br>-View(视图层):让数据层的数据可视化。在Android中对应用户交互、UI绘制等。<br>-Controller (逻辑层)∶获得用户行为的通知，并根据需要更新Model。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>Model类没有对Android类的任何引用，因此可以直接进行单元测试。Controller不会扩展或实现任何Android类，并且应该引用View的接口类。通过这种方式，也可以对控制器进行单元测试。如果View遵循单一责任原则，那么它们的角色就是为每个用户事件更新Controller，只显示Model中的数据，而不实现任何业务逻辑。在这种理想的作用下，UI测试应该足以覆盖所有的View的功能。<br>总结以上介绍我们发现，MVC模式高度支持职责的分离。这种优势不仅增加了代码的可测试性，而且使其更容易扩展，从而可以相当容易地实现新功能。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>代码相对冗余。我们知道，MVC模式中View对Model是有着强依赖的。当View非常复杂的时候，为了最小化View中的逻辑，Model应该能够为要显示的每个视图提供可测试的方法——这将增加大量的类和方法。<br>灵活性较低。由于View依赖于Controller和TModel，Ul逻辑中的一个更改可能导致需要修改很多类，这降低了灵活性，并且导致UI难以测试。<br>可维护性低。Android的视图组件中，有着非常明显的生命周期，如Activity、Fragment等。对于MVC模式，我们有时不得不将处理视图逻辑的代码都写在这些组件中，造成它们十分臃肿。<br>所以,Android中最初的MVC架构问题显而易见:过于臃肿的<br>Controller层大大降低了工程的可维护性及可测试性。</p>
<h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p><img src="https://img-blog.csdnimg.cn/06817a26d2174c74b361f96eeb2f0d59.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>Model(数据层)。负责管理业务逻辑和处理网络或数据库API。</p>
<p>View(视图层)。显示数据并将用户操作的信息通知给Presenter。</p>
<p>Presenter(逻辑层)。从Model中检索数据，应用UI逻辑并管理View的状态，决定显示什么，以及对View的事件做出响应。</p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>相对于MVC，MVP模式设计思路的核心是提出了Presenter层，它是View层与Model层沟通的桥梁，对业务逻辑进行处理。这更符合了我们理想中的单一职责原则。</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li><p>接口粒度难以掌控。MVP模式将模块职责进行了良好的分离。但在开发小规模App或原型时，这似乎增加了开销——对于每个业务场景，我们都要写Activity-View-Presenter-Contract这4个类。为了缓解这种情况，一些开发者删除了Contract接口类和Presenter的接口。另外，Presenter 与View的交互是通过接口实现的,如果接口粒度过大，解耦程度就不高，反之会造成接口数量暴增的情况。<br>从工程的严谨角度来说，这或许并不是缺点，只是创造一个良好工程架构带来的额外工作量。</p>
</li>
<li><p>Presenter逻辑容易过重。当我们将UI的逻辑移动到Presenter中时，Presenter变成了有数千行代码的类，或许会难以维护。要解决这个问题，我们只可能更多地拆分代码，创建便于单元测试的单一职责的类。</p>
</li>
<li><p>Presenter和View相互引用。我们在Presenter和View中都会保持一份对方的引用，所以需要用subscribe和unsubscribe来绑定和解除绑定。在操作UI的时候，我们需要判断UI生命周期，否则容易造成内存泄漏。</p>
</li>
</ol>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p><img src="https://img-blog.csdnimg.cn/8ddd36092c1a43f6a7cc3bd2e47c8758.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>Model(数据模型):与ViewModel配合，可以获取和保存数据。</p>
<p>View(视图):即将用户的动作通知给ViewModel(视图模型)。</p>
<p>ViewModel(视图模型):暴露公共属性与View相关的数据流，通常为Model和View的绑定关系。</p>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><p>如果MVP模式意味着Presenter直接告诉View要显示的内容，那么在MVVM中, ViewModel会公开Views可以绑定的事件流。这样ViewModel不再需要保持对View的引用，但发挥了Presenter一样的作用。这也意味着MVP模式所需的所有接口现在都被删除了。这对介意接口数量过多的开发者来说是个福音。<br>View还会通知ViewModel进行不同的操作。因此，MVM模式支持View和ViewModel之间的双向数据绑定，并且View和ViewModel之间存在多对一关系。View具有对ViewModel的引用，但ViewModel没有关于View的信息。因为数据的使用者应该知道生产者，但生产者ViewModel不需要知道，也不关心谁使用数据。</p>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>1）需要更多精力定位Bug。由于双向绑定，视图中的异常排查起来会比较麻烦，你需要检查View中的代码，还需要检查Model中的代码。另外你可能多处复用了Model，一个地方导致的异常可能会扩散到其他地方，定位错误源可能并不会太简单。<br>2）通用的View需要更好的设计。当一个View要变成通用组件时，该View对应的Model通常不能复用。在整体架构设计不够完善时，我们很容易创建一些冗余的Model。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Games104第7节记录</title>
    <url>/2022/04/18/Games104%E7%AC%AC7%E8%8A%82%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="环境光遮蔽-Ambient-Occasion"><a href="#环境光遮蔽-Ambient-Occasion" class="headerlink" title="环境光遮蔽(Ambient Occasion)"></a>环境光遮蔽(Ambient Occasion)</h1><p><img src="https://img-blog.csdnimg.cn/25497739fd2c430fae63e9c0192b6234.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="预计算AO"><a href="#预计算AO" class="headerlink" title="预计算AO"></a>预计算AO</h2><p>采用光线追踪离线计算AO，并将结果存储到纹理中，这种方法广泛应用于物体建模过程中：</p>
<ol>
<li>额外的仓储成本</li>
<li>仅适用于静态对象<br><img src="https://img-blog.csdnimg.cn/91d8714a28b7428c963f92a76f7e854f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h2 id="屏幕空间环境遮挡"><a href="#屏幕空间环境遮挡" class="headerlink" title="屏幕空间环境遮挡"></a>屏幕空间环境遮挡</h2></li>
<li>在视空间中每个像素p周围的球体中生成N个随机样本</li>
<li>通过比较深度与深度缓冲来测试样本闭塞</li>
<li>样本点的平均可见性来近似AO<br><img src="https://img-blog.csdnimg.cn/dd1c6131d69b4539aa3452e12a467af3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h2 id="SSAO"><a href="#SSAO" class="headerlink" title="SSAO+"></a>SSAO+</h2>回想一下AO方程实际上是在法向半球上做的<br><img src="https://img-blog.csdnimg.cn/8c2c90658c464a84b73167374cb2973a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h2 id="HBAO-Horizon-based-Ambient-Occlusion"><a href="#HBAO-Horizon-based-Ambient-Occlusion" class="headerlink" title="HBAO Horizon-based Ambient Occlusion"></a>HBAO Horizon-based Ambient Occlusion</h2>使用深度缓冲作为高度场<br>在水平角以下的2D表面射线被遮挡<br><img src="https://img-blog.csdnimg.cn/554096e301f54e76989ddc0984873d8d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li>
<li>使用深度缓冲区作为2D表面上的高度场</li>
<li>从水平角直接在2D和近似AO中跟踪射线<br><img src="https://img-blog.csdnimg.cn/a440fac09190446d88d967ab96d47ee8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h2 id="GTAO-Ground-Truth-based-Ambient-Occlusion"><a href="#GTAO-Ground-Truth-based-Ambient-Occlusion" class="headerlink" title="GTAO Ground Truth-based Ambient Occlusion"></a>GTAO Ground Truth-based Ambient Occlusion</h2>GTAO引入了缺失余弦因子，消除了衰减函数，并增加了多跳的快速逼近<br><img src="https://img-blog.csdnimg.cn/362bb3fe599b4bcaa5ea1360c804adfc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/5153c9a6b13b4c8f93c46a722de61109.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h2 id="Ray-Tracing-Ambient-Occlusion"><a href="#Ray-Tracing-Ambient-Occlusion" class="headerlink" title="Ray-Tracing Ambient Occlusion"></a>Ray-Tracing Ambient Occlusion</h2>使用RTT硬件从每个屏幕像素投射光线<br>1 spp(每像素样本)对远场遮挡效果很好<br>用2-4 spp，可以恢复接触区域的详细闭塞<br><img src="https://img-blog.csdnimg.cn/978c78d71f1d46afabecc8b3010603b4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h1 id="fog"><a href="#fog" class="headerlink" title="fog"></a>fog</h1><img src="https://img-blog.csdnimg.cn/f4a3fc3b53214eedab2eb1fd5991ca22.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h2 id="high-fog"><a href="#high-fog" class="headerlink" title="high fog"></a>high fog</h2><img src="https://img-blog.csdnimg.cn/57afe1dec66f4d09907d9622965a6dc9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h2 id="Voxel-based-Volumetric-Fog基于体素化的雾"><a href="#Voxel-based-Volumetric-Fog基于体素化的雾" class="headerlink" title="Voxel-based Volumetric Fog基于体素化的雾"></a>Voxel-based Volumetric Fog基于体素化的雾</h2><img src="https://img-blog.csdnimg.cn/d978ccea3d334dc685cc04f48ab16f16.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h1 id="反走样-Anti-aliasing"><a href="#反走样-Anti-aliasing" class="headerlink" title="反走样 Anti-aliasing"></a>反走样 Anti-aliasing</h1><h2 id="反走样的原因"><a href="#反走样的原因" class="headerlink" title="反走样的原因"></a>反走样的原因</h2>混叠是由高频信号与高频信号产生的一系列图像伪影。有限的渲染分辨率的采样不足<img src="https://img-blog.csdnimg.cn/1233c40b79d14bafb15336412c5494b1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2>基于屏幕的抗锯齿方案的一般策略是使用抽样模式获得更多的样本，然后加权和样本相加产生像素颜色<br><img src="https://img-blog.csdnimg.cn/446246fe04bf424d8c6b28c8bf863275.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h2 id="Super-sample-AA-SSAA-and-Multi-sample-AA-MSAA"><a href="#Super-sample-AA-SSAA-and-Multi-sample-AA-MSAA" class="headerlink" title="Super-sample AA (SSAA) and Multi-sample AA (MSAA)"></a>Super-sample AA (SSAA) and Multi-sample AA (MSAA)</h2><img src="https://img-blog.csdnimg.cn/9941e98336d244aba3ea71333c0832f4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h2 id="FXAA-Fast-Approximate-Anti-aliasing"><a href="#FXAA-Fast-Approximate-Anti-aliasing" class="headerlink" title="FXAA (Fast Approximate Anti-aliasing)"></a>FXAA (Fast Approximate Anti-aliasing)</h2>基于1x渲染图像的抗锯齿．<br>根据亮度找到边缘像素<br>计算每个边缘像素的偏移量．<br>重新采样边缘像素的偏移量与邻居混合<br><img src="https://img-blog.csdnimg.cn/9ec04444a29c44898830afa18d7a2975.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/43fa97ef25c948a78de2e1c54b01e023.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/68d5ce1ee75a4efa8c5188e85dd0549c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>Blend Nearby Pixels<br><img src="https://img-blog.csdnimg.cn/e14713690b41467aa516176f578e9442.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h2 id="TAA-Temporal-Anti-aliasing"><a href="#TAA-Temporal-Anti-aliasing" class="headerlink" title="TAA (Temporal Anti-aliasing)"></a>TAA (Temporal Anti-aliasing)</h2>利用时空滤波方法提高机管局运动稳定性<br><img src="https://img-blog.csdnimg.cn/828e4a38111140a396950dd1580e1300.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h1 id="Post-process"><a href="#Post-process" class="headerlink" title="Post-process"></a>Post-process</h1>在3D图形中，后处理是指将应用于最终图像的任何算法。这可以是出于风格上的原因(色彩校正、对比等)，也可以是出于现实原因(色调映射、景深等)。<br><img src="https://img-blog.csdnimg.cn/b58634d980a94625a3ce7bd5c725d53c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h2 id="Bloom"><a href="#Bloom" class="headerlink" title="Bloom"></a>Bloom</h2><img src="https://img-blog.csdnimg.cn/2471e71edfb24440917d9cd803b1cc5a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h3 id="Detect-Bright-Area-by-Threshold"><a href="#Detect-Bright-Area-by-Threshold" class="headerlink" title="Detect Bright Area by Threshold"></a>Detect Bright Area by Threshold</h3><img src="https://img-blog.csdnimg.cn/b70e8321822e4a8681200db64f17e995.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/1d3f717cfbee4b5e8f9626e83704f0e0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/c639aa87c64f44faa20d3c6151b58840.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li>
</ol>
<h2 id="Tone-Mapping"><a href="#Tone-Mapping" class="headerlink" title="Tone Mapping"></a>Tone Mapping</h2><ol>
<li>没有办法在SDR设备中直接显示HDR图像</li>
<li>色调映射功能的目的是将宽范围的高动态范围(HDR)颜色映射到显示器可以输出的标准动态范围(SDR)<br><img src="https://img-blog.csdnimg.cn/5cd07ddc05b94031b7f6ce0fae191dd8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h3 id="Tone-Mapping-Curve"><a href="#Tone-Mapping-Curve" class="headerlink" title="Tone Mapping Curve"></a>Tone Mapping Curve</h3><img src="https://img-blog.csdnimg.cn/6183249d49e44eb0833d538867f592f1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h3 id="ACES"><a href="#ACES" class="headerlink" title="ACES"></a>ACES</h3></li>
</ol>
<p><strong>学院色彩编码系统</strong></p>
<ol>
<li>主要用于电影和动画</li>
<li>有趣的范例和转换</li>
</ol>
<p><strong>有用的部分</strong></p>
<ol>
<li>在HDR中应用颜色分级是好的</li>
<li>将一个固定的管道连接到最终的OTD转换阶段的想法是好的</li>
<li>将艺术意图与支持不同设备的机制分离开来<br><img src="https://img-blog.csdnimg.cn/56d831ec988a437796f4d257660936ff.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h3 id="HDR-and-SDR-Pipeline"><a href="#HDR-and-SDR-Pipeline" class="headerlink" title="HDR and SDR Pipeline"></a>HDR and SDR Pipeline</h3>HDR &#x2F; SDR之间的视觉一致性<br>之前的SDR颜色管道相似的SDR结果<br>高质量<br>高性能<br>对美术团队的干扰最小<br>从当前的颜色管道简单<br>过渡掌握HDR和SDR所需的额外开销最小<br><img src="https://img-blog.csdnimg.cn/be1f508f06d44451ac93c2060215f129.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/4609a63144d5421987609d1e6098fa34.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li>
</ol>
<h2 id="Color-Grading"><a href="#Color-Grading" class="headerlink" title="Color Grading"></a>Color Grading</h2><h3 id="Lookup-Table-LUT"><a href="#Lookup-Table-LUT" class="headerlink" title="Lookup Table (LUT)"></a>Lookup Table (LUT)</h3><ol>
<li>LUT用于根据LUT中包含的数据将源像素的输入颜色值重新映射为新的输出值</li>
<li>LUT可以被认为是一种可以应用于图像或镜头的颜色预设<br><img src="https://img-blog.csdnimg.cn/6b746c2cb526490b856808499d3510e1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/8f694b7cc7be46d4afc28d18a66ecd4c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/208f87f769564030b9d18c7cb5d6e35d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h1 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h1>渲染管道是所有渲染操作执行和资源分配的管理顺序<br><img src="https://img-blog.csdnimg.cn/b6dbf9be4def44b7bd1fc192982bfdcb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h2 id="Forward-Rendering"><a href="#Forward-Rendering" class="headerlink" title="Forward Rendering"></a>Forward Rendering</h2><img src="https://img-blog.csdnimg.cn/7c2f767d52a74b9a8d32dfded11873df.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/e58c13f1642f4d61884d5c165a45363d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/6f26a4edecef490382256569bbc6ff1b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h2 id="Deferred-Rendering"><a href="#Deferred-Rendering" class="headerlink" title="Deferred Rendering"></a>Deferred Rendering</h2><img src="https://img-blog.csdnimg.cn/139528b58e2749f283fcd9fc1093a91c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3>光照只计算可见的片段<br>G-Buffer的数据可以用于后处理<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3>高内存和带宽成本<br>不支持透明对象<br>对MSAA不友好<br><img src="https://img-blog.csdnimg.cn/a0639caf4e384b1aaa9c99feb4429e88.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/14459a460848487383de48f943d92d8f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/e0358d66ba174c999c8f385463ef4800.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/7a62db1b62514bbcb3172424dff97912.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>前进+(基于贴图的前进)渲染<br>深度预压(防止透支&#x2F;提供瓷砖深度范围)<br>平铺光照剔除(输出:每个平铺的光照列表)<br>每个物体的阴影(PS:通过光剔除计算的光列表迭代)<br><img src="https://img-blog.csdnimg.cn/e02f693d4757465f889b66736226c4df.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/dbce402f97e147f9a0d9d578bc68169f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/10829f8a13e44100a1371c3d8a675de9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h3><p>复杂的并行工作需要与复杂的资源依赖性同步<br>大量生命周期小于一帧的瞬态资源<br>复杂资源状态管理<br>不需要大量的用户低级知识，就可以利用新暴露的GPU特性<br><img src="https://img-blog.csdnimg.cn/dc6bd3415cb7419c84c3dad4cd9169a9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/e80ed436995d4a5581197412eb64b1ea.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="屏幕撕裂"><a href="#屏幕撕裂" class="headerlink" title="屏幕撕裂"></a>屏幕撕裂</h1><p><img src="https://img-blog.csdnimg.cn/ac66e2ee58dd43b4b3be6d1690f0a69a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>在大多数游戏中，你的GPU帧率是非常不稳定的当新的GPU帧在最后一帧的中间更新时，屏幕撕裂发生<br><img src="https://img-blog.csdnimg.cn/b23946d58b334a83ad5070157a89dcfc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>v-Sync Technology<br>用垂直刷新同步缓冲区交换称为V-syncV-Sync可以用来防止撕裂，但帧率降低，鼠标延迟和口吃破坏游戏<br><img src="https://img-blog.csdnimg.cn/8d437ae2af5944d6abe3bec740450410.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/a0e4175b56b74b078db9c34906887d9d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>引擎制作</tag>
      </tags>
  </entry>
  <entry>
    <title>UnityShader入门</title>
    <url>/2022/01/10/UnityShader%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h4 id="平铺和偏移"><a href="#平铺和偏移" class="headerlink" title="平铺和偏移"></a>平铺和偏移</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//properties</span></span><br><span class="line">_Texture(<span class="string">&quot;Texture&quot;</span>,<span class="number">2</span>D)=<span class="string">&quot;white&quot;</span>&#123;&#125;</span><br><span class="line"><span class="comment">//SubPass/Pass</span></span><br><span class="line">sampler2D _Texture;</span><br><span class="line">float4 _Texture_ST;  </span><br><span class="line">o.uv=v.uv*_Texture_ST.xy+_Texture_ST.zw;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="顶点坐标系MVP转换"><a href="#顶点坐标系MVP转换" class="headerlink" title="顶点坐标系MVP转换"></a>顶点坐标系MVP转换</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">float4 pos_world = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">float4 pos_view = mul(UNITY_MATRIX_V,pos_world);</span><br><span class="line">float4 pos_clip = mul(UNITY_MATRIX_P,pos_view);</span><br><span class="line">o.pos=pos_clip;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">o.pos=UnityObjectToClipPos(v.vertex);</span><br></pre></td></tr></table></figure>

<h4 id="CG变量用法"><a href="#CG变量用法" class="headerlink" title="CG变量用法"></a>CG变量用法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> = <span class="number">32</span><span class="comment">//坐标</span></span><br><span class="line">half = <span class="number">16</span><span class="comment">//uv，大部分向量</span></span><br><span class="line">fixed =<span class="number">8</span><span class="comment">//颜色</span></span><br></pre></td></tr></table></figure>

<h2 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h2><h3 id="面剔除"><a href="#面剔除" class="headerlink" title="面剔除"></a>面剔除</h3><h4 id="单独写死"><a href="#单独写死" class="headerlink" title="单独写死"></a>单独写死</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Cull off</span><br></pre></td></tr></table></figure>

<h4 id="在面板上显示"><a href="#在面板上显示" class="headerlink" title="在面板上显示"></a>在面板上显示</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[Enum(UnityEngine.Rendering.CullMode)]_CullMode(<span class="string">&quot;CullMode&quot;</span>,Float)=<span class="number">2</span><span class="comment">//Properties</span></span><br><span class="line">Cull [_CullMode]<span class="comment">//SubPass/Pass</span></span><br></pre></td></tr></table></figure>

<h3 id="图片铺在模型上"><a href="#图片铺在模型上" class="headerlink" title="图片铺在模型上"></a>图片铺在模型上</h3><p>图片将平铺到x与y组成的平面上</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">o.uv=v.vertex.xy*_Texture_ST.xy+_Texture_ST.zw;</span><br></pre></td></tr></table></figure>

<p>xy变成yx时</p>
<p>相当与x轴旋转180度y轴旋转-90度</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">o.uv=v.vertex.yx*_Texture_ST.xy+_Texture_ST.zw;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">float4 pos_world = mul(unity_ObjectToWorld, v.vertex);</span><br></pre></td></tr></table></figure>



<p>加面解决圆面失真的问题</p>
<h2 id="水波的制作"><a href="#水波的制作" class="headerlink" title="水波的制作"></a>水波的制作</h2><h3 id="先制作动态圆盘"><a href="#先制作动态圆盘" class="headerlink" title="先制作动态圆盘"></a>先制作动态圆盘</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_Float(<span class="string">&quot;Float&quot;</span>,Float)=<span class="number">0.0</span></span><br><span class="line">_Vector(<span class="string">&quot;Vector&quot;</span>,Vector)=(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">_Texture(<span class="string">&quot;Texture&quot;</span>,<span class="number">2</span>D)=<span class="string">&quot;white&quot;</span>&#123;&#125;<span class="comment">//Properties</span></span><br><span class="line">half gradient=tex2D(_Texture,i.uv+_Time.y*_Vector.xy).x;</span><br><span class="line">clip(gradient-_Float);</span><br><span class="line"><span class="keyword">return</span> gradient.xxxx;<span class="comment">//fragment</span></span><br></pre></td></tr></table></figure>

<h3 id="噪声"><a href="#噪声" class="headerlink" title="噪声"></a>噪声</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_NoiseTex(<span class="string">&quot;NoiseTex&quot;</span>,<span class="number">2</span>D)=<span class="string">&quot;white&quot;</span>&#123;&#125;<span class="comment">//Properties</span></span><br><span class="line">half noise=<span class="number">1.0f</span>-tex2D(_NoiseTex,i.uv+_Time.y*_Vector.wz).x;</span><br><span class="line">clip(gradient-_Float-noise);<span class="comment">//fragment</span></span><br></pre></td></tr></table></figure>

<h3 id="完善颜色-完整代码"><a href="#完善颜色-完整代码" class="headerlink" title="完善颜色,完整代码"></a>完善颜色,完整代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Shader<span class="string">&quot;MyShader/03shader&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties&#123;</span><br><span class="line">        _Float(<span class="string">&quot;Float&quot;</span>,Float)=<span class="number">0.0</span></span><br><span class="line">        _Range(<span class="string">&quot;Range&quot;</span>,Range(<span class="number">0</span>,<span class="number">1</span>))=<span class="number">0.0</span></span><br><span class="line">        _Vector(<span class="string">&quot;Vector&quot;</span>,Vector)=(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _Color(<span class="string">&quot;Color&quot;</span>,Color)=(<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>)</span><br><span class="line">        _Texture(<span class="string">&quot;Texture&quot;</span>,<span class="number">2</span>D)=<span class="string">&quot;white&quot;</span>&#123;&#125;</span><br><span class="line">        _NoiseTex(<span class="string">&quot;NoiseTex&quot;</span>,<span class="number">2</span>D)=<span class="string">&quot;white&quot;</span>&#123;&#125;</span><br><span class="line">        [Enum(UnityEngine.Rendering.CullMode)]_CullMode(<span class="string">&quot;CullMode&quot;</span>,Float)=<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        Pass&#123;</span><br><span class="line">            Cull [_CullMode]</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span><span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">            <span class="keyword">struct</span> appdata&#123;</span><br><span class="line">                float4 vertex:POSITION;</span><br><span class="line">                float2 uv:TEXCOORD0;</span><br><span class="line">             <span class="comment">//   float4 color:COLOR;</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">                float4 pos:SV_POSITION;</span><br><span class="line">                float2 uv:TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            sampler2D _Texture;</span><br><span class="line">            float4 _Texture_ST;</span><br><span class="line">            <span class="type">float</span> _Float;</span><br><span class="line">            float4 _Vector;</span><br><span class="line">            sampler2D _NoiseTex;</span><br><span class="line">            float2 _NoiseTex_ST;</span><br><span class="line">            fixed4 _Color;</span><br><span class="line"></span><br><span class="line">            v2f <span class="title function_">vert</span><span class="params">(appdata v)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                float4 pos_world = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">                float4 pos_view = mul(UNITY_MATRIX_V,pos_world);</span><br><span class="line">                float4 pos_clip = mul(UNITY_MATRIX_P,pos_view);</span><br><span class="line">                <span class="comment">//o.pos=pos_clip;</span></span><br><span class="line">                o.pos=UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv=v.uv.xy*_Texture_ST.xy+_Texture_ST.zw;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            half4 <span class="title function_">frag</span><span class="params">(v2f i)</span>:SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                half gradient=tex2D(_Texture,i.uv+_Time.y*_Vector.xy).x;</span><br><span class="line">                half noise=<span class="number">1.0f</span>-tex2D(_NoiseTex,i.uv+_Time.y*_Vector.wz).x;</span><br><span class="line">                clip(gradient-_Float-noise);</span><br><span class="line">                <span class="keyword">return</span> _Color;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="半透明混合"><a href="#半透明混合" class="headerlink" title="半透明混合"></a>半透明混合</h2><h3 id="参数意思"><a href="#参数意思" class="headerlink" title="参数意思"></a>参数意思</h3><table>
<thead>
<tr>
<th></th>
<th>one</th>
<th>此输入的值是 one。该值用于使用源或目标的颜色的值。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><code>Zero</code></td>
<td>此输入的值是 zero。该值用于删除源或目标值。</td>
</tr>
<tr>
<td></td>
<td><code>SrcColor</code></td>
<td>GPU 将此输入的值乘以源颜色值。</td>
</tr>
<tr>
<td></td>
<td><code>SrcAlpha</code></td>
<td>GPU 将此输入的值乘以源 Alpha 值。</td>
</tr>
<tr>
<td></td>
<td><code>DstColor</code></td>
<td>GPU 将此输入的值乘以帧缓冲区的源颜色值。</td>
</tr>
<tr>
<td></td>
<td><code>DstAlpha</code></td>
<td>GPU 将此输入的值乘以帧缓冲区的源 Alpha 值。</td>
</tr>
<tr>
<td></td>
<td><code>OneMinusSrcColor</code></td>
<td>GPU 将此输入的值乘以（1 - 源颜色）。</td>
</tr>
<tr>
<td></td>
<td><code>OneMinusSrcAlpha</code></td>
<td>GPU 将此输入的值乘以（1 - 源 Alpha）。</td>
</tr>
<tr>
<td></td>
<td><code>OneMinusDstColor</code></td>
<td>GPU 将此输入的值乘以（1 - 目标颜色）。</td>
</tr>
<tr>
<td></td>
<td><code>OneMinusDstAlpha</code></td>
<td>GPU 将此输入的值乘以（1 - 目标 Alpha）。</td>
</tr>
</tbody></table>
<h3 id="常见混合类型"><a href="#常见混合类型" class="headerlink" title="常见混合类型"></a>常见混合类型</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Blend SrcAlpha OneMinusSrcAlpha <span class="comment">// 传统透明度</span></span><br><span class="line">Blend SrcAlpha One</span><br><span class="line"><span class="comment">//以上两种常用</span></span><br><span class="line">Blend One OneMinusSrcAlpha <span class="comment">// 预乘透明度</span></span><br><span class="line">Blend One One <span class="comment">// 加法</span></span><br><span class="line">Blend OneMinusDstColor One <span class="comment">// 软加法</span></span><br><span class="line">Blend DstColor Zero <span class="comment">// 乘法</span></span><br><span class="line">Blend DstColor SrcColor <span class="comment">// 2x 乘法</span></span><br></pre></td></tr></table></figure>

<h3 id="代码修改"><a href="#代码修改" class="headerlink" title="代码修改"></a>代码修改</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Tags &#123; <span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;Transparent&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ZWrite Off</span><br><span class="line">Blend SrcAlpha One<span class="comment">//预乘透明度</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">half3 col=_Color.xyz*_Float;</span><br><span class="line">half alpha=saturate(tex2D(_Texture,i.uv).r*_Color.a*_Float);</span><br><span class="line"><span class="keyword">return</span> half4(col,alpha);</span><br></pre></td></tr></table></figure>

<h2 id="边缘光-fresnel-简版的菲涅尔方程"><a href="#边缘光-fresnel-简版的菲涅尔方程" class="headerlink" title="边缘光(fresnel)简版的菲涅尔方程"></a>边缘光(fresnel)简版的菲涅尔方程</h2><h3 id="菲涅尔边缘光实现"><a href="#菲涅尔边缘光实现" class="headerlink" title="菲涅尔边缘光实现"></a>菲涅尔边缘光实现</h3><p>口述： 菲涅耳系数&#x3D;pow (1.0f-saturate(dot(世界坐标到局部坐标的法线向量,世界坐标的顶点到摄像头的单位向量)) ,梯度系数)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">o.normal_world=normalize( mul(float4(v.normal,<span class="number">0</span>),unity_WorldToObject));<span class="comment">//世界坐标到局部坐标的法线向量</span></span><br><span class="line">float4 pos_world = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">o.view_world=normalize(_WorldSpaceCameraPos.xyz-pos_world);<span class="comment">//世界坐标的顶点到摄像头的单位向量</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">float3 normal_world=normalize(i.normal_world);</span><br><span class="line">float3 view_world=normalize(i.view_world);<span class="comment">//光栅化后向量需要标准化</span></span><br><span class="line"><span class="type">float</span> NdotV=saturate(dot(normal_world,view_world));</span><br><span class="line">half3 col=_Color.xyz*_Float;</span><br><span class="line"><span class="type">float</span> fresnel=<span class="built_in">pow</span>(<span class="number">1.0f</span>-NdotV,_Rim);<span class="comment">//菲涅尔系数</span></span><br><span class="line">half alpha=saturate(_Float*fresnel);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> half4(col,alpha);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Pass&#123;</span><br><span class="line">    ZWrite Off</span><br><span class="line">    Blend SrcAlpha One<span class="comment">//预乘透明度</span></span><br><span class="line">    Cull [_CullMode]</span><br><span class="line">    CGPROGRAM</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span><span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">        float4 vertex:POSITION;</span><br><span class="line">        float2 uv:TEXCOORD0;</span><br><span class="line">        float3 normal:NORMAL;</span><br><span class="line">     <span class="comment">//   float4 color:COLOR;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">        float4 pos:SV_POSITION;</span><br><span class="line">        float2 uv:TEXCOORD0;</span><br><span class="line">        float3 normal_world:TEXCOORD1;</span><br><span class="line">        float3 view_world:TEXCOORD2;</span><br><span class="line">    &#125;;</span><br><span class="line">    sampler2D _Texture;</span><br><span class="line">    float4 _Texture_ST;</span><br><span class="line">    fixed4 _Color;</span><br><span class="line">    <span class="type">float</span> _Float;</span><br><span class="line">    <span class="type">float</span> _Rim;</span><br><span class="line">    v2f <span class="title function_">vert</span><span class="params">(appdata v)</span></span><br><span class="line">    &#123;</span><br><span class="line">        v2f o;</span><br><span class="line">        o.pos=UnityObjectToClipPos(v.vertex);</span><br><span class="line">        o.normal_world=normalize( mul(float4(v.normal,<span class="number">0</span>),unity_WorldToObject));</span><br><span class="line">        float4 pos_world = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">        o.view_world=normalize(_WorldSpaceCameraPos.xyz-pos_world);</span><br><span class="line">        o.uv=v.uv*_Texture_ST.xy+_Texture_ST.zw;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    half4 <span class="title function_">frag</span><span class="params">(v2f i)</span>:SV_Target</span><br><span class="line">    &#123;</span><br><span class="line">        float3 normal_world=normalize(i.normal_world);</span><br><span class="line">        float3 view_world=normalize(i.view_world);</span><br><span class="line">        <span class="type">float</span> NdotV=saturate(dot(normal_world,view_world));</span><br><span class="line">        half3 col=_Color.xyz*_Float;</span><br><span class="line">        <span class="type">float</span> fresnel=<span class="built_in">pow</span>(<span class="number">1.0f</span>-NdotV,_Rim);</span><br><span class="line">        half alpha=saturate(_Float*fresnel);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> half4(col,alpha);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="预先写深度"><a href="#预先写深度" class="headerlink" title="预先写深度"></a>预先写深度</h3><p><strong>修除内部透明小Bug，预先将前面的深度写入，但不写入颜色信息，用上面的pass第二遍时将后面的透明的给剔除掉，</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line">     Cull Off </span><br><span class="line">     ZWrite On <span class="comment">//深度写入</span></span><br><span class="line">     ColorMask <span class="number">0</span><span class="comment">//不写颜色信息</span></span><br><span class="line">     CGPROGRAM</span><br><span class="line">     float4 _Color;</span><br><span class="line">     <span class="meta">#<span class="keyword">pragma</span> vertex vert </span></span><br><span class="line">     <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">     float4 <span class="title function_">vert</span><span class="params">(float4 vertexPos : POSITION)</span> : SV_POSITION</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">return</span> UnityObjectToClipPos(vertexPos);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     float4 <span class="title function_">frag</span><span class="params">(<span class="type">void</span>)</span> : COLOR</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">return</span> _Color;</span><br><span class="line">     &#125;</span><br><span class="line">     ENDCG</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>计算机图形学</category>
        <category>Unity</category>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu系统和Docker的奇妙故事</title>
    <url>/2022/04/07/Ubuntu%E7%B3%BB%E7%BB%9F%E5%92%8CDocker%E7%9A%84%E5%A5%87%E5%A6%99%E6%95%85%E4%BA%8B/</url>
    <content><![CDATA[<h1 id="装系统"><a href="#装系统" class="headerlink" title="装系统"></a>装系统</h1><p>下载镜像，制作</p>
<p>跳过更新过程</p>
<p>找到软件和更新</p>
<p>寻找最佳镜像源</p>
<p>设置好再更新镜像</p>
<h1 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h1><p>用<a href="https://github.com/fatedier/frp/releases">frp</a>进行穿透</p>
<h2 id="公网服务器"><a href="#公网服务器" class="headerlink" title="公网服务器"></a>公网服务器</h2><p>frps.ini</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = <span class="number">7000</span></span><br><span class="line">token =sss        密钥和客户端一样就行</span><br></pre></td></tr></table></figure>

<h2 id="私有服务器"><a href="#私有服务器" class="headerlink" title="私有服务器"></a>私有服务器</h2><p>frpc.ini</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = 公网服务器ip</span><br><span class="line">server_port = <span class="number">7000</span></span><br><span class="line">token =sss</span><br><span class="line"></span><br><span class="line">[pve-web]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = <span class="number">192.168</span><span class="number">.50</span><span class="number">.200</span>   </span><br><span class="line">local_port = <span class="number">8888</span>           </span><br><span class="line">remote_port = <span class="number">8888</span>      </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">local_ip <span class="comment">//私有服务器地址</span></span><br><span class="line"></span><br><span class="line">local_port <span class="comment">//本地的应用端口</span></span><br><span class="line"></span><br><span class="line">remote_port <span class="comment">//映射到服务器的端口</span></span><br></pre></td></tr></table></figure>

<h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>一定要下_linux_amd64.tar.gz的，架构可以选，其他的darwin_amd64.tar.gzUbuntu运行不了</p>
<p>到相关文件夹下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sudo ./frps -c frps.ini</span><br></pre></td></tr></table></figure>

<p>如果在其他用户群</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">su -l [user]</span><br></pre></td></tr></table></figure>

<p>不加的话默认root权限管理员</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ./frpc -c frpc.ini</span><br></pre></td></tr></table></figure>

<h2 id="win"><a href="#win" class="headerlink" title="win"></a>win</h2><p>cmd指令相关文件夹下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">frps.exe -c frps.ini</span><br><span class="line">frpc.exe -c frpc.ini</span><br></pre></td></tr></table></figure>

<p>可以将此命令写出bat放进开始文件夹，变成开机启动项。</p>
<h1 id="虚拟组网"><a href="#虚拟组网" class="headerlink" title="虚拟组网"></a>虚拟组网</h1><p>zerotier 虚拟组网</p>
<p>原理就是先通过zerotier中继器进行联网，然后尝试让两者进行p2p连接。</p>
<p>Linux麻烦一点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">zerotier-cli join id<span class="comment">//加入并连接</span></span><br><span class="line">zerotier-cli leave id<span class="comment">//断开连接</span></span><br></pre></td></tr></table></figure>



<h1 id="转载自别人视频的东西"><a href="#转载自别人视频的东西" class="headerlink" title="转载自别人视频的东西"></a>转载自别人视频的东西</h1><h2 id="docker镜像加速"><a href="#docker镜像加速" class="headerlink" title="docker镜像加速"></a>docker镜像加速</h2><p>请把 docker 更换源工具解压至用户主目录</p>
<p>打开终端运行</p>
<p>ds.sh</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#! /bin/bash</span><br><span class="line"></span><br><span class="line">date <span class="string">&quot;+%Y年%m月%d日 周%w %H:%M:%S&quot;</span></span><br><span class="line">echo <span class="string">&#x27;为 Docker 更换官方国内源加速下载&#x27;</span></span><br><span class="line">cat &gt; /etc/docker/daemon.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://registry.docker-cn.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">service docker restart</span><br><span class="line">docker info|grep <span class="string">&quot;Registry Mirrors&quot;</span> -A <span class="number">1</span></span><br><span class="line">echo <span class="string">&#x27;显示 registry.docker-cn.com 即换源成功&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="更换-Docker-国内官方源"><a href="#更换-Docker-国内官方源" class="headerlink" title="更换 Docker 国内官方源"></a>更换 Docker 国内官方源</h3><p>sudo sh ds.sh</p>
<h3 id="修复-Docker-无管理员权限运行失败的问题"><a href="#修复-Docker-无管理员权限运行失败的问题" class="headerlink" title="修复 Docker 无管理员权限运行失败的问题"></a>修复 Docker 无管理员权限运行失败的问题</h3><p>sudo gpasswd -a $USER docker</p>
<p>newgrp docker</p>
<p>service docker restart</p>
<p><a href="https://www.bilibili.com/video/BV1Bh411s765?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click">来自科技宅小明的视频</a></p>
<p><strong>一定要切换镜像源！！！一定要切换镜像源！！！一定要切换镜像源！！！一定要切换镜像源！！！一定要切换镜像源！！！一定要切换镜像源！！！一定要切换镜像源！！！一定要切换镜像源！！！一定要切换镜像源！！！一定要切换镜像源！！！</strong></p>
<h2 id="装Docker"><a href="#装Docker" class="headerlink" title="装Docker"></a>装Docker</h2><p><a href="https://www.runoob.com/docker/docker-tutorial.html">也可以看菜鸟教程装Docker</a></p>
<p><strong>更新 apt 工具及索引，以支持 https 存储库</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get install \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg \</span><br><span class="line">    lsb-release</span><br></pre></td></tr></table></figure>

<p><strong>添加 Docker 官方 GPG 密钥（用于签名&#x2F;验证、加密&#x2F;解密）</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">curl -fsSL https:<span class="comment">//download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span></span><br></pre></td></tr></table></figure>

<p><strong>设置 stable 版稳定存储库（区别于夜间版&#x2F;测试版 nightly &#x2F; test ）</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">echo \</span><br><span class="line">  <span class="string">&quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">  $(lsb_release -cs) stable&quot;</span> | sudo tee /etc/apt/sources.<span class="built_in">list</span>.d/docker.<span class="built_in">list</span> &gt; /dev/null</span><br></pre></td></tr></table></figure>

<p><strong>更新 apt 工具及索引，并安装 Docker</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>



<p><strong>验证 Docker Engine 是否正确安装（显示 “Hello from Docker!” 即为成功安装）</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure>

<h2 id="为-Docker-安装图形化操作界面-Portainer"><a href="#为-Docker-安装图形化操作界面-Portainer" class="headerlink" title="为 Docker 安装图形化操作界面 Portainer"></a>为 Docker 安装图形化操作界面 Portainer</h2><p><strong>创建 Portainer Server 存储数据库的卷</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sudo docker volume create portainer_data</span><br></pre></td></tr></table></figure>

<p><strong>下载并安装 Portainer Server 容器</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sudo docker run -d -p <span class="number">8000</span>:<span class="number">8000</span> -p <span class="number">9443</span>:<span class="number">9443</span> --name portainer \</span><br><span class="line">    --restart=always \</span><br><span class="line">    -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">    -v portainer_data:/data \</span><br><span class="line">    portainer/portainer-ce:latest</span><br></pre></td></tr></table></figure>

<p><strong>查看 Docker 容器状态（NAMES 标签出现 portainer&#x2F;portainer-ce 则成功运行）</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sudo docker ps</span><br></pre></td></tr></table></figure>

<p><strong>使用 Ubuntu 自带的火狐浏览器访问（<a href="https://127.0.0.1:9443/%EF%BC%89">https://127.0.0.1:9443/）</a></strong><br><strong>或使用局域网内另一台计算机&#x2F;手机的浏览器访问（https:&#x2F;&#x2F;服务器的IP:9443&#x2F;）</strong></p>
<p><strong>对 Portainer 初始设置</strong><br>设置用户名及密码（8位字符或数字），点击 Get Started，载入后点击 local 即可</p>
<h2 id="启用-Web-个人导航页"><a href="#启用-Web-个人导航页" class="headerlink" title="启用 Web 个人导航页"></a>启用 Web 个人导航页</h2><p><strong>将 nginx 文件夹解压至 &#x2F;home&#x2F;你自己的用户名&#x2F; 之下</strong></p>
<p><strong>下载 Nginx 镜像</strong></p>
<p>Portainer 点击 Images 镜像，docker.io 右侧填入 nginx，点击 Pull the image 下载镜像</p>
<p><strong>部署并运行 Nginx 容器（可以理解为把 Nginx 镜像作为小型虚拟机启动）</strong></p>
<p>点击 Containers 标签，点击 Add Container 启动容器，名称填入Nginx，docker.io 右侧填入 nginx:latest（Images 标签页 Tags 标签选项）。</p>
<p>Manual network port publishing 手动发布网口设置项，把本地80端口映射到容器80端口。</p>
<p>在Advanced container settings高级容器设置中，点击map additional volume 映射附加卷，点击绑定文件夹及可读写，本地文件夹填入 &#x2F;home&#x2F;你自己的用户名&#x2F;nginx&#x2F; 容器文件夹填入 &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</p>
<p>Restart policy 重启策略调整为 Always 永远自动启动。</p>
<p>最后点击 Deploy the container 部署容器</p>
<p><strong>使用 Ubuntu 自带的火狐浏览器访问（<a href="http://127.0.0.1)/">http://127.0.0.1）</a></strong><br><strong>或使用局域网内另一台计算机&#x2F;手机的浏览器访问（http:&#x2F;&#x2F;服务器的IP）</strong></p>
<h2 id="来自GitHub大佬的分享"><a href="#来自GitHub大佬的分享" class="headerlink" title="来自GitHub大佬的分享"></a>来自GitHub大佬的分享</h2><p>来自各种生活的容器服务，<a href="https://github.com/awesome-selfhosted/awesome-selfhosted">上链接</a></p>
<h2 id="搭建-Mattermost-私人聊天室"><a href="#搭建-Mattermost-私人聊天室" class="headerlink" title="搭建 Mattermost 私人聊天室"></a>搭建 Mattermost 私人聊天室</h2><p><strong>命令方式安装 Docker 版 Mattermost</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">-d \</span><br><span class="line">--name mattermost-preview \</span><br><span class="line">--restart=always \</span><br><span class="line">--publish <span class="number">8065</span>:<span class="number">8065</span> \</span><br><span class="line">--add-host dockerhost:<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> \</span><br><span class="line">mattermost/mattermost-preview</span><br></pre></td></tr></table></figure>

<h2 id="设置-Mattermost-私人聊天室"><a href="#设置-Mattermost-私人聊天室" class="headerlink" title="设置 Mattermost 私人聊天室"></a>设置 Mattermost 私人聊天室</h2><p><strong>访问 127.0.0.1:8065 网址，输入邮箱用户名及密码进行初始账户注册</strong><br><strong>选择第二项进入控制台，进入SITE CONFIGURATION - Localization更改语言为中文</strong><br><strong>保存返回上一步，新建群组PQMing（可以自行改名），点击Finish完成</strong><br><strong>新页面输入用户名，上传头像（可选）并保存，保存团队，不起用通知</strong><br><strong>复制邀请链接，之后可以分享给朋友，稍等一会就完成设置</strong><br><strong>默认的管理员账户仍然是英文，点击右上角设置，Display里改成中文即可</strong><br><strong>新用户入群后会自动进入公共和闲聊这两个频道，用户之间可以选择群聊或私信</strong></p>
<h2 id="免费使用为知笔记"><a href="#免费使用为知笔记" class="headerlink" title="免费使用为知笔记"></a>免费使用为知笔记</h2><p><strong>访问用户主目录文件夹</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cd ~</span><br></pre></td></tr></table></figure>

<p><strong>在主目录新建 wizdata 文件夹用于存储笔记数据</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mkdir wizdata</span><br></pre></td></tr></table></figure>

<p><strong>命令方式安装 Docker 版为知笔记</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">-it \</span><br><span class="line">-d \</span><br><span class="line">--name wiz \</span><br><span class="line">--restart=always \</span><br><span class="line">-v ~/wizdata:/wiz/storage \</span><br><span class="line">-v /etc/localtime:/etc/localtime \</span><br><span class="line">-p <span class="number">8080</span>:<span class="number">80</span> \</span><br><span class="line">-p <span class="number">9269</span>:<span class="number">9269</span>/udp \</span><br><span class="line">wiznote/wizserver</span><br></pre></td></tr></table></figure>

<h2 id="搭建个人博客-Wordpress"><a href="#搭建个人博客-Wordpress" class="headerlink" title="搭建个人博客 Wordpress"></a>搭建个人博客 Wordpress</h2><p><strong>安装 Docker 版 mariadb 数据库命令，可自行替换密码（默认为meimima）</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name mariadb \</span><br><span class="line">  -p <span class="number">3306</span>:<span class="number">3306</span> \</span><br><span class="line">  -e MARIADB_ROOT_PASSWORD=meimima \</span><br><span class="line">  -e MARIADB_DATABASE=wordpress \</span><br><span class="line">  --restart=always \</span><br><span class="line">  mariadb:latest</span><br></pre></td></tr></table></figure>

<p><strong>安装 Docker 版 Wordpress 命令，需要自行替换为本机 IP 地址（采用上一步数据库密码meimima）</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  -d \</span><br><span class="line">  --name wordpress \</span><br><span class="line">  -e WORDPRESS_DB_HOST=服务器IP:<span class="number">3306</span> \</span><br><span class="line">  -e WORDPRESS_DB_USER=root \</span><br><span class="line">  -e WORDPRESS_DB_PASSWORD=meimima \</span><br><span class="line">  -e WORDPRESS_DB_NAME=wordpress \</span><br><span class="line">  -e WORDPRESS_TABLE_PREFIX=wp_ \</span><br><span class="line">  -p <span class="number">8081</span>:<span class="number">80</span> \</span><br><span class="line">  --restart=always \</span><br><span class="line">  wordpress</span><br></pre></td></tr></table></figure>

<p><strong>使用浏览器登陆服务器 IP:8081（例：192.168.2.15:8081）访问博客</strong></p>
<h2 id="可选-安装-mariadb-数据库控制面板-phpmyadmin-手动管理数据库"><a href="#可选-安装-mariadb-数据库控制面板-phpmyadmin-手动管理数据库" class="headerlink" title="可选 安装 mariadb 数据库控制面板 phpmyadmin 手动管理数据库"></a>可选 安装 mariadb 数据库控制面板 phpmyadmin 手动管理数据库</h2><p><strong>安装 Docker 版 phpmyadmin 数据库控制面板命令</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  -d \</span><br><span class="line">  --name phpmyadmin \</span><br><span class="line">  --link mariadb \</span><br><span class="line">  -e PMA_HOST=<span class="string">&quot;mariadb&quot;</span> \</span><br><span class="line">  -p <span class="number">8082</span>:<span class="number">80</span> \</span><br><span class="line">  --restart=always \</span><br><span class="line">  phpmyadmin</span><br></pre></td></tr></table></figure>

<p><strong>使用浏览器登陆服务器 IP:8082（例：192.168.2.15:8082）访问数据库控制面板</strong><br><strong>使用安装 phpmyadmin 命令中的密码（默认为meimima）及用户名 root 登陆数据库</strong><br><strong>点击控制面板左侧 新建 按钮，创建名为 wordpress 的数据库</strong></p>
<h2 id="免费网盘-SeaFile-安装教程"><a href="#免费网盘-SeaFile-安装教程" class="headerlink" title="免费网盘 SeaFile 安装教程"></a>免费网盘 SeaFile 安装教程</h2><p>docker-compose.yml</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">version: <span class="string">&#x27;2.0&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  db:</span><br><span class="line">    image: mariadb:<span class="number">10.5</span></span><br><span class="line">    container_name: seafile-mysql</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      - MYSQL_ROOT_PASSWORD=db_dev  # 设置数据库根用户的密码</span><br><span class="line">      - MYSQL_LOG_CONSOLE=<span class="literal">true</span></span><br><span class="line">    volumes:</span><br><span class="line">      - /home/seafile-mysql/db:/var/lib/mysql  # 设置数据库存储位置</span><br><span class="line">    networks:</span><br><span class="line">      - seafile-net</span><br><span class="line"></span><br><span class="line">  memcached:</span><br><span class="line">    image: memcached:<span class="number">1.5</span><span class="number">.6</span></span><br><span class="line">    container_name: seafile-memcached</span><br><span class="line">    restart: always</span><br><span class="line">    entrypoint: memcached -m <span class="number">256</span></span><br><span class="line">    networks:</span><br><span class="line">      - seafile-net</span><br><span class="line"></span><br><span class="line">  seafile:</span><br><span class="line">    image: seafileltd/seafile-mc:latest</span><br><span class="line">    container_name: seafile</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;81:80&quot;</span>  # 主机<span class="number">81</span>端口映射至容器<span class="number">80</span>端口http</span><br><span class="line">      - <span class="string">&quot;4433:443&quot;</span>  # 主机<span class="number">4433</span>端口映射至容器<span class="number">443</span>端口https</span><br><span class="line">      - <span class="string">&quot;8088:8080&quot;</span>  # 主机<span class="number">8088</span>端口映射至容器<span class="number">8080</span>端口webdav</span><br><span class="line">    volumes:</span><br><span class="line">      - /home/seafile-data:/shared   # 设置Seafile数据存储位置</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      - DB_HOST=db</span><br><span class="line">      - DB_ROOT_PASSWD=db_dev  # 与第一条注释所设置密码相同</span><br><span class="line">      - TIME_ZONE=Asia/Shanghai # 设定时区为上海</span><br><span class="line">      - SEAFILE_ADMIN_EMAIL=me@example.com # 设置管理员账户，默认为 <span class="string">&#x27;me@example.com&#x27;</span></span><br><span class="line">      - SEAFILE_ADMIN_PASSWORD=asecret     # 设置管理员密码，默认为 <span class="string">&#x27;asecret&#x27;</span></span><br><span class="line">#      - SEAFILE_SERVER_LETSENCRYPT=<span class="literal">false</span>   # 是否启用LETSENCRYPT提供的https加密证书，默认为 <span class="string">&#x27;false&#x27;</span></span><br><span class="line">      - SEAFILE_SERVER_HOSTNAME=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">81</span> # 设置网盘域名地址</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">      - memcached</span><br><span class="line">    networks:</span><br><span class="line">      - seafile-net</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  seafile-net:</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>docker-compose原版.yml</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">version: <span class="string">&#x27;2.0&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  db:</span><br><span class="line">    image: mariadb:<span class="number">10.5</span></span><br><span class="line">    container_name: seafile-mysql</span><br><span class="line">    environment:</span><br><span class="line">      - MYSQL_ROOT_PASSWORD=db_dev  # Requested, <span class="built_in">set</span> the root<span class="number">&#x27;</span>s password of MySQL service.</span><br><span class="line">      - MYSQL_LOG_CONSOLE=<span class="literal">true</span></span><br><span class="line">    volumes:</span><br><span class="line">      - /opt/seafile-mysql/db:/var/lib/mysql  # Requested, specifies the path to MySQL data persistent store.</span><br><span class="line">    networks:</span><br><span class="line">      - seafile-net</span><br><span class="line"></span><br><span class="line">  memcached:</span><br><span class="line">    image: memcached:<span class="number">1.5</span><span class="number">.6</span></span><br><span class="line">    container_name: seafile-memcached</span><br><span class="line">    entrypoint: memcached -m <span class="number">256</span></span><br><span class="line">    networks:</span><br><span class="line">      - seafile-net</span><br><span class="line">          </span><br><span class="line">  seafile:</span><br><span class="line">    image: seafileltd/seafile-mc:latest</span><br><span class="line">    container_name: seafile</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;80:80&quot;</span></span><br><span class="line">#      - <span class="string">&quot;443:443&quot;</span>  # If https is enabled, cancel the comment.</span><br><span class="line">    volumes:</span><br><span class="line">      - /opt/seafile-data:/shared   # Requested, specifies the path to Seafile data persistent store.</span><br><span class="line">    environment:</span><br><span class="line">      - DB_HOST=db</span><br><span class="line">      - DB_ROOT_PASSWD=db_dev  # Requested, the value shuold be root<span class="number">&#x27;</span>s password of MySQL service.</span><br><span class="line">#      - TIME_ZONE=Asia/Shanghai # Optional, <span class="keyword">default</span> is UTC. Should be uncomment and <span class="built_in">set</span> to your local time zone.</span><br><span class="line">      - SEAFILE_ADMIN_EMAIL=me@example.com # Specifies Seafile admin user, <span class="keyword">default</span> is <span class="string">&#x27;me@example.com&#x27;</span>.</span><br><span class="line">      - SEAFILE_ADMIN_PASSWORD=asecret     # Specifies Seafile admin password, <span class="keyword">default</span> is <span class="string">&#x27;asecret&#x27;</span>.</span><br><span class="line">      - SEAFILE_SERVER_LETSENCRYPT=<span class="literal">false</span>   # Whether use letsencrypt to generate cert.</span><br><span class="line">      - SEAFILE_SERVER_HOSTNAME=seafile.example.com # Specifies your host name.</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">      - memcached</span><br><span class="line">    networks:</span><br><span class="line">      - seafile-net</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  seafile-net:</span><br></pre></td></tr></table></figure>

<p><strong>打开终端运行以下命令（输入密码界面不会显示密码）</strong></p>
<p>sudo apt-get update | sudo apt-get install docker-compose -y</p>
<p><strong>将 docker-compose.yml 解压至用户主目录，并修改文件内邮箱密码</strong></p>
<p><strong>访问用户主目录</strong></p>
<p>cd ~</p>
<p><strong>在终端运行以下命令</strong></p>
<p>sudo docker-compose up -d</p>
<p><strong>使用自带的火狐浏览器，访问 <a href="http://127.0.0.1:81/">http://127.0.0.1:81</a></strong></p>
<p><strong>未更改 docker-compose.yml 文件内邮箱密码的话，默认用户名 <a href="mailto:&#109;&#x65;&#x40;&#101;&#120;&#97;&#109;&#x70;&#108;&#x65;&#46;&#x63;&#x6f;&#x6d;">&#109;&#x65;&#x40;&#101;&#120;&#97;&#109;&#x70;&#108;&#x65;&#46;&#x63;&#x6f;&#x6d;</a> 密码 asecret</strong></p>
<p><strong>请在路由器转发 http 使用的 81 端口至服务器</strong></p>
<p><strong>全平台客户端下载链接 <a href="https://www.seafile.com/download/">https://www.seafile.com/download/</a></strong></p>
<h2 id="免费网盘-SeaFile-配置教程-https"><a href="#免费网盘-SeaFile-配置教程-https" class="headerlink" title="免费网盘 SeaFile 配置教程 (https)"></a>免费网盘 SeaFile 配置教程 (https)</h2><p><strong>于各个免费平台申请相应域名的 SSL 证书</strong></p>
<p><strong>创建 &#x2F;home&#x2F;seafile-data&#x2F;ssl 目录，然后拷贝证书文件和密钥文件至 ssl 目录下</strong></p>
<p><strong>如果网盘域名是 seafile.example.com，证书名称必须为 seafile.example.com.crt，密钥文件名称为 seafile.example.com.key</strong></p>
<p><strong>请在路由器转发 https 使用的 4433 端口至服务器</strong></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Ducker</tag>
      </tags>
  </entry>
  <entry>
    <title>houdini导入渲染顶点动画流动图片</title>
    <url>/2022/04/30/houdini%E5%AF%BC%E5%85%A5%E6%B8%B2%E6%9F%93%E9%A1%B6%E7%82%B9%E5%8A%A8%E7%94%BB%E6%B5%81%E5%8A%A8%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h1 id="VAT动画"><a href="#VAT动画" class="headerlink" title="VAT动画"></a>VAT动画</h1><h2 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h2><p><img src="https://img-blog.csdnimg.cn/81a8e0ecbb5a43f29ec8f6743a211673.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/b45b4f80e3334f4c924528347c895065.png#pic_center" alt="在这里插入图片描述"><br>行代表顶点，列代表帧<br>需要每个顶点从左到右循环偏移顶点即可</p>
<h2 id="时间推移"><a href="#时间推移" class="headerlink" title="时间推移"></a>时间推移</h2><p><img src="https://img-blog.csdnimg.cn/2f6448719b11418290d1b6bf5bbf03c8.png" alt="在这里插入图片描述"></p>
<h2 id="合成流动的UV"><a href="#合成流动的UV" class="headerlink" title="合成流动的UV"></a>合成流动的UV</h2><p><img src="https://img-blog.csdnimg.cn/587bfd6898014048acfb1e23efff1731.png" alt="在这里插入图片描述"></p>
<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p><img src="https://img-blog.csdnimg.cn/3da6f944d98a435bb9fd82572f65b31d.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/57576d56555b486e972fc9d7f882b674.png" alt="在这里插入图片描述"></p>
<h2 id="扩展：约数函数"><a href="#扩展：约数函数" class="headerlink" title="扩展：约数函数"></a>扩展：约数函数</h2><h3 id="floor"><a href="#floor" class="headerlink" title="floor"></a>floor</h3><p>取小的那个数，floor(1.5)&#x3D;1</p>
<h3 id="round"><a href="#round" class="headerlink" title="round"></a>round</h3><p>round是四舍五入</p>
<h3 id="ceil"><a href="#ceil" class="headerlink" title="ceil"></a>ceil</h3><p>取大的那个数，ceil(1.1)&#x3D;2</p>
<h1 id="FlowPicture"><a href="#FlowPicture" class="headerlink" title="FlowPicture"></a>FlowPicture</h1><p>扰动渐变参数&#x3D;abs(frac(x)*2-1)<br><img src="https://img-blog.csdnimg.cn/eb1a456347d64535a990369207a7e554.png" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/0e5fe59d242940408141de273bf47683.png" alt="在这里插入图片描述"></p>
<h2 id="简略版"><a href="#简略版" class="headerlink" title="简略版"></a>简略版</h2><p><img src="https://img-blog.csdnimg.cn/212903f3e280489681a0dc6c27edac3f.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/ab2bd34ffd2a420f9c161f707a66dc65.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>人物扫光</title>
    <url>/2022/01/21/%E4%BA%BA%E7%89%A9%E6%89%AB%E5%85%89/</url>
    <content><![CDATA[<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="边缘光"><a href="#边缘光" class="headerlink" title="边缘光"></a>边缘光</h2><p><img src="https://img-blog.csdnimg.cn/ae5ddfb6e8464ec0aa7ffeb6c7f1bf90.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">    </p>
<h2 id="流光"><a href="#流光" class="headerlink" title="流光"></a>流光</h2><p><img src="https://img-blog.csdnimg.cn/1ee1c9a1e9ad45809bdd840452952c77.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当一个三维向量补全为四维向量的时候，如果是点的话最后需要补成1.0，如果是向量的话需要补0.0</p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>光照模型与法线贴图</title>
    <url>/2022/02/14/%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="渲染路径"><a href="#渲染路径" class="headerlink" title="渲染路径"></a>渲染路径</h1><h2 id="前向渲染"><a href="#前向渲染" class="headerlink" title="前向渲染"></a>前向渲染</h2><p>对每一个物体每一个光源进行渲染，超出范围的灯光以顶点灯光渲染，适用于灯光较少的情况</p>
<h3 id="ForwardBase"><a href="#ForwardBase" class="headerlink" title="ForwardBase"></a>ForwardBase</h3><p>在这个Pass里面，主方向灯以及超出范围的灯光作为顶点灯光传入SH，   LightMap，Reflection， Probe等计算均在这个Pass里面完成。</p>
<h3 id="ForwardAdd"><a href="#ForwardAdd" class="headerlink" title="ForwardAdd"></a>ForwardAdd</h3><p>数量范围内的灯光，每个灯光的计算，均会调用一次这个pass，计算的结果通过Blend one one 叠加起来。</p>
<h2 id="延迟渲染"><a href="#延迟渲染" class="headerlink" title="延迟渲染"></a>延迟渲染</h2><p> 使用MRT技术 ，RT0是物体的颜色，RT1是金属反射的颜色，RT2是法线数据，RT4是深度信息。</p>
<p>光源直接渲染一次。有带宽和设备支持的限制，ue4和HDRP默认。</p>
<h1 id="法线贴图"><a href="#法线贴图" class="headerlink" title="法线贴图"></a>法线贴图</h1><h2 id="法线"><a href="#法线" class="headerlink" title="法线"></a>法线</h2><p>顶点垂直模型的线NORMAL</p>
<h2 id="切线"><a href="#切线" class="headerlink" title="切线"></a>切线</h2><p>UV中u递增的线或者v递增的线，引擎帮我们生成的TANGENT</p>
<h2 id="副切线"><a href="#副切线" class="headerlink" title="副切线"></a>副切线</h2><p> 法线叉乘切线得到的。</p>
<h1 id="unity的无光照shader获得光源信息实战"><a href="#unity的无光照shader获得光源信息实战" class="headerlink" title="unity的无光照shader获得光源信息实战"></a>unity的无光照shader获得光源信息实战</h1><h2 id="ForwardBase-Pass"><a href="#ForwardBase-Pass" class="headerlink" title="ForwardBase Pass"></a>ForwardBase Pass</h2><h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><p>需要将光照模式调为ForwardBase</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>在编写时加入如下引用文件以方便获取光照参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdbase</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AutoLight.cginc&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>appadata</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">appdata</span></span><br><span class="line">       &#123;</span><br><span class="line">           float4 vertex : POSITION;</span><br><span class="line">           float2 uv : TEXCOORD0;</span><br><span class="line">           float3 normal:NORMAL;<span class="comment">//法线</span></span><br><span class="line">           float4 tangent:TANGENT;<span class="comment">//切线注意是四维向量，w用来矫正平台的区别</span></span><br><span class="line">       &#125;;</span><br></pre></td></tr></table></figure>

<p>片元数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">v2f</span></span><br><span class="line">       &#123;</span><br><span class="line">           float2 uv : TEXCOORD0;</span><br><span class="line">           float4 vertex : SV_POSITION;</span><br><span class="line">           float3 normali_dir:TEXCOORD1;</span><br><span class="line">           float3 tangent_dir:TEXCOORD2;</span><br><span class="line">           float3 binormal_dir:TEXCOORD3;</span><br><span class="line">           float3 pos_world:TEXCOORD4;</span><br><span class="line"></span><br><span class="line">       &#125;;</span><br></pre></td></tr></table></figure>

<p>光源数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">half3 light_dir =<span class="built_in">normalize</span>( _WorldSpaceLightPos0.xyz );<span class="comment">//定向光位置无意义所以代表光照方向</span></span><br></pre></td></tr></table></figure>



<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Pass</span><br><span class="line">      &#123;</span><br><span class="line">          Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span>&#125;</span><br><span class="line">          </span><br><span class="line">          CGPROGRAM</span><br><span class="line">          <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">          <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">          <span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdbase</span></span><br><span class="line">          <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">          <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AutoLight.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">struct</span> appdata</span><br><span class="line">          &#123;</span><br><span class="line">              float4 vertex : POSITION;</span><br><span class="line">              float2 uv : TEXCOORD0;</span><br><span class="line">              float3 normal:NORMAL;</span><br><span class="line">              float4 tangent:TANGENT;</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">struct</span> <span class="title class_">v2f</span></span><br><span class="line">          &#123;</span><br><span class="line">              float2 uv : TEXCOORD0;</span><br><span class="line">              float4 vertex : SV_POSITION;</span><br><span class="line">              float3 normali_dir:TEXCOORD1;</span><br><span class="line">              float3 tangent_dir:TEXCOORD2;</span><br><span class="line">              float3 binormal_dir:TEXCOORD3;</span><br><span class="line">              float3 pos_world:TEXCOORD4;</span><br><span class="line"></span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          sampler2D _MainTex;</span><br><span class="line">          float4 _MainTex_ST;</span><br><span class="line">          sampler2D _AOMap;</span><br><span class="line">          float4 _AOMap_ST;</span><br><span class="line">          float4 _LightColor0;</span><br><span class="line">          <span class="type">float</span> _Shininess;</span><br><span class="line">          <span class="type">float</span> _SpecularIntensity;</span><br><span class="line">          float4 _AmbientColor; </span><br><span class="line">          sampler2D _SpecMask;</span><br><span class="line">          <span class="type">float</span> _SpecMask_ST; </span><br><span class="line">          sampler2D _NormalMap;</span><br><span class="line">          float4 _NormalMap_ST; </span><br><span class="line">          <span class="type">float</span> _NormalIntensity;</span><br><span class="line">          <span class="type">float</span> __AmbientIntensity;</span><br><span class="line"></span><br><span class="line">          <span class="function">float3 <span class="title">ACESFilm</span><span class="params">(float3 x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">float</span> a = <span class="number">2.51f</span>;</span><br><span class="line">    <span class="type">float</span> b = <span class="number">0.03f</span>;</span><br><span class="line">    <span class="type">float</span> c = <span class="number">2.43f</span>;</span><br><span class="line">    <span class="type">float</span> d = <span class="number">0.59f</span>;</span><br><span class="line">    <span class="type">float</span> e = <span class="number">0.14f</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">saturate</span>((x*(a*x + b)) / (x*(c*x + d) + e));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">          <span class="function">v2f <span class="title">vert</span> <span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function">          </span>&#123;</span><br><span class="line">              v2f o;</span><br><span class="line">              o.vertex = <span class="built_in">UnityObjectToClipPos</span>(v.vertex);</span><br><span class="line">              o.normali_dir = <span class="built_in">normalize</span>(<span class="built_in">mul</span>(<span class="built_in">float4</span>(v.normal,<span class="number">0.0</span>),unity_WorldToObject).xyz);</span><br><span class="line">              o.tangent_dir = <span class="built_in">normalize</span>(<span class="built_in">mul</span>(<span class="built_in">float4</span>(v.tangent.xyz,<span class="number">0.0</span>),unity_WorldToObject).xyz);</span><br><span class="line">              o.binormal_dir = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(o.normali_dir,o.tangent_dir))* v.tangent.w;</span><br><span class="line">              o.pos_world = <span class="built_in">mul</span>(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line">              o.uv = <span class="built_in">TRANSFORM_TEX</span>(v.uv, _MainTex);</span><br><span class="line">              <span class="keyword">return</span> o;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="function">fixed4 <span class="title">frag</span> <span class="params">(v2f i)</span> : SV_Target</span></span><br><span class="line"><span class="function">          &#123;</span></span><br><span class="line">              fixed4 col=<span class="built_in">fixed4</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">              half3 AO = <span class="built_in">tex2D</span>(_AOMap,i.uv).xyz;</span><br><span class="line">              half3 spec_mask = <span class="built_in">tex2D</span>(_SpecMask,i.uv).xyz;</span><br><span class="line">              half4 normalmap = <span class="built_in">tex2D</span>(_NormalMap,i.uv);</span><br><span class="line"></span><br><span class="line">              half3 view_dir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.pos_world);</span><br><span class="line">              half3 light_dir =<span class="built_in">normalize</span>( _WorldSpaceLightPos0.xyz );</span><br><span class="line"></span><br><span class="line">              <span class="comment">//Normal</span></span><br><span class="line">              half3 normal_dir  =<span class="built_in">normalize</span>(i.normali_dir);</span><br><span class="line">              half3 tangent_dir  =<span class="built_in">normalize</span>(i.tangent_dir)*_NormalIntensity;</span><br><span class="line">              half3 binormal_dir =<span class="built_in">normalize</span>(i.binormal_dir)*_NormalIntensity;</span><br><span class="line">              half3 normal_data = <span class="built_in">UnpackNormal</span>(normalmap);</span><br><span class="line">              float3x3 TBN = <span class="built_in">float3x3</span>(tangent_dir,binormal_dir,normal_dir);</span><br><span class="line">              normal_dir =<span class="built_in">normalize</span>(<span class="built_in">mul</span>(normal_data,TBN));</span><br><span class="line">              <span class="comment">//normal_dir=tangent_dir*normal_data.x*_NormalIntensity+binormal_dir*normal_data.y*_NormalIntensity+normal_dir*normal_data.z ;</span></span><br><span class="line">              </span><br><span class="line">              half NotL = <span class="built_in">max</span>(<span class="built_in">dot</span>(normal_dir,light_dir),<span class="number">0</span>);</span><br><span class="line">              half3 diffuse =  NotL*_LightColor0.xyz;</span><br><span class="line">              half3 specular =  <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(<span class="built_in">reflect</span>(-light_dir,normal_dir),view_dir),<span class="number">0</span>),_Shininess)* _LightColor0.xyz*_SpecularIntensity*spec_mask;</span><br><span class="line">              half3 ambient =  _AmbientColor.xyz*__AmbientIntensity;</span><br><span class="line">              </span><br><span class="line">              <span class="comment">//col.xyz+= AO;</span></span><br><span class="line"></span><br><span class="line">              col.xyz += diffuse;</span><br><span class="line">              col.xyz += specular;</span><br><span class="line">              col.xyz += ambient;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// sample the texture</span></span><br><span class="line">              col.xyz *=<span class="built_in">tex2D</span>(_MainTex, i.uv).xyz;</span><br><span class="line">              col.xyz *=AO;</span><br><span class="line">              <span class="comment">// apply fog</span></span><br><span class="line">              <span class="keyword">return</span> col;</span><br><span class="line">          &#125;</span><br><span class="line">          ENDCG</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h2 id="ForwardAdd-Pass"><a href="#ForwardAdd-Pass" class="headerlink" title="ForwardAdd Pass"></a>ForwardAdd Pass</h2><h3 id="关键点-1"><a href="#关键点-1" class="headerlink" title="关键点"></a>关键点</h3><p>需要将光照模式调为ForwardAdd</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardAdd&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>要加混合模式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Blend One One</span><br></pre></td></tr></table></figure>

<p>在编写时加入如下引用文件以方便获取光照参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdadd</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AutoLight.cginc&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>appadata</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">appdata</span></span><br><span class="line">       &#123;</span><br><span class="line">           float4 vertex : POSITION;</span><br><span class="line">           float2 uv : TEXCOORD0;</span><br><span class="line">           float3 normal:NORMAL;<span class="comment">//法线</span></span><br><span class="line">           float4 tangent:TANGENT;<span class="comment">//切线注意是四维向量，w用来矫正平台的区别</span></span><br><span class="line">       &#125;;</span><br></pre></td></tr></table></figure>

<p>片元数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">v2f</span></span><br><span class="line">       &#123;</span><br><span class="line">           float2 uv : TEXCOORD0;</span><br><span class="line">           float4 vertex : SV_POSITION;</span><br><span class="line">           float3 normali_dir:TEXCOORD1;</span><br><span class="line">           float3 tangent_dir:TEXCOORD2;</span><br><span class="line">           float3 binormal_dir:TEXCOORD3;</span><br><span class="line">           float3 pos_world:TEXCOORD4;</span><br><span class="line"></span><br><span class="line">       &#125;;</span><br></pre></td></tr></table></figure>

<p>光源数据</p>
<p>如果是定向光的话和ForwardBase是一样的，但如果是点光源的话应考虑衰减量和光照方向</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">half3 light_dir =<span class="built_in">normalize</span>( _WorldSpaceLightPos0.xyz-i.pos_world.xyz ); </span><br><span class="line">            half distance=<span class="built_in">length</span>(_WorldSpaceLightPos0.xyz-i.pos_world.xyz);</span><br><span class="line">            <span class="type">float</span> range = <span class="number">1.0</span>/unity_WorldToLight[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            half attuenation =<span class="built_in">saturate</span>((range-distance)/range);</span><br></pre></td></tr></table></figure>

<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">     Pass</span><br><span class="line">     &#123;</span><br><span class="line">         Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardAdd&quot;</span>&#125;</span><br><span class="line">         Blend One One</span><br><span class="line">         CGPROGRAM</span><br><span class="line">         <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">         <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">         <span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdadd</span></span><br><span class="line">         <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">         <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AutoLight.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">struct</span> appdata</span><br><span class="line">         &#123;</span><br><span class="line">             float4 vertex : POSITION;</span><br><span class="line">             float2 uv : TEXCOORD0;</span><br><span class="line">             float3 normal:NORMAL;</span><br><span class="line">             float4 tangent:TANGENT;</span><br><span class="line">         &#125;;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">struct</span> <span class="title class_">v2f</span></span><br><span class="line">         &#123;</span><br><span class="line">             float2 uv : TEXCOORD0;</span><br><span class="line">             float4 vertex : SV_POSITION;</span><br><span class="line">             float3 normali_dir:TEXCOORD1;</span><br><span class="line">             float3 tangent_dir:TEXCOORD2;</span><br><span class="line">             float3 binormal_dir:TEXCOORD3;</span><br><span class="line">             float3 pos_world:TEXCOORD4;</span><br><span class="line"></span><br><span class="line">         &#125;;</span><br><span class="line"></span><br><span class="line">         sampler2D _MainTex;</span><br><span class="line">         float4 _MainTex_ST;</span><br><span class="line">         sampler2D _AOMap;</span><br><span class="line">         float4 _AOMap_ST;</span><br><span class="line">         float4 _LightColor0;</span><br><span class="line">         <span class="type">float</span> _Shininess;</span><br><span class="line">         <span class="type">float</span> _SpecularIntensity;</span><br><span class="line">         float4 _AmbientColor; </span><br><span class="line">         sampler2D _SpecMask;</span><br><span class="line">         <span class="type">float</span> _SpecMask_ST; </span><br><span class="line">         sampler2D _NormalMap;</span><br><span class="line">         float4 _NormalMap_ST; </span><br><span class="line">         <span class="type">float</span> _NormalIntensity;</span><br><span class="line"></span><br><span class="line">         <span class="function">float3 <span class="title">ACESFilm</span><span class="params">(float3 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">float</span> a = <span class="number">2.51f</span>;</span><br><span class="line">  <span class="type">float</span> b = <span class="number">0.03f</span>;</span><br><span class="line">  <span class="type">float</span> c = <span class="number">2.43f</span>;</span><br><span class="line">  <span class="type">float</span> d = <span class="number">0.59f</span>;</span><br><span class="line">  <span class="type">float</span> e = <span class="number">0.14f</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">saturate</span>((x*(a*x + b)) / (x*(c*x + d) + e));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">         <span class="function">v2f <span class="title">vert</span> <span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function">         </span>&#123;</span><br><span class="line">             v2f o;</span><br><span class="line">             o.vertex = <span class="built_in">UnityObjectToClipPos</span>(v.vertex);</span><br><span class="line">             o.normali_dir = <span class="built_in">normalize</span>(<span class="built_in">mul</span>(<span class="built_in">float4</span>(v.normal,<span class="number">0.0</span>),unity_WorldToObject).xyz);</span><br><span class="line">             o.tangent_dir = <span class="built_in">normalize</span>(<span class="built_in">mul</span>(<span class="built_in">float4</span>(v.tangent.xyz,<span class="number">0.0</span>),unity_WorldToObject).xyz);</span><br><span class="line">             o.binormal_dir = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(o.normali_dir,o.tangent_dir))*v.tangent.w;</span><br><span class="line">             o.pos_world = <span class="built_in">mul</span>(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line">             o.uv = <span class="built_in">TRANSFORM_TEX</span>(v.uv, _MainTex);</span><br><span class="line">             <span class="keyword">return</span> o;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function">fixed4 <span class="title">frag</span> <span class="params">(v2f i)</span> : SV_Target</span></span><br><span class="line"><span class="function">         &#123;</span></span><br><span class="line">             fixed4 col=<span class="built_in">fixed4</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">             half3 spec_mask = <span class="built_in">tex2D</span>(_SpecMask,i.uv).xyz;</span><br><span class="line">             half4 normalmap = <span class="built_in">tex2D</span>(_NormalMap,i.uv);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             half3 normal_dir  =<span class="built_in">normalize</span>(i.normali_dir);</span><br><span class="line">             half3 tangent_dir  =<span class="built_in">normalize</span>(i.tangent_dir);</span><br><span class="line">             half3 binormal_dir =<span class="built_in">normalize</span>(i.binormal_dir);</span><br><span class="line">             half3 normal_data = <span class="built_in">UnpackNormal</span>(normalmap);</span><br><span class="line">              normal_dir= tangent_dir*normal_data.x *_NormalIntensity+binormal_dir*normal_data.y*_NormalIntensity+normal_dir*normal_data.z ;</span><br><span class="line">             half3 view_dir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.pos_world);</span><br><span class="line">             <span class="meta">#<span class="keyword">if</span> defined (DIRECTIONAL)</span></span><br><span class="line">             half3 light_dir =<span class="built_in">normalize</span>( _WorldSpaceLightPos0.xyz );</span><br><span class="line">             half attuenation=<span class="number">1.0</span>;</span><br><span class="line">             <span class="meta">#<span class="keyword">elif</span> defined (POINT) </span></span><br><span class="line">             half3 light_dir =<span class="built_in">normalize</span>( _WorldSpaceLightPos0.xyz-i.pos_world.xyz ); </span><br><span class="line">             half distance=<span class="built_in">length</span>(_WorldSpaceLightPos0.xyz-i.pos_world.xyz);</span><br><span class="line">             <span class="type">float</span> range = <span class="number">1.0</span>/unity_WorldToLight[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">             half attuenation =<span class="built_in">saturate</span>((range-distance)/range);</span><br><span class="line">              </span><br><span class="line">             <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">             half NotL = <span class="built_in">max</span>(<span class="built_in">dot</span>(normal_dir,light_dir),<span class="number">0</span>);</span><br><span class="line">             half3 diffuse =  NotL*_LightColor0.xyz;</span><br><span class="line">             half3 specular =  <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(<span class="built_in">reflect</span>(-light_dir,normal_dir),view_dir),<span class="number">0</span>),_Shininess)* _LightColor0.xyz*_SpecularIntensity*spec_mask;</span><br><span class="line">             half3 AO = <span class="built_in">tex2D</span>(_AOMap,i.uv).xyz;</span><br><span class="line">             </span><br><span class="line">             <span class="comment">//col.xyz+= AO;</span></span><br><span class="line"></span><br><span class="line">             col.xyz += diffuse;</span><br><span class="line">             col.xyz += specular;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// sample the texture</span></span><br><span class="line">             col.xyz *=<span class="built_in">tex2D</span>(_MainTex, i.uv).xyz;</span><br><span class="line">             col.xyz *=AO;</span><br><span class="line">             col.xyz *=attuenation;</span><br><span class="line">             <span class="comment">// apply fog</span></span><br><span class="line">             <span class="keyword">return</span> col;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">         ENDCG</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>后处理技术（上）</title>
    <url>/2022/02/20/%E5%90%8E%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF1/</url>
    <content><![CDATA[<h1 id="后处理（上）"><a href="#后处理（上）" class="headerlink" title="后处理（上）"></a>后处理（上）</h1><h2 id="启用后处理"><a href="#启用后处理" class="headerlink" title="启用后处理"></a>启用后处理</h2><p>在摄像头添加脚本</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line">[<span class="meta">ExecuteInEditMode()</span>]<span class="comment">//编辑模式就能看到效果</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CameraPostPress</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Material mat;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mat==<span class="literal">null</span>||SystemInfo.supportsImageEffects==<span class="literal">false</span>||mat.shader==<span class="literal">null</span>||mat.shader.isSupported==<span class="literal">false</span>) &#123;</span><br><span class="line">            enabled = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture source, RenderTexture destination</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//当渲染图片启用   source是帧处理的图片 0是pass的顺序</span></span><br><span class="line">        Graphics.Blit(source,destination,mat, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="背景板"><a href="#背景板" class="headerlink" title="背景板"></a>背景板</h2><p><img src="https://img-blog.csdnimg.cn/d5c8641a1ca14b439e5c36b1b84949da.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>只要物体能拓展到屏幕上，就能让图片平铺到图片上，在片源部分做</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">half2 screen_uv = i.screen_pos.xy / (i.screen_pos.w + <span class="number">0.000001</span>);</span><br><span class="line">screen_uv = (screen_uv + <span class="number">1.0</span>) * <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure>

<p>注意的是dx的y轴是反的</p>
<p>有三套解决方案</p>
<h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v2f <span class="title function_">vert</span> <span class="params">(appdata v)</span></span><br><span class="line">&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    o.uv = v.uv;</span><br><span class="line">    o.screen_pos = o.vertex;</span><br><span class="line">    o.screen_pos.y = -o.screen_pos.y;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    half2 screen_uv = i.screen_pos.xy / (i.screen_pos.w + <span class="number">0.000001</span>);</span><br><span class="line">    screen_uv = (screen_uv + <span class="number">1.0</span>) * <span class="number">0.5</span>; </span><br><span class="line">    <span class="comment">// sample the texture</span></span><br><span class="line">    fixed4 col = tex2D(_MainTex, screen_uv);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v2f <span class="title function_">vert</span> <span class="params">(appdata v)</span></span><br><span class="line">&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    o.uv = v.uv;</span><br><span class="line">    o.screen_pos = o.vertex;</span><br><span class="line">    o.screen_pos.y = o.screen_pos.y * _ProjectionParams.x;<span class="comment">//改变</span></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    half2 screen_uv = i.screen_pos.xy / (i.screen_pos.w + <span class="number">0.000001</span>);</span><br><span class="line">    screen_uv = (screen_uv + <span class="number">1.0</span>) * <span class="number">0.5</span>;</span><br><span class="line">    <span class="comment">// sample the texture</span></span><br><span class="line">    fixed4 col = tex2D(_MainTex, screen_uv);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v2f <span class="title function_">vert</span> <span class="params">(appdata v)</span></span><br><span class="line">&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    o.uv = v.uv;</span><br><span class="line">    o.screen_pos=ComputeScreenPos(o.vertex);<span class="comment">//改变</span></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;c</span><br><span class="line"></span><br><span class="line">fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    half2 screen_uv = i.screen_pos.xy / (i.screen_pos.w + <span class="number">0.000001</span>);</span><br><span class="line">       <span class="comment">//改变</span></span><br><span class="line">    <span class="comment">// sample the texture</span></span><br><span class="line">    fixed4 col = tex2D(_MainTex, screen_uv);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="背景板代码"><a href="#背景板代码" class="headerlink" title="背景板代码"></a>背景板代码</h3><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unlit/Quad&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            <span class="comment">// make fog work</span></span><br><span class="line">           </span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float4 screen_pos:TEXCOORD1;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = v.uv;</span><br><span class="line">                <span class="comment">//o.screen_pos = o.vertex;</span></span><br><span class="line">                <span class="comment">//o.screen_pos.y = -o.screen_pos.y;</span></span><br><span class="line">                o.screen_pos=ComputeScreenPos(o.vertex);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                half2 screen_uv = i.screen_pos.xy / (i.screen_pos.w + <span class="number">0.000001</span>);</span><br><span class="line">                screen_uv = (screen_uv + <span class="number">1.0</span>) * <span class="number">0.5</span>;</span><br><span class="line">                <span class="comment">// sample the texture</span></span><br><span class="line">                fixed4 col = tex2D(_MainTex, screen_uv);</span><br><span class="line">               </span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="调色"><a href="#调色" class="headerlink" title="调色"></a>调色</h2><p><img src="https://img-blog.csdnimg.cn/67f8be49624b4c17be5c5d3a4f3100d7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="ASE"><a href="#ASE" class="headerlink" title="ASE"></a>ASE</h3><p><img src="https://img-blog.csdnimg.cn/68a7f0f72c9645ff8b3eb0c407796880.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><h4 id="色调"><a href="#色调" class="headerlink" title="色调"></a>色调</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">float3 <span class="title function_">HSVToRGB</span><span class="params">(float3 c)</span> &#123;</span><br><span class="line">    float4 K = float4(<span class="number">1.0</span>, <span class="number">2.0</span> / <span class="number">3.0</span>, <span class="number">1.0</span> / <span class="number">3.0</span>, <span class="number">3.0</span>);</span><br><span class="line">    float3 p = <span class="built_in">abs</span>(frac(c.xxx + K.xyz) * <span class="number">6.0</span> - K.www);</span><br><span class="line">    <span class="keyword">return</span> c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//RGB B*lerp(float3(1.0,1.0,1.0)) frac 取小数部分 色调（H），饱和度（S），明度（V）。</span></span><br><span class="line"><span class="comment">//H=B*lerp(1.0f,saturate(abs(frac(R + 1.0) * 6.0 - 3.0) - 1.0f),G)</span></span><br><span class="line"><span class="comment">//S=B*lerp(1.0f,saturate(abs(frac(R +  2.0 / 3.0) * 6.0 - 3.0) - 1.0f),G)</span></span><br><span class="line"><span class="comment">//V=B*lerp(1.0f,saturate(abs(frac(R +  1.0 / 3.0) * 6.0 - 3.0) - 1.0f),G)</span></span><br><span class="line">float3 <span class="title function_">RGBToHSV</span><span class="params">(float3 c)</span> &#123;</span><br><span class="line">    float4 K = float4(<span class="number">0.0</span>, <span class="number">-1.0</span> / <span class="number">3.0</span>, <span class="number">2.0</span> / <span class="number">3.0</span>, <span class="number">-1.0</span>);</span><br><span class="line">    float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));</span><br><span class="line">    float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));</span><br><span class="line">    <span class="type">float</span> d = q.x - min(q.w, q.y);</span><br><span class="line">    <span class="type">float</span> e = <span class="number">1.0e-10</span>;</span><br><span class="line">    <span class="keyword">return</span> float3(<span class="built_in">abs</span>(q.z + (q.w - q.y) / (<span class="number">6.0</span> * d + e)), d / (q.x + e), q.x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="亮度"><a href="#亮度" class="headerlink" title="亮度"></a>亮度</h4><p>简单粗暴直接乘</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">col.rgb=col.rgb*_Brightness;</span><br></pre></td></tr></table></figure>

<h4 id="饱和度"><a href="#饱和度" class="headerlink" title="饱和度"></a>饱和度</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> lumin=dot(col.rgb,float3(<span class="number">0.22</span>,<span class="number">0.707</span>,<span class="number">0.071</span>));</span><br><span class="line">col.rgb=lerp(lumin,col.rgb,_Saturation);</span><br></pre></td></tr></table></figure>

<h4 id="对比度"><a href="#对比度" class="headerlink" title="对比度"></a>对比度</h4><p>float3(0.5,0.5,0.5)是灰色</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">col.rgb=lerp(float3(<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>),col.rgb,_Contrast);</span><br></pre></td></tr></table></figure>

<h4 id="暗角-x2F-晕影"><a href="#暗角-x2F-晕影" class="headerlink" title="暗角&#x2F;晕影"></a>暗角&#x2F;晕影</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">float2 d=<span class="built_in">abs</span>(i.uv<span class="number">-0.5</span>)*_VignetteIntensity;</span><br><span class="line">d=<span class="built_in">pow</span>(saturate(d),_VignetteRoundness);</span><br><span class="line"><span class="type">float</span> dist=length(d);</span><br><span class="line">col.rgb=<span class="built_in">pow</span>(saturate(<span class="number">1.0</span>-dist*dist),_VignetteSmoothness)*col.rgb;</span><br></pre></td></tr></table></figure>

<h3 id="调色代码"><a href="#调色代码" class="headerlink" title="调色代码"></a>调色代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Hidden/Color_Code&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Brightness(<span class="string">&quot;Brightness&quot;</span>, Float) = <span class="number">1</span></span><br><span class="line">        _Saturation(<span class="string">&quot;Saturation&quot;</span>,Float) = <span class="number">1</span></span><br><span class="line">        _Contrast(<span class="string">&quot;Contrast&quot;</span>,Float) = <span class="number">1</span></span><br><span class="line">        _VignetteIntensity(<span class="string">&quot;VignetteIntensity&quot;</span>,Range(<span class="number">0.05</span>,<span class="number">3.0</span>)) = <span class="number">1.5</span></span><br><span class="line">        _VignetteRoundness(<span class="string">&quot;VignetteRoundness&quot;</span>,Range(<span class="number">1</span>,<span class="number">6</span>)) = <span class="number">5</span></span><br><span class="line">        _VignetteSmoothness(<span class="string">&quot;VignetteSmoothness&quot;</span>,Range(<span class="number">0.05</span>,<span class="number">5</span>)) = <span class="number">5</span></span><br><span class="line">        _HueShift(<span class="string">&quot;HueShift&quot;</span>,Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// No culling or depth</span></span><br><span class="line">        Cull Off ZWrite Off ZTest Always</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert_img</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">            float3 HSVToRGB(float3 c) &#123;</span><br><span class="line">                float4 K = float4(<span class="number">1.0</span>, <span class="number">2.0</span> / <span class="number">3.0</span>, <span class="number">1.0</span> / <span class="number">3.0</span>, <span class="number">3.0</span>);</span><br><span class="line">                float3 p = <span class="built_in">abs</span>(frac(c.xxx + K.xyz) * <span class="number">6.0</span> - K.www);</span><br><span class="line">                <span class="keyword">return</span> c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//RGB B*lerp(float3(1.0,1.0,1.0)) frac 取小数部分 色调（H），饱和度（S），明度（V）。</span></span><br><span class="line">            <span class="comment">//H=B*lerp(1.0f,saturate(abs(frac(R + 1.0) * 6.0 - 3.0) - 1.0f),G)</span></span><br><span class="line">            <span class="comment">//S=B*lerp(1.0f,saturate(abs(frac(R +  2.0 / 3.0) * 6.0 - 3.0) - 1.0f),G)</span></span><br><span class="line">            <span class="comment">//V=B*lerp(1.0f,saturate(abs(frac(R +  1.0 / 3.0) * 6.0 - 3.0) - 1.0f),G)</span></span><br><span class="line">            float3 <span class="title function_">RGBToHSV</span><span class="params">(float3 c)</span> &#123;</span><br><span class="line">                float4 K = float4(<span class="number">0.0</span>, <span class="number">-1.0</span> / <span class="number">3.0</span>, <span class="number">2.0</span> / <span class="number">3.0</span>, <span class="number">-1.0</span>);</span><br><span class="line">                float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));</span><br><span class="line">                float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));</span><br><span class="line">                <span class="type">float</span> d = q.x - min(q.w, q.y);</span><br><span class="line">                <span class="type">float</span> e = <span class="number">1.0e-10</span>;</span><br><span class="line">                <span class="keyword">return</span> float3(<span class="built_in">abs</span>(q.z + (q.w - q.y) / (<span class="number">6.0</span> * d + e)), d / (q.x + e), q.x);</span><br><span class="line">            &#125;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            <span class="type">float</span> _Brightness;</span><br><span class="line">            <span class="type">float</span> _Saturation;</span><br><span class="line">            <span class="type">float</span> _Contrast;</span><br><span class="line">            <span class="type">float</span> _VignetteIntensity;</span><br><span class="line">            <span class="type">float</span> _VignetteRoundness;</span><br><span class="line">            <span class="type">float</span> _VignetteSmoothness;</span><br><span class="line">            <span class="type">float</span> _HueShift;</span><br><span class="line"></span><br><span class="line">            fixed4 <span class="title function_">frag</span> <span class="params">(v2f_img i)</span> : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                fixed4 sourse = tex2D(_MainTex, i.uv);</span><br><span class="line">                fixed4 col=sourse;</span><br><span class="line">                <span class="comment">//色相</span></span><br><span class="line">                fixed3 hsv = RGBToHSV(sourse.rgb);</span><br><span class="line">                hsv.r= hsv.r +_HueShift;</span><br><span class="line">                col.rgb=HSVToRGB(hsv);</span><br><span class="line">                <span class="comment">//亮度</span></span><br><span class="line">                col.rgb=col.rgb*_Brightness;</span><br><span class="line">                <span class="comment">//饱和度</span></span><br><span class="line">                <span class="type">float</span> lumin=dot(col.rgb,float3(<span class="number">0.22</span>,<span class="number">0.707</span>,<span class="number">0.071</span>));</span><br><span class="line">                col.rgb=lerp(lumin,col.rgb,_Saturation);</span><br><span class="line">                <span class="comment">//对比度</span></span><br><span class="line">                col.rgb=lerp(float3(<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>),col.rgb,_Contrast);</span><br><span class="line">                <span class="comment">//暗角/晕影</span></span><br><span class="line">                float2 d=<span class="built_in">abs</span>(i.uv<span class="number">-0.5</span>)*_VignetteIntensity;</span><br><span class="line"></span><br><span class="line">                d=<span class="built_in">pow</span>(saturate(d),_VignetteRoundness);</span><br><span class="line">                <span class="type">float</span> dist=length(d);</span><br><span class="line">                col.rgb=<span class="built_in">pow</span>(saturate(<span class="number">1.0</span>-dist*dist),_VignetteSmoothness)*col.rgb; </span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="破碎的玻璃"><a href="#破碎的玻璃" class="headerlink" title="破碎的玻璃"></a>破碎的玻璃</h2><p><img src="https://img-blog.csdnimg.cn/bdbfbc20fb5140fa916c22f3d7e11676.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="上玻璃"><a href="#上玻璃" class="headerlink" title="上玻璃"></a>上玻璃</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> aspect = _ScreenParams.x / _ScreenParams.y; <span class="comment">// x = width y = height z = 1 + 1.0/width w = 1 + 1.0/height</span></span><br><span class="line">float2 glass_uv = float2(i.uv.x * aspect, i.uv.y) * _GlassMask_ST.xy + _GlassMask_ST.zw;</span><br><span class="line"></span><br><span class="line">half glass_opacity = tex2D(_GlassMask, glass_uv).r;</span><br><span class="line">finalcolor = lerp(finalcolor, _GlassCrack.xxx, glass_opacity);</span><br></pre></td></tr></table></figure>

<h3 id="上法线"><a href="#上法线" class="headerlink" title="上法线"></a>上法线</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">half3 glass_normal = UnpackNormal(tex2D(_GlassNormal, glass_uv));</span><br></pre></td></tr></table></figure>

<h3 id="解决边缘法线贴图重影"><a href="#解决边缘法线贴图重影" class="headerlink" title="解决边缘法线贴图重影"></a>解决边缘法线贴图重影</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">half2 d = <span class="number">1.0</span> - smoothstep(<span class="number">0.95</span>,<span class="number">1</span>,<span class="built_in">abs</span>(i.uv * <span class="number">2.0</span> - <span class="number">1.0</span>));</span><br><span class="line">half vfactor = d.x * d.y;</span><br></pre></td></tr></table></figure>

<h3 id="解决法线贴图毛玻璃的问题"><a href="#解决法线贴图毛玻璃的问题" class="headerlink" title="解决法线贴图毛玻璃的问题"></a>解决法线贴图毛玻璃的问题</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">float2 d_mask = step(<span class="number">0.005</span>, <span class="built_in">abs</span>(glass_normal.xy));</span><br><span class="line"><span class="type">float</span> mask = d_mask.x * d_mask.y;</span><br><span class="line">half2 uv_distort = i.uv + glass_normal.xy * _Distort * vfactor * mask;</span><br><span class="line">half4 col = tex2D(_MainTex, uv_distort);</span><br></pre></td></tr></table></figure>

<h3 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Hidden/BrokenGlass&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">  Properties</span><br><span class="line">  &#123;</span><br><span class="line">    _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    _GlassMask(<span class="string">&quot;GlassMask&quot;</span>,<span class="number">2</span>D) = <span class="string">&quot;black&quot;</span>&#123;&#125;</span><br><span class="line">    _GlassCrack(<span class="string">&quot;GlassCrack&quot;</span>,Float) = <span class="number">1</span></span><br><span class="line">    _GlassNormal(<span class="string">&quot;GlassNormal&quot;</span>,<span class="number">2</span>D) = <span class="string">&quot;bump&quot;</span>&#123;&#125;</span><br><span class="line">    _Distort(<span class="string">&quot;Distort&quot;</span>,Float) = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  SubShader</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// No culling or depth</span></span><br><span class="line">    Cull Off ZWrite Off ZTest Always</span><br><span class="line"></span><br><span class="line">    Pass</span><br><span class="line">    &#123;</span><br><span class="line">      CGPROGRAM</span><br><span class="line">      <span class="meta">#<span class="keyword">pragma</span> vertex vert_img</span></span><br><span class="line">      <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">      </span><br><span class="line">      <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">    </span><br><span class="line">      sampler2D _MainTex;</span><br><span class="line">      sampler2D _GlassMask;</span><br><span class="line">      float4 _GlassMask_ST;</span><br><span class="line">      <span class="type">float</span> _GlassCrack;</span><br><span class="line">      sampler2D _GlassNormal;</span><br><span class="line">      <span class="type">float</span> _Distort;</span><br><span class="line"></span><br><span class="line">      half4 <span class="title function_">frag</span> <span class="params">(v2f_img i)</span> : SV_Target</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">float</span> aspect = _ScreenParams.x / _ScreenParams.y; <span class="comment">// x = width y = height z = 1 + 1.0/width w = 1 + 1.0/height</span></span><br><span class="line">        float2 glass_uv = float2(i.uv.x * aspect, i.uv.y) * _GlassMask_ST.xy + _GlassMask_ST.zw;</span><br><span class="line"></span><br><span class="line">        half glass_opacity = tex2D(_GlassMask, glass_uv).r;</span><br><span class="line">        half3 glass_normal = UnpackNormal(tex2D(_GlassNormal, glass_uv));</span><br><span class="line"></span><br><span class="line">        half2 d = <span class="number">1.0</span> - smoothstep(<span class="number">0.95</span>,<span class="number">1</span>,<span class="built_in">abs</span>(i.uv * <span class="number">2.0</span> - <span class="number">1.0</span>));</span><br><span class="line">        half vfactor = d.x * d.y;</span><br><span class="line"></span><br><span class="line">        float2 d_mask = step(<span class="number">0.005</span>, <span class="built_in">abs</span>(glass_normal.xy));</span><br><span class="line">        <span class="type">float</span> mask = d_mask.x * d_mask.y;</span><br><span class="line"></span><br><span class="line">        half2 uv_distort = i.uv + glass_normal.xy * _Distort * vfactor * mask;</span><br><span class="line">        half4 col = tex2D(_MainTex, uv_distort);</span><br><span class="line">        half3 finalcolor = col.rgb;</span><br><span class="line">        finalcolor = lerp(finalcolor, _GlassCrack.xxx, glass_opacity);</span><br><span class="line">        <span class="keyword">return</span> float4(finalcolor,col.a);</span><br><span class="line">      &#125;</span><br><span class="line">      ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>后处理技术（下）</title>
    <url>/2022/02/24/%E5%90%8E%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF3/</url>
    <content><![CDATA[<h1 id="HDRBloom（光晕）"><a href="#HDRBloom（光晕）" class="headerlink" title="HDRBloom（光晕）"></a>HDRBloom（光晕）</h1><p>取亮光部分，进行降采样，在升采样的过程中，叠加降采样对应尺寸的图片，合并效果图和源图片</p>
<h2 id="初处理"><a href="#初处理" class="headerlink" title="初处理"></a>初处理</h2><p>如果放入的是HDR图片，可以在shader里面加float4 _MainTex_HDR;   col.rgb  &#x3D; DecodeHDR(col,_MainTex_HDR);进行解码。</p>
<h2 id="取光亮部分"><a href="#取光亮部分" class="headerlink" title="取光亮部分"></a>取光亮部分</h2><p>先进行均值模糊，取亮色部分。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">float</span> intensity = Mathf.Exp(_Intensity / <span class="number">10.0f</span> * <span class="number">0.693f</span>) - <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">mat.SetFloat(<span class="string">&quot;_Threshold&quot;</span>, _Threshold);</span><br><span class="line">mat.SetFloat(<span class="string">&quot;_Intensity&quot;</span>, intensity);</span><br><span class="line"></span><br><span class="line"><span class="comment">//取亮色</span></span><br><span class="line">Graphics.Blit(source, RT_Down[<span class="number">0</span>], mat, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">half4 <span class="title function_">frag_PreFilter</span><span class="params">(v2f_img i)</span> : SV_Target<span class="comment">//0</span></span><br><span class="line">&#123;</span><br><span class="line">    half4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">    half4 d=_MainTex_TexelSize.xyxy*half4(<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">    col.rgb+=tex2D(_MainTex,i.uv+d.xy).rgb;</span><br><span class="line">    col.rgb+=tex2D(_MainTex,i.uv+d.zy).rgb;</span><br><span class="line">    col.rgb+=tex2D(_MainTex,i.uv+d.xw).rgb;</span><br><span class="line">    col.rgb+=tex2D(_MainTex,i.uv+d.zw).rgb;</span><br><span class="line">    col.rgb*=<span class="number">0.25</span>;</span><br><span class="line">    <span class="type">float</span> br = max(max(col.r,col.g),col.b);</span><br><span class="line">    br =  max(<span class="number">0</span>,(br - _Threshold))/max(<span class="number">0.00001</span>,br);</span><br><span class="line">    col.rgb*=br;</span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="降采样"><a href="#降采样" class="headerlink" title="降采样"></a>降采样</h2><p>用双重盒状模糊的降采样方式</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//降采样</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;_Iteration;i++) &#123;<span class="comment">//0-i-1</span></span><br><span class="line">    Graphics.Blit(RT_Down[i], RT_Down[i + <span class="number">1</span>], mat, <span class="number">1</span>);</span><br><span class="line">   <span class="comment">// print(&quot;downcode &quot; + i );</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">half4 <span class="title function_">frag_DownsampleBox</span><span class="params">(v2f_img i)</span> : SV_Target<span class="comment">//1</span></span><br><span class="line">&#123;</span><br><span class="line">    half4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">    half4 d=_MainTex_TexelSize.xyxy*half4(<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">    col.rgb+=tex2D(_MainTex,i.uv+d.xy).rgb;</span><br><span class="line">    col.rgb+=tex2D(_MainTex,i.uv+d.zy).rgb;</span><br><span class="line">    col.rgb+=tex2D(_MainTex,i.uv+d.xw).rgb;</span><br><span class="line">    col.rgb+=tex2D(_MainTex,i.uv+d.zw).rgb;</span><br><span class="line">    col.rgb*=<span class="number">0.25</span>;</span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="升采样"><a href="#升采样" class="headerlink" title="升采样"></a>升采样</h2><p>升采样过程中加同尺寸的降采样贴图</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Graphics.Blit(RT_Down[_Iteration], RT_Up[_Iteration]);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=_Iteration;i&gt;<span class="number">0</span>;i--) &#123;</span><br><span class="line">    mat.SetTexture(<span class="string">&quot;_BloomTex&quot;</span>, RT_Down[i<span class="number">-1</span>]);</span><br><span class="line">    Graphics.Blit(RT_Up[i], RT_Up[i<span class="number">-1</span>], mat, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">//print(&quot;upcode &quot; + i);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">half4 <span class="title function_">frag_UpsampleBox</span><span class="params">(v2f_img i)</span> : SV_Target<span class="comment">//2</span></span><br><span class="line">&#123;</span><br><span class="line">    half4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">    half4 d=_MainTex_TexelSize.xyxy*half4(<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">    col.rgb+=tex2D(_MainTex,i.uv+d.xy).rgb;</span><br><span class="line">    col.rgb+=tex2D(_MainTex,i.uv+d.zy).rgb;</span><br><span class="line">    col.rgb+=tex2D(_MainTex,i.uv+d.xw).rgb;</span><br><span class="line">    col.rgb+=tex2D(_MainTex,i.uv+d.zw).rgb;</span><br><span class="line">    col.rgb*=<span class="number">0.25</span>;</span><br><span class="line">    half4 color2 = tex2D(_BloomTex, i.uv);</span><br><span class="line">    <span class="keyword">return</span> col + color2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>把升采样的最后一张图和原图合并,和释放贴图。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">mat.SetTexture(<span class="string">&quot;_BloomTex&quot;</span>, RT_Up[<span class="number">0</span>]);</span><br><span class="line">Graphics.Blit(source, destination, mat, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//Release</span></span><br><span class="line"><span class="comment">//RenderTexture.ReleaseTemporary(RT1);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; _Iteration+<span class="number">1</span>; i++) &#123;</span><br><span class="line">   <span class="comment">// print(&quot;Release &quot; + i);</span></span><br><span class="line"></span><br><span class="line">    RenderTexture.ReleaseTemporary(RT_Down[i]);</span><br><span class="line">    RenderTexture.ReleaseTemporary(RT_Up[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">half4 <span class="title function_">frag_Combine</span><span class="params">(v2f_img i)</span> : SV_Target<span class="comment">//3</span></span><br><span class="line">&#123;</span><br><span class="line">    half4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">    half3 color1 = tex2D(_BloomTex, i.uv).rgb;</span><br><span class="line">    col.rgb+= color1.rgb*_Intensity;</span><br><span class="line">    <span class="keyword">return</span> col ;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h2 id="最后小瑕疵"><a href="#最后小瑕疵" class="headerlink" title="最后小瑕疵"></a>最后小瑕疵</h2><p>在光晕的周围还有点不自然。可用如下解决方案。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">float3 <span class="title function_">ACES_Tonemapping</span><span class="params">(float3 x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">float</span> a = <span class="number">2.51f</span>;</span><br><span class="line">  <span class="type">float</span> b = <span class="number">0.03f</span>;</span><br><span class="line">  <span class="type">float</span> c = <span class="number">2.43f</span>;</span><br><span class="line">  <span class="type">float</span> d = <span class="number">0.59f</span>;</span><br><span class="line">  <span class="type">float</span> e = <span class="number">0.14f</span>;</span><br><span class="line">  float3 encode_color = saturate((x*(a*x + b)) / (x*(c*x + d) + e));</span><br><span class="line">  <span class="keyword">return</span> encode_color;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">half4 <span class="title function_">frag</span> <span class="params">(v2f_img i)</span> : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">  half4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">  half3 linear_color = <span class="built_in">pow</span>(col.rgb, <span class="number">2.2</span>);</span><br><span class="line">  half3 encode_color = ACES_Tonemapping(linear_color);</span><br><span class="line">  half3 final_color = <span class="built_in">pow</span>(encode_color, <span class="number">1.0</span> / <span class="number">2.2</span>);</span><br><span class="line">  <span class="keyword">return</span> float4(final_color,col.a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="后处理的顺序"><a href="#后处理的顺序" class="headerlink" title="后处理的顺序"></a>后处理的顺序</h1><p><img src="https://img-blog.csdnimg.cn/3c671e3fee7c4999bd942e25acf1ea62.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>调整顺序：Bloom-&gt;Vignette-&gt;Tonemapping-&gt;ColorGrading</p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>特效篇溶解算法</title>
    <url>/2022/04/25/%E7%89%B9%E6%95%88%E7%AF%87%E6%BA%B6%E8%A7%A3%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="简单的溶解"><a href="#简单的溶解" class="headerlink" title="简单的溶解"></a>简单的溶解</h1><h2 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h2><p><img src="https://img-blog.csdnimg.cn/32ce53bae89a46b09a75ba4bd24aad1a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="溶解边缘"><a href="#溶解边缘" class="headerlink" title="溶解边缘"></a>溶解边缘</h2><p><img src="https://img-blog.csdnimg.cn/475b6118b8ce4488926b9e174b1c02e6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="合成效果"><a href="#合成效果" class="headerlink" title="合成效果"></a>合成效果</h2><p><img src="https://img-blog.csdnimg.cn/0c70eee974984a19a21bc3f15ff2e1ec.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="改进1"><a href="#改进1" class="headerlink" title="改进1"></a>改进1</h1><p>溶解边缘柔和<br><img src="https://img-blog.csdnimg.cn/24518b48f8da422ebaffeba0ac2337bc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/6b354c34d2b4476aabf715adb4628972.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="改进2"><a href="#改进2" class="headerlink" title="改进2"></a>改进2</h1><p>加一定方向的溶解<br><img src="https://img-blog.csdnimg.cn/9f08ba7ff00942428877a4364125fb4b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/04567aaa0ed0433d96694b5d44ef08cd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/25993e1f6067401da28e783127ea2a4e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="加入炭化的效果"><a href="#加入炭化的效果" class="headerlink" title="加入炭化的效果"></a>加入炭化的效果</h1><p>加入Remap的图片，能够将燃烧的黑烟搞出来<br><img src="https://img-blog.csdnimg.cn/d525542e2c034da696951e609b50f749.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/8d28dc8033e740ddab1db767ef2c0ac5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>特效篇火焰</title>
    <url>/2022/03/01/%E7%89%B9%E6%95%88%E7%AF%87%E7%81%AB%E7%84%B0/</url>
    <content><![CDATA[<h1 id="火焰"><a href="#火焰" class="headerlink" title="火焰"></a>火焰</h1><h2 id="制作原理"><a href="#制作原理" class="headerlink" title="制作原理"></a>制作原理</h2><p>利用裁剪方程，将噪点图进行向上流动达到火焰往上升的效果，用一张渐变图和噪点图相乘把上半部分进行裁剪，将颜色的HDR效果打开，现在得到初步的火焰加一点点细节，让火的边缘柔和一点。让噪声图减去一个变量，并钳制在0到1之间，调大变量会使边缘柔和化，接下来是让火焰外焰和内焰效果</p>
<h2 id="透明度"><a href="#透明度" class="headerlink" title="透明度"></a>透明度</h2><p><img src="https://img-blog.csdnimg.cn/b18d6793b8d14c4dbc1549b8e17d6b16.png" alt="在这里插入图片描述"></p>
<h2 id="噪点值"><a href="#噪点值" class="headerlink" title="噪点值"></a>噪点值</h2><p><img src="https://img-blog.csdnimg.cn/a9f0ed3772e7465785f1f268de05ebd6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>噪点图往上移动取R通道</p>
<h2 id="渐变值和内焰边界"><a href="#渐变值和内焰边界" class="headerlink" title="渐变值和内焰边界"></a>渐变值和内焰边界</h2><p><img src="https://img-blog.csdnimg.cn/a3ecd9c74d574044aed2fc070e609e02.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="火焰边缘柔和"><a href="#火焰边缘柔和" class="headerlink" title="火焰边缘柔和"></a>火焰边缘柔和</h2><p><img src="https://img-blog.csdnimg.cn/62b84b85d65440458541ed1d72f8b0e5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>当Softness变大边缘柔和，注意必须要clamp函数</p>
<h2 id="外焰和内焰"><a href="#外焰和内焰" class="headerlink" title="外焰和内焰"></a>外焰和内焰</h2><p><img src="https://img-blog.csdnimg.cn/6533e690f9c94cdca1192da8e6e0e94f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="火焰的形状"><a href="#火焰的形状" class="headerlink" title="火焰的形状"></a>火焰的形状</h2><p><img src="https://img-blog.csdnimg.cn/ab2c4b373bd14b8d8cd4dd0d099d9826.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p><img src="https://img-blog.csdnimg.cn/4f00d42d98774071b79471a128aaf7f9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>色调映射视差偏移</title>
    <url>/2022/03/26/%E8%89%B2%E8%B0%83%E6%98%A0%E5%B0%84%E8%A7%86%E5%B7%AE%E5%81%8F%E7%A7%BB/</url>
    <content><![CDATA[<h1 id="Blinn-Phong"><a href="#Blinn-Phong" class="headerlink" title="Blinn-Phong"></a>Blinn-Phong</h1><p>半角向量&#x3D;观察方向V+光照方向L；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">half3 view_dir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.pos_world);</span><br><span class="line">                half3 light_dir =<span class="built_in">normalize</span>( _WorldSpaceLightPos0.xyz );</span><br><span class="line">                half3 half_dir  = <span class="built_in">normalize</span>(view_dir+light_dir);</span><br><span class="line">half NotH = <span class="built_in">max</span>(<span class="built_in">dot</span>(normal_dir,half_dir),<span class="number">0</span>);</span><br><span class="line">half3 specular =  <span class="built_in">pow</span>(<span class="built_in">max</span>(NotH,<span class="number">0</span>),_Shininess)* _LightColor0.xyz*_SpecularIntensity*spec_mask;</span><br></pre></td></tr></table></figure>

<h1 id="色彩映射"><a href="#色彩映射" class="headerlink" title="色彩映射"></a>色彩映射</h1><p>高光部分过曝，使得颜色直接变白色为了体现更多细节，将色调重新映射,注意一般这个处理都在后处理完成。实现如下。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">float3 <span class="title">ACESFilm</span><span class="params">(float3 x)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        <span class="type">float</span> a = <span class="number">2.51f</span>;</span><br><span class="line">        <span class="type">float</span> b = <span class="number">0.03f</span>;</span><br><span class="line">        <span class="type">float</span> c = <span class="number">2.43f</span>;</span><br><span class="line">        <span class="type">float</span> d = <span class="number">0.59f</span>;</span><br><span class="line">        <span class="type">float</span> e = <span class="number">0.14f</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">saturate</span>((x*(a*x + b)) / (x*(c*x + d) + e));</span><br><span class="line">      &#125;;</span><br><span class="line">base_color =<span class="built_in">pow</span>(base_color,<span class="number">2.2</span>);</span><br><span class="line">half3 tone_color = <span class="built_in">ACESFilm</span>(col.xyz);</span><br><span class="line">col.xyz=<span class="built_in">pow</span>(tone_color,<span class="number">1.0</span>/<span class="number">2.2</span>);</span><br></pre></td></tr></table></figure>

<h1 id="视察偏移"><a href="#视察偏移" class="headerlink" title="视察偏移"></a>视察偏移</h1><p>用高度图模拟侧面的观察的遮挡问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">float3 view_tangentspace = <span class="built_in">normalize</span>(<span class="built_in">mul</span>(TBN,view_dir));</span><br><span class="line">                half2 uv_parallax = i.uv;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;_HeightTime;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    half height = <span class="built_in">tex2D</span>(_Parallax,uv_parallax);</span><br><span class="line">                    uv_parallax = uv_parallax - (<span class="number">0.5</span> - height) * (view_tangentspace.xy/view_tangentspace.z+<span class="number">0.42</span>) *_ParallaxIntensity*<span class="number">0.01f</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                half3 base_color = <span class="built_in">tex2D</span>(_MainTex, uv_parallax).xyz;</span><br><span class="line">                base_color =<span class="built_in">pow</span>(base_color,<span class="number">2.2</span>);</span><br><span class="line">                half3 AO = <span class="built_in">tex2D</span>(_AOMap,uv_parallax).xyz;</span><br><span class="line">                half3 spec_mask = <span class="built_in">tex2D</span>(_SpecMask,uv_parallax).xyz;</span><br></pre></td></tr></table></figure>

<h1 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h1><p><img src="https://img-blog.csdnimg.cn/b4e49300b10d4343bbb929c5b0bb7819.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="实时阴影"><a href="#实时阴影" class="headerlink" title="实时阴影"></a>实时阴影</h2><p>理论知识全适用，但代码只适用于内置渲染管线</p>
<h3 id="传统实时阴影"><a href="#传统实时阴影" class="headerlink" title="传统实时阴影"></a>传统实时阴影</h3><p><img src="https://img-blog.csdnimg.cn/d4e54fe16d55458192dffc2201354366.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>阴影距离决定定向光的拍摄位置位置大概是</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//摄像头的 forword 向量*阴影距离 向光照反方向 + 阴影距离</span></span><br></pre></td></tr></table></figure>

<p>在光源位置做摄像机，拍摄一张深度图</p>
<p><img src="https://img-blog.csdnimg.cn/399f4e8f6a9f4fb4844d403cb000798d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>将光源摄像头内的顶点转入光源相机空间用z坐标z1和shadowMap的灰度值z2进行比对，z1&lt;z2，则不再阴影区，最佳理解：就是单纯的摄像机深度剔除的部分，把光源看作摄像机，看到的就被照亮，没看到的就是阴影咯。</p>
<h3 id="Unity屏幕空间阴影"><a href="#Unity屏幕空间阴影" class="headerlink" title="Unity屏幕空间阴影"></a>Unity屏幕空间阴影</h3><p>用摄像头view渲染深度图，渲染的深度图可以还原屏幕需要的片元的世界坐标空间进行优化</p>
<p><img src="https://img-blog.csdnimg.cn/9346f44043224d33a328311423dcd20d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/52f6b72858994de695791f6b5f9e249f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>然后从Camera直接转到光照摄像头坐标系下。</p>
<h3 id="联级阴影-CSM"><a href="#联级阴影-CSM" class="headerlink" title="联级阴影 CSM"></a>联级阴影 CSM</h3><p>以下是个人通过unity猜测出来的，暂未找资料</p>
<p>分成四个区域，越靠近物体联级越多，把所有得到的联级进行均值混合原理还是前两种方法</p>
<p>证明</p>
<p>无联级，阴影距离3.3</p>
<p><img src="https://img-blog.csdnimg.cn/289b9b933af247808d08256809864b85.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>两联级，阴影距离10</p>
<p><img src="https://img-blog.csdnimg.cn/505e0a7663404e69abafbfecfb47481a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>得到的阴影效果会胡一点，可能是混合了</p>
<h2 id="阴影相关的内置函数"><a href="#阴影相关的内置函数" class="headerlink" title="阴影相关的内置函数"></a>阴影相关的内置函数</h2><h3 id="只计算实时阴影"><a href="#只计算实时阴影" class="headerlink" title="只计算实时阴影"></a>只计算实时阴影</h3><p>记得把v2f结构体中的vertex改成pos。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SHADOW_COORDS</span>(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">TRANSFER_SHADOW</span>(o)</span><br><span class="line">half shadow = <span class="built_in">SHADOW_ATTENUATION</span>(i);</span><br></pre></td></tr></table></figure>

<p>多光源</p>
<h3 id="混合光源计算"><a href="#混合光源计算" class="headerlink" title="混合光源计算"></a>混合光源计算</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">LIGHTING_COORDS</span>(<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">TRANSFER_VERTEX_TO_FRAGMENT</span>(o);</span><br><span class="line">half atten = <span class="built_in">LIGHT_ATTENUATION</span> (i);</span><br><span class="line">half NotL = <span class="built_in">min</span>(atten,<span class="built_in">max</span>(<span class="built_in">dot</span>(normal_dir,light_dir),<span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>在forwardadd中一定把环境光删除，否则出现阴影锯齿。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;lit/Blin-Phong&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _NormalMap(<span class="string">&quot;Normal Map&quot;</span>,<span class="number">2</span>D)=<span class="string">&quot;bump&quot;</span>&#123;&#125;</span><br><span class="line">        _NormalIntensity(<span class="string">&quot;Normal Intensity&quot;</span>,<span class="built_in">Range</span>(<span class="number">0.0</span>,<span class="number">5.0</span>))= <span class="number">1.0</span></span><br><span class="line">        _AOMap(<span class="string">&quot;AO Map&quot;</span>,<span class="number">2</span>D)=<span class="string">&quot;white&quot;</span>&#123;&#125;</span><br><span class="line">         _SpecMask(<span class="string">&quot;Spec Mask&quot;</span>,<span class="number">2</span>D)=<span class="string">&quot;white&quot;</span>&#123;&#125;</span><br><span class="line">        _Shininess (<span class="string">&quot;Shininess&quot;</span>, Float) = <span class="number">1</span></span><br><span class="line">        _SpecularIntensity(<span class="string">&quot;SpecularIntensity&quot;</span>,<span class="built_in">Range</span>(<span class="number">0.01</span>,<span class="number">5</span>))= <span class="number">1.0</span></span><br><span class="line">        _Parallax(<span class="string">&quot;Parallax&quot;</span>,<span class="number">2</span>D)=<span class="string">&quot;black&quot;</span>&#123;&#125;</span><br><span class="line">        _ParallaxIntensity(<span class="string">&quot;Parallax Intensity&quot;</span>,Float)=<span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">        _HeightTime(<span class="string">&quot;Height Time&quot;</span>,<span class="built_in">Range</span>(<span class="number">0</span>,<span class="number">10</span>))=<span class="number">1.0</span></span><br><span class="line">        <span class="comment">//_AmbientColor(&quot;Ambient Color&quot;,Color)=(0,0,0,0)</span></span><br><span class="line">       <span class="comment">// __AmbientIntensity(&quot;Ambient Intensity&quot;,Float)=0</span></span><br><span class="line">       </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span>&#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdbase</span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AutoLight.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 normal:NORMAL;</span><br><span class="line">                float4 tangent:TANGENT;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">v2f</span></span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 normali_dir:TEXCOORD1;</span><br><span class="line">                float3 tangent_dir:TEXCOORD2;</span><br><span class="line">                float3 binormal_dir:TEXCOORD3;</span><br><span class="line">                float3 pos_world:TEXCOORD4;</span><br><span class="line">                <span class="built_in">SHADOW_COORDS</span>(<span class="number">5</span>)</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            sampler2D _AOMap;</span><br><span class="line">            float4 _AOMap_ST;</span><br><span class="line">            float4 _LightColor0;</span><br><span class="line">            <span class="type">float</span> _Shininess;</span><br><span class="line">            <span class="type">float</span> _SpecularIntensity;</span><br><span class="line">            <span class="comment">//float4 _AmbientColor; </span></span><br><span class="line">            sampler2D _SpecMask;</span><br><span class="line">            <span class="type">float</span> _SpecMask_ST; </span><br><span class="line">            sampler2D _NormalMap;</span><br><span class="line">            float4 _NormalMap_ST; </span><br><span class="line">            <span class="type">float</span> _NormalIntensity;</span><br><span class="line">            sampler2D _Parallax;</span><br><span class="line">            <span class="type">float</span> _ParallaxIntensity;</span><br><span class="line">            <span class="type">float</span> _HeightTime;</span><br><span class="line">            <span class="comment">//float __AmbientIntensity;</span></span><br><span class="line"></span><br><span class="line">            <span class="function">float3 <span class="title">ACESFilm</span><span class="params">(float3 x)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        <span class="type">float</span> a = <span class="number">2.51f</span>;</span><br><span class="line">        <span class="type">float</span> b = <span class="number">0.03f</span>;</span><br><span class="line">        <span class="type">float</span> c = <span class="number">2.43f</span>;</span><br><span class="line">        <span class="type">float</span> d = <span class="number">0.59f</span>;</span><br><span class="line">        <span class="type">float</span> e = <span class="number">0.14f</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">saturate</span>((x*(a*x + b)) / (x*(c*x + d) + e));</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span> <span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = <span class="built_in">UnityObjectToClipPos</span>(v.vertex);</span><br><span class="line">                o.normali_dir = <span class="built_in">normalize</span>(<span class="built_in">mul</span>(<span class="built_in">float4</span>(v.normal,<span class="number">0.0</span>),unity_WorldToObject).xyz);</span><br><span class="line">                o.tangent_dir = <span class="built_in">normalize</span>(<span class="built_in">mul</span>(<span class="built_in">float4</span>(v.tangent.xyz,<span class="number">0.0</span>),unity_WorldToObject).xyz);</span><br><span class="line">                o.binormal_dir = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(o.normali_dir,o.tangent_dir))* v.tangent.w;</span><br><span class="line">                o.pos_world = <span class="built_in">mul</span>(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line">                o.uv = <span class="built_in">TRANSFORM_TEX</span>(v.uv, _MainTex);</span><br><span class="line">                <span class="built_in">TRANSFER_SHADOW</span>(o)</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span> <span class="params">(v2f i)</span> : SV_Target</span></span><br><span class="line"><span class="function">            &#123;</span></span><br><span class="line">                fixed4 col=<span class="built_in">fixed4</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">                </span><br><span class="line">           </span><br><span class="line">                half shadow = <span class="built_in">SHADOW_ATTENUATION</span>(i);</span><br><span class="line">                half4 normalmap = <span class="built_in">tex2D</span>(_NormalMap,i.uv);</span><br><span class="line">                half3 view_dir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.pos_world);</span><br><span class="line">                half3 light_dir =<span class="built_in">normalize</span>( _WorldSpaceLightPos0.xyz );</span><br><span class="line">                half3 half_dir  = <span class="built_in">normalize</span>(view_dir+light_dir);</span><br><span class="line">                <span class="comment">//Normal</span></span><br><span class="line">                half3 normal_dir  =<span class="built_in">normalize</span>(i.normali_dir);</span><br><span class="line">                half3 tangent_dir  =<span class="built_in">normalize</span>(i.tangent_dir)*_NormalIntensity;</span><br><span class="line">                half3 binormal_dir =<span class="built_in">normalize</span>(i.binormal_dir)*_NormalIntensity;</span><br><span class="line">                half3 normal_data = <span class="built_in">UnpackNormal</span>(normalmap);</span><br><span class="line">                float3x3 TBN = <span class="built_in">float3x3</span>(tangent_dir,binormal_dir,normal_dir);</span><br><span class="line">                normal_dir =<span class="built_in">normalize</span>(<span class="built_in">mul</span>(normal_data,TBN));</span><br><span class="line">                <span class="comment">//normal_dir=tangent_dir*normal_data.x*_NormalIntensity+binormal_dir*normal_data.y*_NormalIntensity+normal_dir*normal_data.z ;</span></span><br><span class="line">              </span><br><span class="line">                float3 view_tangentspace = <span class="built_in">normalize</span>(<span class="built_in">mul</span>(TBN,view_dir));</span><br><span class="line">                half2 uv_parallax = i.uv;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;_HeightTime;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    half height = <span class="built_in">tex2D</span>(_Parallax,uv_parallax);</span><br><span class="line">                    uv_parallax = uv_parallax - (<span class="number">0.5</span> - height) * (view_tangentspace.xy/view_tangentspace.z+<span class="number">0.42</span>) *_ParallaxIntensity*<span class="number">0.01f</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                half3 base_color = <span class="built_in">tex2D</span>(_MainTex, uv_parallax).xyz;</span><br><span class="line">                base_color =<span class="built_in">pow</span>(base_color,<span class="number">2.2</span>);</span><br><span class="line">                half3 AO = <span class="built_in">tex2D</span>(_AOMap,uv_parallax).xyz;</span><br><span class="line">                half3 spec_mask = <span class="built_in">tex2D</span>(_SpecMask,uv_parallax).xyz;</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">                half NotL = <span class="built_in">min</span>(shadow,<span class="built_in">max</span>(<span class="built_in">dot</span>(normal_dir,light_dir),<span class="number">0</span>));</span><br><span class="line">                half NotH = <span class="built_in">max</span>(<span class="built_in">dot</span>(normal_dir,half_dir),<span class="number">0</span>);</span><br><span class="line">                half3 diffuse =  NotL*_LightColor0.xyz;</span><br><span class="line">                half3 specular =  <span class="built_in">pow</span>(<span class="built_in">max</span>(NotH,<span class="number">0</span>),_Shininess)* _LightColor0.xyz*_SpecularIntensity*spec_mask*NotL;</span><br><span class="line">               <span class="comment">// half3 ambient =  _AmbientColor.xyz*__AmbientIntensity;</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//col.xyz+= AO;</span></span><br><span class="line"></span><br><span class="line">                col.xyz += diffuse;</span><br><span class="line">                col.xyz += specular;</span><br><span class="line">                col.xyz += UNITY_LIGHTMODEL_AMBIENT.xyz; </span><br><span class="line"></span><br><span class="line">                 <span class="comment">// sample the texture</span></span><br><span class="line">                col.xyz *=base_color;</span><br><span class="line">                col.xyz *=AO;</span><br><span class="line">                half3 tone_color = <span class="built_in">ACESFilm</span>(col.xyz);</span><br><span class="line">                col.xyz=<span class="built_in">pow</span>(tone_color,<span class="number">1.0</span>/<span class="number">2.2</span>);</span><br><span class="line">                <span class="comment">// apply fog</span></span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">       Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardAdd&quot;</span>&#125;</span><br><span class="line">            Blend One One</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdadd</span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AutoLight.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 normal:NORMAL;</span><br><span class="line">                float4 tangent:TANGENT;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">v2f</span></span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 normali_dir:TEXCOORD1;</span><br><span class="line">                float3 tangent_dir:TEXCOORD2;</span><br><span class="line">                float3 binormal_dir:TEXCOORD3;</span><br><span class="line">                float3 pos_world:TEXCOORD4;</span><br><span class="line">                <span class="built_in">LIGHTING_COORDS</span>(<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            sampler2D _AOMap;</span><br><span class="line">            float4 _AOMap_ST;</span><br><span class="line">            float4 _LightColor0;</span><br><span class="line">            <span class="type">float</span> _Shininess;</span><br><span class="line">            <span class="type">float</span> _SpecularIntensity;</span><br><span class="line">            <span class="comment">//float4 _AmbientColor; </span></span><br><span class="line">            sampler2D _SpecMask;</span><br><span class="line">            <span class="type">float</span> _SpecMask_ST; </span><br><span class="line">            sampler2D _NormalMap;</span><br><span class="line">            float4 _NormalMap_ST; </span><br><span class="line">            <span class="type">float</span> _NormalIntensity;</span><br><span class="line">            sampler2D _Parallax;</span><br><span class="line">            <span class="type">float</span> _ParallaxIntensity;</span><br><span class="line">            <span class="type">float</span> _HeightTime;</span><br><span class="line">            <span class="comment">//float __AmbientIntensity;</span></span><br><span class="line"></span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span> <span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = <span class="built_in">UnityObjectToClipPos</span>(v.vertex);</span><br><span class="line">                o.normali_dir = <span class="built_in">normalize</span>(<span class="built_in">mul</span>(<span class="built_in">float4</span>(v.normal,<span class="number">0.0</span>),unity_WorldToObject).xyz);</span><br><span class="line">                o.tangent_dir = <span class="built_in">normalize</span>(<span class="built_in">mul</span>(<span class="built_in">float4</span>(v.tangent.xyz,<span class="number">0.0</span>),unity_WorldToObject).xyz);</span><br><span class="line">                o.binormal_dir = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(o.normali_dir,o.tangent_dir))* v.tangent.w;</span><br><span class="line">                o.pos_world = <span class="built_in">mul</span>(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line">                o.uv = <span class="built_in">TRANSFORM_TEX</span>(v.uv, _MainTex);</span><br><span class="line">                <span class="built_in">TRANSFER_VERTEX_TO_FRAGMENT</span>(o);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span> <span class="params">(v2f i)</span> : SV_Target</span></span><br><span class="line"><span class="function">            &#123;</span></span><br><span class="line">                fixed4 col=<span class="built_in">fixed4</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">                </span><br><span class="line">           </span><br><span class="line">                half atten = <span class="built_in">LIGHT_ATTENUATION</span> (i);</span><br><span class="line">                half4 normalmap = <span class="built_in">tex2D</span>(_NormalMap,i.uv);</span><br><span class="line">                half3 view_dir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.pos_world);</span><br><span class="line">                half3 light_dir_point =<span class="built_in">normalize</span>( _WorldSpaceLightPos0.xyz - i.pos_world);</span><br><span class="line">                half3 light_dir =<span class="built_in">normalize</span>( _WorldSpaceLightPos0.xyz );</span><br><span class="line">                light_dir = <span class="built_in">lerp</span>(light_dir,light_dir_point,_WorldSpaceLightPos0.w);</span><br><span class="line">                half3 half_dir  = <span class="built_in">normalize</span>(view_dir+light_dir);</span><br><span class="line">                <span class="comment">//Normal</span></span><br><span class="line">                half3 normal_dir  =<span class="built_in">normalize</span>(i.normali_dir);</span><br><span class="line">                half3 tangent_dir  =<span class="built_in">normalize</span>(i.tangent_dir)*_NormalIntensity;</span><br><span class="line">                half3 binormal_dir =<span class="built_in">normalize</span>(i.binormal_dir)*_NormalIntensity;</span><br><span class="line">                half3 normal_data = <span class="built_in">UnpackNormal</span>(normalmap);</span><br><span class="line">                float3x3 TBN = <span class="built_in">float3x3</span>(tangent_dir,binormal_dir,normal_dir);</span><br><span class="line">                normal_dir =<span class="built_in">normalize</span>(<span class="built_in">mul</span>(normal_data,TBN));</span><br><span class="line">                <span class="comment">//normal_dir=tangent_dir*normal_data.x*_NormalIntensity+binormal_dir*normal_data.y*_NormalIntensity+normal_dir*normal_data.z ;</span></span><br><span class="line">              </span><br><span class="line">                float3 view_tangentspace = <span class="built_in">normalize</span>(<span class="built_in">mul</span>(TBN,view_dir));</span><br><span class="line">                half2 uv_parallax = i.uv;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;_HeightTime;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    half height = <span class="built_in">tex2D</span>(_Parallax,uv_parallax);</span><br><span class="line">                    uv_parallax = uv_parallax - (<span class="number">0.5</span> - height) * (view_tangentspace.xy/view_tangentspace.z+<span class="number">0.42</span>) *_ParallaxIntensity*<span class="number">0.01f</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                half3 base_color = <span class="built_in">tex2D</span>(_MainTex, uv_parallax).xyz;</span><br><span class="line">                </span><br><span class="line">                half3 AO = <span class="built_in">tex2D</span>(_AOMap,uv_parallax).xyz;</span><br><span class="line">                half3 spec_mask = <span class="built_in">tex2D</span>(_SpecMask,uv_parallax).xyz;</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">                half NotL = <span class="built_in">min</span>(atten,<span class="built_in">max</span>(<span class="built_in">dot</span>(normal_dir,light_dir),<span class="number">0</span>));</span><br><span class="line">                half NotH = <span class="built_in">max</span>(<span class="built_in">dot</span>(normal_dir,half_dir),<span class="number">0</span>);</span><br><span class="line">                half3 diffuse =  NotL*_LightColor0.xyz;</span><br><span class="line">                half3 specular =  <span class="built_in">pow</span>(<span class="built_in">max</span>(NotH,<span class="number">0</span>),_Shininess)* _LightColor0.xyz*_SpecularIntensity*spec_mask*NotL;</span><br><span class="line"></span><br><span class="line">                col.xyz += diffuse;</span><br><span class="line">                col.xyz += specular;</span><br><span class="line">               </span><br><span class="line"></span><br><span class="line">                 <span class="comment">// sample the texture</span></span><br><span class="line">                col.xyz *=base_color;</span><br><span class="line">                col.xyz *=AO;</span><br><span class="line">             </span><br><span class="line">                <span class="comment">// apply fog</span></span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>薄膜干涉效果</title>
    <url>/2022/01/22/%E8%96%84%E8%86%9C%E5%B9%B2%E6%B6%89%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<blockquote>
<h1 id="薄膜干涉"><a href="#薄膜干涉" class="headerlink" title="薄膜干涉"></a>薄膜干涉</h1></blockquote>
<h2 id="材质捕捉效果（Material-Capture）"><a href="#材质捕捉效果（Material-Capture）" class="headerlink" title="材质捕捉效果（Material Capture）"></a>材质捕捉效果（Material Capture）</h2><p><strong>预览效果</strong></p>
<p><img src="https://img-blog.csdnimg.cn/56c243af89ed49898a5ee5130e2a0507.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_16,color_FFFFFF,t_70,g_se,x_16" alt="预览效果"></p>
<p><strong>ASE图</strong></p>
<p><img src="https://img-blog.csdnimg.cn/d923225abd084649b13c00901cb87279.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>将观察坐标系的顶点法线xy当作材质的uv，将材质图片根据坐标平埔视角坐标系下的模型上，缺点当模型处于视野边缘时会有破绽。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>Properties</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_MainTex (<span class="string">&quot;diffuse&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">  _MatCatAddTex (<span class="string">&quot;MatCatAdd&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">  _MatCatAddIntensity (<span class="string">&quot;MatCatAddIntensity&quot;</span>, Float) = <span class="number">0.35</span></span><br><span class="line"></span><br><span class="line">  _MatCatTex (<span class="string">&quot;MatCat&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">  _MatCatIntensity (<span class="string">&quot;MatCatIntensity&quot;</span>, Float) = <span class="number">5.0</span></span><br></pre></td></tr></table></figure>

<p>Pass</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sampler2D _MatCatAddTex;</span><br><span class="line">float4 _MatCatAddTex_ST;</span><br><span class="line"><span class="type">float</span> _MatCatAddIntensity;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sampler2D _MatCatTex;</span><br><span class="line">float4 _MatCatTex_ST;</span><br><span class="line"><span class="type">float</span> _MatCatIntensity;</span><br></pre></td></tr></table></figure>

<p>vert</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">o.normal_world = mul(float4(v.normal,<span class="number">0.0</span>) ,unity_WorldToObject);<span class="comment">//获取worldnormal</span></span><br></pre></td></tr></table></figure>

<p>frag</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fixed4 col_diffuse = tex2D(_MainTex, i.uv);</span><br><span class="line">half2 MatCat_uv = (mul(UNITY_MATRIX_V, half4(normal_world, <span class="number">0.0</span>)).xy + <span class="number">1.0f</span>) * <span class="number">0.5f</span>;</span><br><span class="line">fixed4 col_MatCatAdd = tex2D(_MatCatAddTex, MatCat_uv) * _MatCatAddIntensity;</span><br><span class="line">fixed4 col_MatCat = tex2D(_MatCatTex, MatCat_uv) * _MatCatIntensity;</span><br></pre></td></tr></table></figure>

<h2 id="Ramp填充里面的颜色"><a href="#Ramp填充里面的颜色" class="headerlink" title="Ramp填充里面的颜色"></a>Ramp填充里面的颜色</h2><p><strong>预览效果</strong></p>
<p><img src="https://img-blog.csdnimg.cn/4de55293ebc148d28909c8690ad9a1a9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><strong>过度颜色图</strong></p>
<p><img src="https://img-blog.csdnimg.cn/1e311d3cf2474411a1c39505009b610d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p><strong>ASE图</strong></p>
<p><img src="https://img-blog.csdnimg.cn/7d0955cba77744b8be275fa6c1b9f080.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>利用菲涅尔方程的经验，1.0f - saturate(dot(normal_world, view_dir))在x和y上得到的是单调连续数值</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>Properties</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_RampTex(<span class="string">&quot;Ramp&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>vart</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">float3 pos_world = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">o.view_world = normalize( _WorldSpaceCameraPos - pos_world );</span><br></pre></td></tr></table></figure>



<p>frag</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">half3 view_dir = normalize(i.view_world);</span><br><span class="line">half fresnel = <span class="number">1.0f</span> - saturate(dot(normal_world, view_dir));</span><br><span class="line">fixed4 col_Ramp = tex2D(_RampTex, half2(fresnel, <span class="number">0.5f</span>));</span><br></pre></td></tr></table></figure>



<h2 id="合并效果"><a href="#合并效果" class="headerlink" title="合并效果"></a>合并效果</h2><h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p><img src="https://img-blog.csdnimg.cn/6683c0fd1e1d4027be543f06e8e47de8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/89d2e4d09575407c9e6ea4d33677e259.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="ASE图"><a href="#ASE图" class="headerlink" title="ASE图"></a>ASE图</h3><p><img src="https://img-blog.csdnimg.cn/dc3628555216403f82d24ccc9a88feb6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unlit/MatCat1_Code&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;diffuse&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _MatCatAddTex (<span class="string">&quot;MatCatAdd&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _MatCatAddIntensity (<span class="string">&quot;MatCatAddIntensity&quot;</span>, Float) = <span class="number">0.35</span></span><br><span class="line"></span><br><span class="line">        _MatCatTex (<span class="string">&quot;MatCat&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _MatCatIntensity (<span class="string">&quot;MatCatIntensity&quot;</span>, Float) = <span class="number">5.0</span></span><br><span class="line">        _RampTex(<span class="string">&quot;Ramp&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 normal_world : TEXCOORD1;</span><br><span class="line">                float3 view_world : TEXCOORD2;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">            sampler2D _MatCatAddTex;</span><br><span class="line">            float4 _MatCatAddTex_ST;</span><br><span class="line">            <span class="type">float</span> _MatCatAddIntensity;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            sampler2D _MatCatTex;</span><br><span class="line">            float4 _MatCatTex_ST;</span><br><span class="line">            <span class="type">float</span> _MatCatIntensity;</span><br><span class="line">            </span><br><span class="line">            sampler2D _RampTex;</span><br><span class="line">            float4 _RampTex_ST;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            v2f <span class="title function_">vert</span> <span class="params">(appdata v)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">                o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">                o.normal_world = mul(float4(v.normal,<span class="number">0.0</span>) ,unity_WorldToObject);</span><br><span class="line">                float3 pos_world = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">                o.view_world = normalize( _WorldSpaceCameraPos - pos_world );</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                half3 normal_world = normalize(i.normal_world);</span><br><span class="line">                fixed4 col;</span><br><span class="line">                <span class="comment">// MatCap</span></span><br><span class="line">                fixed4 col_diffuse = tex2D(_MainTex, i.uv);</span><br><span class="line">                half2 MatCat_uv = (mul(UNITY_MATRIX_V, half4(normal_world, <span class="number">0.0</span>)).xy + <span class="number">1.0f</span>) * <span class="number">0.5f</span>;</span><br><span class="line">                fixed4 col_MatCatAdd = tex2D(_MatCatAddTex, MatCat_uv) * _MatCatAddIntensity;</span><br><span class="line">                fixed4 col_MatCat = tex2D(_MatCatTex, MatCat_uv) * _MatCatIntensity;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">//Ramp</span></span><br><span class="line">                half3 view_dir = normalize(i.view_world);</span><br><span class="line">                half fresnel = <span class="number">1.0f</span> - saturate(dot(normal_world, view_dir));</span><br><span class="line">                fixed4 col_Ramp = tex2D(_RampTex, half2(fresnel, <span class="number">0.5f</span>));</span><br><span class="line"></span><br><span class="line">                col = col_diffuse * col_MatCat * col_Ramp;</span><br><span class="line">                col += col_MatCatAdd ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">               <span class="comment">// return fixed4(i.normal_world,0.0);</span></span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>藤曼生长</title>
    <url>/2022/02/10/%E8%97%A4%E6%9B%BC%E7%94%9F%E9%95%BF/</url>
    <content><![CDATA[<h1 id="藤曼生长"><a href="#藤曼生长" class="headerlink" title="藤曼生长"></a>藤曼生长</h1><p><strong>预览视图</strong></p>
<p><img src="https://img-blog.csdnimg.cn/239148c16c944873b02c02d3147cd67d.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/4606bf1634494bfb9d0af5015ae90502.png" alt="在这里插入图片描述"></p>
<p><strong>PBR材质下的效果</strong></p>
<p>显示更好看上ASE</p>
<p><img src="https://img-blog.csdnimg.cn/ba9a3e2dbcfc4bfdbb6771696810b7e0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/d1ea5f1eab5a4091b0baf36a3495df95.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/34ccd229561748c192f020f3b60c88c8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="简化版"><a href="#简化版" class="headerlink" title="简化版"></a>简化版</h2><p>可以乘以顶点法线向量可以实现物体的缩放，用一个UV图的权重控制不同位置缩放部分，可以形成藤曼的样子</p>
<h3 id="ASE"><a href="#ASE" class="headerlink" title="ASE"></a>ASE</h3><p><img src="https://img-blog.csdnimg.cn/cd32f8d0755c44bcb1671ecc6d91b26b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">_Grow(<span class="string">&quot;Grow&quot;</span>,Range(<span class="number">-1.0</span>,<span class="number">1.0</span>)) = <span class="number">0.0</span></span><br><span class="line">_Expend(<span class="string">&quot;Expend&quot;</span>,Float) = <span class="number">0.0</span></span><br><span class="line">_Scale(<span class="string">&quot;Scale&quot;</span>,Float) = <span class="number">0.0</span></span><br><span class="line">_GrowMin(<span class="string">&quot;GrowMin&quot;</span>, Range(<span class="number">0</span>,<span class="number">1.0</span>)) = <span class="number">0.6</span></span><br><span class="line">_GrowMax(<span class="string">&quot;GrowMax&quot;</span>, Range(<span class="number">0</span>,<span class="number">1.5</span>)) = <span class="number">1.0</span></span><br><span class="line">_EndMin(<span class="string">&quot;EndMin&quot;</span>, Range(<span class="number">0</span>,<span class="number">1.0</span>)) = <span class="number">0.6</span></span><br><span class="line">_EndMax(<span class="string">&quot;EndMax&quot;</span>, Range(<span class="number">0</span>,<span class="number">1.5</span>)) = <span class="number">1.0</span> </span><br></pre></td></tr></table></figure>

<h4 id="appdata"><a href="#appdata" class="headerlink" title="appdata"></a>appdata</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">appdata</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 normal:NORMAL;</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="vert"><a href="#vert" class="headerlink" title="vert"></a>vert</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v2f <span class="title function_">vert</span> <span class="params">(appdata v)</span></span><br><span class="line">&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    half weight = max(smoothstep( _GrowMin, _GrowMax, v.uv.y - _Grow), smoothstep(_EndMin, _EndMax,v.uv.y ));</span><br><span class="line">    half3 weight_combine = weight * _Expend * <span class="number">0.01f</span>*v.normal;</span><br><span class="line">    half3 scale_combine = _Scale * <span class="number">0.01f</span> * v.normal;</span><br><span class="line">    half3 normal_combine = weight_combine + scale_combine;</span><br><span class="line">    v.vertex.xyz = v.vertex.xyz+ normal_combine;</span><br><span class="line">    o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="frag"><a href="#frag" class="headerlink" title="frag"></a>frag</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    clip(<span class="number">1</span> - (i.uv.y - _Grow));</span><br><span class="line">    <span class="comment">// sample the texture</span></span><br><span class="line">    fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unlit/Vice1_Code&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Grow(<span class="string">&quot;Grow&quot;</span>,Range(<span class="number">-1.0</span>,<span class="number">1.0</span>)) = <span class="number">0.0</span></span><br><span class="line">        _Expend(<span class="string">&quot;Expend&quot;</span>,Float) = <span class="number">0.0</span></span><br><span class="line">        _Scale(<span class="string">&quot;Scale&quot;</span>,Float) = <span class="number">0.0</span></span><br><span class="line">        _GrowMin(<span class="string">&quot;GrowMin&quot;</span>, Range(<span class="number">0</span>,<span class="number">1.0</span>)) = <span class="number">0.6</span></span><br><span class="line">        _GrowMax(<span class="string">&quot;GrowMax&quot;</span>, Range(<span class="number">0</span>,<span class="number">1.5</span>)) = <span class="number">1.0</span></span><br><span class="line">        _EndMin(<span class="string">&quot;EndMin&quot;</span>, Range(<span class="number">0</span>,<span class="number">1.0</span>)) = <span class="number">0.6</span></span><br><span class="line">        _EndMax(<span class="string">&quot;EndMax&quot;</span>, Range(<span class="number">0</span>,<span class="number">1.5</span>)) = <span class="number">1.0</span> </span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            <span class="comment">// make fog work</span></span><br><span class="line">           </span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 normal:NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float2 uv : TEXCOORD0; </span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">float</span> _Grow;</span><br><span class="line">            <span class="type">float</span> _Expend;</span><br><span class="line">            <span class="type">float</span> _GrowMin;</span><br><span class="line">            <span class="type">float</span> _GrowMax;</span><br><span class="line">            <span class="type">float</span> _EndMin;</span><br><span class="line">            <span class="type">float</span> _EndMax;</span><br><span class="line">            <span class="type">float</span> _Scale;</span><br><span class="line">            v2f <span class="title function_">vert</span> <span class="params">(appdata v)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                half weight = max(smoothstep( _GrowMin, _GrowMax, v.uv.y - _Grow), smoothstep(_EndMin, _EndMax,v.uv.y ));</span><br><span class="line">                half3 weight_combine = weight * _Expend * <span class="number">0.01f</span>*v.normal;</span><br><span class="line">                half3 scale_combine = _Scale * <span class="number">0.01f</span> * v.normal;</span><br><span class="line">                half3 normal_combine = weight_combine + scale_combine;</span><br><span class="line">                v.vertex.xyz = v.vertex.xyz+ normal_combine;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                clip(<span class="number">1</span> - (i.uv.y - _Grow));</span><br><span class="line">                <span class="comment">// sample the texture</span></span><br><span class="line">                fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最近有一点偷懒，更新有点慢，新年快乐，新的一年，冲冲冲；</p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>透光效果模拟</title>
    <url>/2022/04/03/%E9%80%8F%E5%85%89%E6%95%88%E6%9E%9C%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<h1 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">float3 diffuse_color = _DiffuseColor;</span><br><span class="line">float3 normalDir = <span class="built_in">normalize</span>(i.normalDir);</span><br><span class="line">float3 viewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos - i.posWorld.xyz);</span><br><span class="line">float3 lightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br></pre></td></tr></table></figure>

<h1 id="漫反射"><a href="#漫反射" class="headerlink" title="漫反射"></a>漫反射</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> diff_term = <span class="built_in">max</span>(<span class="number">0.0</span>, <span class="built_in">dot</span>(normalDir, lightDir));</span><br><span class="line">float3 diffuselight_color = diff_term * diffuse_color * _LightColor0.rgb;</span><br><span class="line"><span class="type">float</span> sky_sphere = (<span class="built_in">dot</span>(normalDir,<span class="built_in">float3</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>)) + <span class="number">1.0</span>) * <span class="number">0.5</span>;</span><br><span class="line">float3 sky_light = sky_sphere * diffuse_color;</span><br><span class="line">float3 final_diffuse = diffuselight_color + sky_light * _Opacity + _AddColor.xyz;</span><br></pre></td></tr></table></figure>

<h1 id="穿透光"><a href="#穿透光" class="headerlink" title="穿透光"></a>穿透光</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">float3 back_dir = -<span class="built_in">normalize</span>(lightDir + normalDir * _BasePassDistortion);</span><br><span class="line"><span class="type">float</span> VdotB = <span class="built_in">max</span>(<span class="number">0.0</span>, <span class="built_in">dot</span>(viewDir, back_dir));</span><br><span class="line"><span class="type">float</span> backlight_term = <span class="built_in">max</span>(<span class="number">0.0</span>,<span class="built_in">pow</span>(VdotB, _BasePassPower)) * _BasePassScale;</span><br><span class="line"><span class="type">float</span> thickness = <span class="number">1.0</span> - <span class="built_in">tex2D</span>(_ThicknessMap, i.uv).r;</span><br><span class="line">float3 backlight = backlight_term * thickness *_LightColor0.xyz * _BasePassColor.xyz;</span><br></pre></td></tr></table></figure>

<h1 id="环境光"><a href="#环境光" class="headerlink" title="环境光"></a>环境光</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">float3 reflectDir = <span class="built_in">reflect</span>(-viewDir,normalDir);</span><br><span class="line"></span><br><span class="line">half theta = _EnvRotate * UNITY_PI / <span class="number">180.0f</span>;</span><br><span class="line">float2x2 m_rot = <span class="built_in">float2x2</span>(<span class="built_in">cos</span>(theta), -<span class="built_in">sin</span>(theta), <span class="built_in">sin</span>(theta),<span class="built_in">cos</span>(theta));</span><br><span class="line">float2 v_rot = <span class="built_in">mul</span>(m_rot, reflectDir.xz);</span><br><span class="line">reflectDir = <span class="built_in">half3</span>(v_rot.x, reflectDir.y, v_rot.y);</span><br><span class="line"></span><br><span class="line">float4 cubemap_color = <span class="built_in">texCUBE</span>(_EnvMap,reflectDir);</span><br><span class="line">half3 env_color = <span class="built_in">DecodeHDR</span>(cubemap_color, _EnvMap_HDR);</span><br><span class="line"></span><br><span class="line"><span class="comment">//菲尼尔效应</span></span><br><span class="line"><span class="type">float</span> fresnel = <span class="number">1.0</span> - <span class="built_in">saturate</span>(<span class="built_in">dot</span>(normalDir, viewDir));</span><br><span class="line">fresnel = <span class="built_in">smoothstep</span>(_FresnelMin, _FresnelMax, fresnel);</span><br><span class="line"></span><br><span class="line">float3 final_env = env_color * _EnvIntensity * fresnel;</span><br></pre></td></tr></table></figure>

<h1 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">float3 combined_color = final_diffuse + final_env + backlight;</span><br><span class="line">float3 final_color = combined_color;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">float4</span>(final_color,<span class="number">1.0</span>);</span><br></pre></td></tr></table></figure>

<h1 id="前向渲染叠加"><a href="#前向渲染叠加" class="headerlink" title="前向渲染叠加"></a>前向渲染叠加</h1><p>只需要将穿透光部分加过来就行。不需要加环境光之类的</p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>魔镜世界</title>
    <url>/2022/02/13/%E9%AD%94%E9%95%9C%E4%B8%96%E7%95%8C/</url>
    <content><![CDATA[<h1 id="魔镜世界"><a href="#魔镜世界" class="headerlink" title="魔镜世界"></a>魔镜世界</h1><p><img src="https://img-blog.csdnimg.cn/708f8e4dc58e4eebb462a598386feb4b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/60384ee277de4032bb962961f62b6cce.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="渲染队列和颜色遮罩"><a href="#渲染队列和颜色遮罩" class="headerlink" title="渲染队列和颜色遮罩"></a>渲染队列和颜色遮罩</h2><h3 id="Rendering-Queue"><a href="#Rendering-Queue" class="headerlink" title="Rendering Queue"></a>Rendering Queue</h3><p>从小到大进行排序</p>
<p>几何体 2000</p>
<p>Alpha Test 2450</p>
<p>Transparent 3000</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;AlphaTest+10&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="Color-Mask"><a href="#Color-Mask" class="headerlink" title="Color Mask"></a>Color Mask</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ColorMask <span class="number">0</span></span><br><span class="line">ColorMask 相应的颜色通道</span><br></pre></td></tr></table></figure>



<h2 id="模板测试（Stencil）"><a href="#模板测试（Stencil）" class="headerlink" title="模板测试（Stencil）"></a>模板测试（Stencil）</h2><p>Reference 参数便于判端和筛选</p>
<p>Comparison 判断方式‘</p>
<p>Pass 面 通过之后的进行操作，图中是替换的意思</p>
<p>Fail 失败之后的操作</p>
<p>ZFail 深度测试失败的操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Stencil</span><br><span class="line">&#123;</span><br><span class="line">  Ref <span class="number">1</span></span><br><span class="line">  Comp always</span><br><span class="line">  Pass Replace</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="深度测试（Depth）"><a href="#深度测试（Depth）" class="headerlink" title="深度测试（Depth）"></a>深度测试（Depth）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ZWrite Off<span class="comment">//深度测试的开关</span></span><br><span class="line">ZTest Less<span class="comment">//深度小于当前缓存则通过</span></span><br><span class="line">ZTest Greater<span class="comment">//深度大于当前缓存则通过</span></span><br><span class="line">ZTest LEqual<span class="comment">//深度小于等于当前缓存则通过</span></span><br><span class="line">ZTest GEqual<span class="comment">//深度大于等于当前缓存则通过</span></span><br><span class="line">ZTest Equal<span class="comment">//深度等于当前缓存则通过</span></span><br><span class="line">ZTest NotEqual<span class="comment">//深度不等于当前缓存则通过</span></span><br><span class="line">ZTest Always<span class="comment">//不论如何都通过</span></span><br></pre></td></tr></table></figure>

<h2 id="制作过程"><a href="#制作过程" class="headerlink" title="制作过程"></a>制作过程</h2><h3 id="将材质导入dome"><a href="#将材质导入dome" class="headerlink" title="将材质导入dome"></a>将材质导入dome</h3><p>课程材料略</p>
<h3 id="制作镜子Shader"><a href="#制作镜子Shader" class="headerlink" title="制作镜子Shader"></a>制作镜子Shader</h3><h4 id="ASE图"><a href="#ASE图" class="headerlink" title="ASE图"></a>ASE图</h4><p><img src="https://img-blog.csdnimg.cn/24690538c7d74427947ec214b96eb3e9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/930c5704723d4d62824f52fb74543c7a.png" alt="在这里插入图片描述"></p>
<h4 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Tags &#123; <span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;AlphaTest+10&quot;</span>  &#125;</span><br><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">    ColorMask <span class="number">0</span></span><br><span class="line">    Stencil&#123;</span><br><span class="line">    Ref <span class="number">1</span></span><br><span class="line">    Comp always</span><br><span class="line">    Pass Replace</span><br><span class="line">    &#125;</span><br><span class="line">    ZWrite Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="制作镜内世界"><a href="#制作镜内世界" class="headerlink" title="制作镜内世界"></a>制作镜内世界</h3><h4 id="ASE图-1"><a href="#ASE图-1" class="headerlink" title="ASE图"></a>ASE图</h4><p><img src="https://img-blog.csdnimg.cn/846f665faf02464f9294ff2fc1919ac4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_10,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="核心代码-1"><a href="#核心代码-1" class="headerlink" title="核心代码"></a>核心代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Tags &#123; <span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;AlphaTest+20&quot;</span> &#125;</span><br><span class="line">Stencil&#123;</span><br><span class="line">  Ref <span class="number">1</span></span><br><span class="line">  Comp equal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="制作深度测试球"><a href="#制作深度测试球" class="headerlink" title="制作深度测试球"></a>制作深度测试球</h3><p>这一步是为了当模板测试未通过物体出现在魔镜后会出现在魔镜中的情况</p>
<p><img src="https://img-blog.csdnimg.cn/dfa1f68f67744d619a251839ec766106.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_13,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="ASE图-2"><a href="#ASE图-2" class="headerlink" title="ASE图"></a>ASE图</h4><p><img src="https://img-blog.csdnimg.cn/61e98110db744bd2afe357319cde1f6a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/1e5541da483f41b592e50bd9957dc801.png" alt="在这里插入图片描述"></p>
<h4 id="核心代码-2"><a href="#核心代码-2" class="headerlink" title="核心代码"></a>核心代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Tags &#123; <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;AlphaTest+15&quot;</span> &#125;</span><br><span class="line">   LOD <span class="number">100</span></span><br><span class="line">   Stencil&#123;</span><br><span class="line">       Ref <span class="number">1</span></span><br><span class="line">       Comp equal</span><br><span class="line">   &#125;</span><br><span class="line">   ZTest always</span><br></pre></td></tr></table></figure>

<h2 id="完成效果"><a href="#完成效果" class="headerlink" title="完成效果"></a>完成效果</h2><p><img src="https://img-blog.csdnimg.cn/ae35f733fb66487d8d5cbf13168e3b6f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>后处理技术（中）</title>
    <url>/2022/02/22/%E5%90%8E%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF2/</url>
    <content><![CDATA[<h1 id="模糊处理"><a href="#模糊处理" class="headerlink" title="模糊处理"></a>模糊处理</h1><p>本文章参考<a href="https://zhuanlan.zhihu.com/p/125744132">毛星云大佬的文章</a>学习，十分推荐看大佬的原文<img src="https://pic3.zhimg.com/80/v2-c2a9906331826e66f66ffda71192411a_720w.jpg"></p>
<p><strong>降采样是常见的优化性能的方法减少中间贴图的尺寸大小</strong></p>
<p><strong>产生的中间贴图一定要记得释放内存，否则造成内存泄漏</strong></p>
<p><strong>在for循环的中间贴图也要记得释放内存</strong></p>
<h1 id="课程的4种常用的模糊算法"><a href="#课程的4种常用的模糊算法" class="headerlink" title="课程的4种常用的模糊算法"></a>课程的4种常用的模糊算法</h1><h2 id="盒状模糊或均值模糊（Box-Blur）"><a href="#盒状模糊或均值模糊（Box-Blur）" class="headerlink" title="盒状模糊或均值模糊（Box Blur）"></a>盒状模糊或均值模糊（Box Blur）</h2><p>最简单的模糊方式，取一个2*2的卷积核，四个数权重都为0.25，取一个像素的四角的像素叠加乘0.25</p>
<p><img src="https://img-blog.csdnimg.cn/b3aa70f8bcb943be9a634b4a5b87acf4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>（-1，-1）（1，-1）（-1，1）（1，1）四个点位叠加除4；</p>
<p>当然卷积核的值可自己调</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="BoxBlur-cs"><a href="#BoxBlur-cs" class="headerlink" title="BoxBlur.cs"></a>BoxBlur.cs</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ExecuteInEditMode()</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BoxBlur</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Material material;</span><br><span class="line">    [<span class="meta">Range(0, 10)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> _Iteration = <span class="number">4</span>;</span><br><span class="line">    [<span class="meta">Range(0, 15)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> _BlurRadius = <span class="number">5.0f</span>;</span><br><span class="line">    [<span class="meta">Range(1, 10)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> _DownSample = <span class="number">2.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span> ()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material == <span class="literal">null</span> || SystemInfo.supportsImageEffects == <span class="literal">false</span></span><br><span class="line">            || material.shader == <span class="literal">null</span> || material.shader.isSupported == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            enabled = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture source, RenderTexture destination</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> width = (<span class="built_in">int</span>)(source.width / _DownSample);</span><br><span class="line">        <span class="built_in">int</span> height = (<span class="built_in">int</span>)(source.height / _DownSample);</span><br><span class="line">        RenderTexture RT1 = RenderTexture.GetTemporary(width,height);</span><br><span class="line">        RenderTexture RT2 = RenderTexture.GetTemporary(width, height);</span><br><span class="line"></span><br><span class="line">        Graphics.Blit(source, RT1);</span><br><span class="line"></span><br><span class="line">        material.SetVector(<span class="string">&quot;_BlurOffset&quot;</span>, <span class="keyword">new</span> Vector4(_BlurRadius / source.width, _BlurRadius / source.height, <span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; _Iteration; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Graphics.Blit(RT1, RT2, material, <span class="number">0</span>);</span><br><span class="line">            Graphics.Blit(RT2, RT1, material, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Graphics.Blit(RT1, destination);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//release</span></span><br><span class="line">        RenderTexture.ReleaseTemporary(RT1);</span><br><span class="line">        RenderTexture.ReleaseTemporary(RT2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="BoxBlur-shader"><a href="#BoxBlur-shader" class="headerlink" title="BoxBlur.shader"></a>BoxBlur.shader</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Hidden/BoxBlur&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">  CGINCLUDE</span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">  sampler2D _MainTex;</span><br><span class="line">  float4 _BlurOffset;</span><br><span class="line"></span><br><span class="line">  half4 <span class="title function_">frag_BoxFilter_4Tap</span><span class="params">(v2f_img i)</span> : SV_Target</span><br><span class="line">  &#123;</span><br><span class="line">    half4 d = _BlurOffset.xyxy * half4(<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    half4 s = <span class="number">0</span>;</span><br><span class="line">    s += tex2D(_MainTex, i.uv + d.xy);</span><br><span class="line">    s += tex2D(_MainTex, i.uv + d.zy);</span><br><span class="line">    s += tex2D(_MainTex, i.uv + d.xw);</span><br><span class="line">    s += tex2D(_MainTex, i.uv + d.zw);</span><br><span class="line">    s *= <span class="number">0.25</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  half4 <span class="title function_">frag_BoxFilter_9Tap</span><span class="params">(v2f_img i)</span> : SV_Target</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//half4 d = _BlurOffset.xyxy * half4(-1,1,0,0);</span></span><br><span class="line">    half4 d = _BlurOffset.xyxy * half4(<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    half4 s = <span class="number">0</span>;</span><br><span class="line">    s = tex2D(_MainTex, i.uv);</span><br><span class="line"></span><br><span class="line">    s += tex2D(_MainTex, i.uv + d.xy);</span><br><span class="line">    s += tex2D(_MainTex, i.uv + d.zy);</span><br><span class="line">    s += tex2D(_MainTex, i.uv + d.xw);</span><br><span class="line">    s += tex2D(_MainTex, i.uv + d.zw);</span><br><span class="line"></span><br><span class="line">    s += tex2D(_MainTex, i.uv + half2(<span class="number">0.0</span>, d.w)); <span class="comment">// 0 1</span></span><br><span class="line">    s += tex2D(_MainTex, i.uv + half2(<span class="number">0.0</span>, d.y)); <span class="comment">// 0 -1</span></span><br><span class="line">    s += tex2D(_MainTex, i.uv + half2(d.z,<span class="number">0.0</span>)); <span class="comment">// 1 0</span></span><br><span class="line">    s += tex2D(_MainTex, i.uv + half2(d.x, <span class="number">0.0</span>)); <span class="comment">// -1 0</span></span><br><span class="line"></span><br><span class="line">    s = s/ <span class="number">9.0</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ENDCG</span><br><span class="line"></span><br><span class="line">  Properties</span><br><span class="line">  &#123;</span><br><span class="line">    _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    _BlurOffset(<span class="string">&quot;BlurOffset&quot;</span>,Float) = <span class="number">1</span> </span><br><span class="line">  &#125;</span><br><span class="line">  SubShader</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// No culling or depth</span></span><br><span class="line">    Cull Off ZWrite Off ZTest Always</span><br><span class="line">    <span class="comment">//0pass 4tap</span></span><br><span class="line">    Pass</span><br><span class="line">    &#123;</span><br><span class="line">      CGPROGRAM</span><br><span class="line">      <span class="meta">#<span class="keyword">pragma</span> vertex vert_img</span></span><br><span class="line">      <span class="meta">#<span class="keyword">pragma</span> fragment frag_BoxFilter_4Tap</span></span><br><span class="line">      ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1pass 9tap</span></span><br><span class="line">    Pass</span><br><span class="line">    &#123;</span><br><span class="line">      CGPROGRAM</span><br><span class="line">      <span class="meta">#<span class="keyword">pragma</span> vertex vert_img</span></span><br><span class="line">      <span class="meta">#<span class="keyword">pragma</span> fragment frag_BoxFilter_9Tap</span></span><br><span class="line">      ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="高斯模糊（Gaussian-Blur）"><a href="#高斯模糊（Gaussian-Blur）" class="headerlink" title="高斯模糊（Gaussian Blur）"></a>高斯模糊（Gaussian Blur）</h2><p>特定的权重，离像素点越远权重越小</p>
<p>下图为高斯函数的3维图示：</p>
<p><img src="https://pic4.zhimg.com/80/v2-d6af23aafa14caec06b3a1790b6d92e3_720w.jpg"></p>
<p>0.05 0.25 0.40 0.25 0.05权值</p>
<p>和盒状模糊差不多，效果会好一点</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><h4 id="GaussianBlur-cs"><a href="#GaussianBlur-cs" class="headerlink" title="GaussianBlur.cs"></a>GaussianBlur.cs</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ExecuteInEditMode()</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GaussianBlur</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Material material;</span><br><span class="line">    [<span class="meta">Range(0, 10)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> _Iteration = <span class="number">4</span>;</span><br><span class="line">    [<span class="meta">Range(0, 15)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> _BlurRadius = <span class="number">5.0f</span>;</span><br><span class="line">    [<span class="meta">Range(1, 10)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> _DownSample = <span class="number">2.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span> ()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material == <span class="literal">null</span> || SystemInfo.supportsImageEffects == <span class="literal">false</span></span><br><span class="line">            || material.shader == <span class="literal">null</span> || material.shader.isSupported == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            enabled = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture source, RenderTexture destination</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> width = (<span class="built_in">int</span>)(source.width / _DownSample);</span><br><span class="line">        <span class="built_in">int</span> height = (<span class="built_in">int</span>)(source.height / _DownSample);</span><br><span class="line">        RenderTexture RT1 = RenderTexture.GetTemporary(width,height);</span><br><span class="line">        RenderTexture RT2 = RenderTexture.GetTemporary(width, height);</span><br><span class="line"></span><br><span class="line">        Graphics.Blit(source, RT1);</span><br><span class="line"></span><br><span class="line">        material.SetVector(<span class="string">&quot;_BlurOffset&quot;</span>, <span class="keyword">new</span> Vector4(_BlurRadius / source.width, _BlurRadius / source.height, <span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; _Iteration; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Graphics.Blit(RT1, RT2, material, <span class="number">0</span>); <span class="comment">//水平方向</span></span><br><span class="line">            Graphics.Blit(RT2, RT1, material, <span class="number">1</span>); <span class="comment">//垂直方向</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Graphics.Blit(RT1, destination);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//release</span></span><br><span class="line">        RenderTexture.ReleaseTemporary(RT1);</span><br><span class="line">        RenderTexture.ReleaseTemporary(RT2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="GaussianBlur-shader"><a href="#GaussianBlur-shader" class="headerlink" title="GaussianBlur.shader"></a>GaussianBlur.shader</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Hidden/GaussianBlur&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">  CGINCLUDE</span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">  sampler2D _MainTex;</span><br><span class="line">  float4 _BlurOffset;</span><br><span class="line"></span><br><span class="line">  half4 <span class="title function_">frag_HorizontalBlur</span><span class="params">(v2f_img i)</span> : SV_Target</span><br><span class="line">  &#123;</span><br><span class="line">    half2 uv1 = i.uv + _BlurOffset.xy * half2(<span class="number">1</span>, <span class="number">0</span>) * <span class="number">-2.0</span>;</span><br><span class="line">    half2 uv2 = i.uv + _BlurOffset.xy * half2(<span class="number">1</span>, <span class="number">0</span>) * <span class="number">-1.0</span>;</span><br><span class="line">    half2 uv3 = i.uv;</span><br><span class="line">    half2 uv4 = i.uv + _BlurOffset.xy * half2(<span class="number">1</span>, <span class="number">0</span>) * <span class="number">1.0</span>;</span><br><span class="line">    half2 uv5 = i.uv + _BlurOffset.xy * half2(<span class="number">1</span>, <span class="number">0</span>) * <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line">    half4 s = <span class="number">0</span>;</span><br><span class="line">    s += tex2D(_MainTex, uv1) * <span class="number">0.05</span>;</span><br><span class="line">    s += tex2D(_MainTex, uv2) * <span class="number">0.25</span>;</span><br><span class="line">    s += tex2D(_MainTex, uv3) * <span class="number">0.40</span>;</span><br><span class="line">    s += tex2D(_MainTex, uv4) * <span class="number">0.25</span>;</span><br><span class="line">    s += tex2D(_MainTex, uv5) * <span class="number">0.05</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  half4 <span class="title function_">frag_VerticalBlur</span><span class="params">(v2f_img i)</span> : SV_Target</span><br><span class="line">  &#123;</span><br><span class="line">    half2 uv1 = i.uv + _BlurOffset.xy * half2(<span class="number">0</span>, <span class="number">1</span>) * <span class="number">-2.0</span>;</span><br><span class="line">    half2 uv2 = i.uv + _BlurOffset.xy * half2(<span class="number">0</span>, <span class="number">1</span>) * <span class="number">-1.0</span>;</span><br><span class="line">    half2 uv3 = i.uv;</span><br><span class="line">    half2 uv4 = i.uv + _BlurOffset.xy * half2(<span class="number">0</span>, <span class="number">1</span>) * <span class="number">1.0</span>;</span><br><span class="line">    half2 uv5 = i.uv + _BlurOffset.xy * half2(<span class="number">0</span>, <span class="number">1</span>) * <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line">    half4 s = <span class="number">0</span>;</span><br><span class="line">    s += tex2D(_MainTex, uv1) * <span class="number">0.05</span>;</span><br><span class="line">    s += tex2D(_MainTex, uv2) * <span class="number">0.25</span>;</span><br><span class="line">    s += tex2D(_MainTex, uv3) * <span class="number">0.40</span>;</span><br><span class="line">    s += tex2D(_MainTex, uv4) * <span class="number">0.25</span>;</span><br><span class="line">    s += tex2D(_MainTex, uv5) * <span class="number">0.05</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ENDCG</span><br><span class="line"></span><br><span class="line">  Properties</span><br><span class="line">  &#123;</span><br><span class="line">    _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    _BlurOffset(<span class="string">&quot;BlurOffset&quot;</span>,Float) = <span class="number">1</span> </span><br><span class="line">  &#125;</span><br><span class="line">  SubShader</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// No culling or depth</span></span><br><span class="line">    Cull Off ZWrite Off ZTest Always</span><br><span class="line">    <span class="comment">//0</span></span><br><span class="line">    Pass</span><br><span class="line">    &#123;</span><br><span class="line">      CGPROGRAM</span><br><span class="line">      <span class="meta">#<span class="keyword">pragma</span> vertex vert_img</span></span><br><span class="line">      <span class="meta">#<span class="keyword">pragma</span> fragment frag_HorizontalBlur</span></span><br><span class="line">      ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line">    Pass</span><br><span class="line">    &#123;</span><br><span class="line">      CGPROGRAM</span><br><span class="line">      <span class="meta">#<span class="keyword">pragma</span> vertex vert_img</span></span><br><span class="line">      <span class="meta">#<span class="keyword">pragma</span> fragment frag_VerticalBlur</span></span><br><span class="line">      ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="双重模糊"><a href="#双重模糊" class="headerlink" title="双重模糊"></a>双重模糊</h2><p>双重的核心思想是先降采样，然后升采样。</p>
<p>相较于Kawase Blur在两个大小相等的纹理之间进行乒乓blit的的思路，Dual Kawase Blur的核心思路在于blit过程中进行降采样和升采样,即对RT进行了降采样以及升采样。如下图所示：</p>
<p><img src="https://pic4.zhimg.com/80/v2-4226f0fd81e3f2ed61b48995e269328f_720w.jpg"></p>
<h3 id="双重-Kawase-模糊（Dual-Kawase-Blur）"><a href="#双重-Kawase-模糊（Dual-Kawase-Blur）" class="headerlink" title="双重 Kawase 模糊（Dual Kawase Blur）"></a>双重 Kawase 模糊（Dual Kawase Blur）</h3><p>双重 Kawase 模糊和双重盒状模糊模糊是最常用的，前者常用于移动端，后者都行，两个的性能和质量都优于之前两种算法</p>
<h4 id="Kawase模糊"><a href="#Kawase模糊" class="headerlink" title="Kawase模糊"></a>Kawase模糊</h4><p>Kawase Blur的思路是对距离当前像素越来越远的地方对四个角进行采样</p>
<p><img src="https://pic4.zhimg.com/80/v2-5ef03cc98ed2ed9a22dee30ce2915e7f_720w.jpg"></p>
<p>所以中间的权重为4&#x2F;8，其余四角为1&#x2F;8；</p>
<p>单独的Kawase算法性能太差了，淘汰。</p>
<h4 id="Dual-Kawase-Blur"><a href="#Dual-Kawase-Blur" class="headerlink" title="Dual Kawase Blur"></a>Dual Kawase Blur</h4><p>Dual Kawase Blur，简称Dual Blur，是SIGGRAPH 2015上ARM团队提出的一种衍生自Kawase Blur的模糊算法。其由两种不同的Blur Kernel构成，如下图所示。<img src="https://pic1.zhimg.com/80/v2-1ae54eb0e154d542ff6acdae06232bdc_720w.jpg"></p>
<p><img src="https://img-blog.csdnimg.cn/e92e5664bde1419f830f6a0e5dc9b91a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>这个贴图怕是只有我看的懂了，图一的1图代表红色的框框，第二个代表整个框框</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><h4 id="DualKawaseBlur-cs"><a href="#DualKawaseBlur-cs" class="headerlink" title="DualKawaseBlur.cs"></a>DualKawaseBlur.cs</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line">[<span class="meta">RequireComponent(typeof(Camera))</span>]</span><br><span class="line">[<span class="meta">ExecuteInEditMode</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DualKawaseBlur</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Material material;</span><br><span class="line">    [<span class="meta">Range(0,15)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> _BlurRadius = <span class="number">5.0f</span>;</span><br><span class="line">    [<span class="meta">Range(0, 10)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> _Iteration = <span class="number">4</span>;</span><br><span class="line">    [<span class="meta">Range(1, 10)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> _DownSample = <span class="number">2.0f</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;RenderTexture&gt; _tempRTList = <span class="keyword">new</span> List&lt;RenderTexture&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!SystemInfo.supportsImageEffects || <span class="literal">null</span> == material ||</span><br><span class="line">           <span class="literal">null</span> == material.shader || !material.shader.isSupported)</span><br><span class="line">        &#123;</span><br><span class="line">            enabled = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture source, RenderTexture destination</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> RTWidth = (<span class="built_in">int</span>)(source.width / _DownSample);</span><br><span class="line">        <span class="built_in">int</span> RTHeight = (<span class="built_in">int</span>)(source.height / _DownSample);</span><br><span class="line">        RenderTexture RT1 = RenderTexture.GetTemporary(RTWidth, RTHeight, <span class="number">0</span>);</span><br><span class="line">        RenderTexture RT2 = <span class="literal">null</span>;</span><br><span class="line">        material.SetFloat(<span class="string">&quot;_Offset&quot;</span>, _BlurRadius);</span><br><span class="line">        Graphics.Blit(source, RT1, material, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//降采样</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; _Iteration; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            RenderTexture.ReleaseTemporary(RT2);</span><br><span class="line">            RTWidth = RTWidth / <span class="number">2</span>;</span><br><span class="line">            RTHeight = RTHeight / <span class="number">2</span>;</span><br><span class="line">            RT2 = RenderTexture.GetTemporary(RTWidth, RTHeight);</span><br><span class="line">            Graphics.Blit(RT1, RT2, material, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            RTWidth = RTWidth / <span class="number">2</span>;</span><br><span class="line">            RTHeight = RTHeight / <span class="number">2</span>;</span><br><span class="line">            RenderTexture.ReleaseTemporary(RT1);</span><br><span class="line">            RT1 = RenderTexture.GetTemporary(RTWidth, RTHeight);</span><br><span class="line">            Graphics.Blit(RT2, RT1, material, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//升采样</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; _Iteration; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            RenderTexture.ReleaseTemporary(RT2);</span><br><span class="line">            RTWidth = RTWidth * <span class="number">2</span>;</span><br><span class="line">            RTHeight = RTHeight * <span class="number">2</span>;</span><br><span class="line">            RT2 = RenderTexture.GetTemporary(RTWidth, RTHeight);</span><br><span class="line">            Graphics.Blit(RT1, RT2, material, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            RTWidth = RTWidth * <span class="number">2</span>;</span><br><span class="line">            RTHeight = RTHeight * <span class="number">2</span>;</span><br><span class="line">            RenderTexture.ReleaseTemporary(RT1);</span><br><span class="line">            RT1 = RenderTexture.GetTemporary(RTWidth, RTHeight);</span><br><span class="line">            Graphics.Blit(RT2, RT1, material, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Graphics.Blit(RT1, destination, material, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// release</span></span><br><span class="line">        RenderTexture.ReleaseTemporary(RT1);</span><br><span class="line">        RenderTexture.ReleaseTemporary(RT2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="DualKawaseBlur-shader"><a href="#DualKawaseBlur-shader" class="headerlink" title="DualKawaseBlur.shader"></a>DualKawaseBlur.shader</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Hidden/DualKawaseBlur&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">  CGINCLUDE</span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">  uniform sampler2D _MainTex;</span><br><span class="line">  uniform float4 _MainTex_TexelSize;</span><br><span class="line">  uniform half _Offset;</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">v2f_DownSample</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    float4 pos: SV_POSITION;</span><br><span class="line">    float2 uv: TEXCOORD1;</span><br><span class="line">    float4 uv01: TEXCOORD2;</span><br><span class="line">    float4 uv23: TEXCOORD3;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">v2f_UpSample</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    float4 pos: SV_POSITION;</span><br><span class="line">    float4 uv01: TEXCOORD1;</span><br><span class="line">    float4 uv23: TEXCOORD2;</span><br><span class="line">    float4 uv45: TEXCOORD3;</span><br><span class="line">    float4 uv67: TEXCOORD4;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  v2f_DownSample <span class="title function_">Vert_DownSample</span><span class="params">(appdata_img v)</span></span><br><span class="line">  &#123;</span><br><span class="line">    v2f_DownSample o;</span><br><span class="line">    o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    </span><br><span class="line">    _MainTex_TexelSize = <span class="number">0.5</span> * _MainTex_TexelSize;</span><br><span class="line">    float2 uv = v.texcoord;</span><br><span class="line">    o.uv = uv;</span><br><span class="line">    o.uv01.xy = uv - _MainTex_TexelSize * float2(<span class="number">1</span> + _Offset, <span class="number">1</span> + _Offset);<span class="comment">//top right</span></span><br><span class="line">    o.uv01.zw = uv + _MainTex_TexelSize * float2(<span class="number">1</span> + _Offset, <span class="number">1</span> + _Offset);<span class="comment">//bottom left</span></span><br><span class="line">    o.uv23.xy = uv - float2(_MainTex_TexelSize.x, -_MainTex_TexelSize.y) * float2(<span class="number">1</span> + _Offset, <span class="number">1</span> + _Offset);<span class="comment">//top left</span></span><br><span class="line">    o.uv23.zw = uv + float2(_MainTex_TexelSize.x, -_MainTex_TexelSize.y) * float2(<span class="number">1</span> + _Offset, <span class="number">1</span> + _Offset);<span class="comment">//bottom right</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  half4 <span class="title function_">Frag_DownSample</span><span class="params">(v2f_DownSample i)</span>: SV_Target</span><br><span class="line">  &#123;</span><br><span class="line">    half4 sum = tex2D(_MainTex, i.uv) * <span class="number">4</span>;</span><br><span class="line">    sum += tex2D(_MainTex, i.uv01.xy);</span><br><span class="line">    sum += tex2D(_MainTex, i.uv01.zw);</span><br><span class="line">    sum += tex2D(_MainTex, i.uv23.xy);</span><br><span class="line">    sum += tex2D(_MainTex, i.uv23.zw);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum * <span class="number">0.125</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  v2f_UpSample <span class="title function_">Vert_UpSample</span><span class="params">(appdata_img v)</span></span><br><span class="line">  &#123;</span><br><span class="line">    v2f_UpSample o;</span><br><span class="line">    o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">  </span><br><span class="line">    float2 uv = v.texcoord;</span><br><span class="line">    </span><br><span class="line">    _MainTex_TexelSize = <span class="number">0.5</span> * _MainTex_TexelSize;</span><br><span class="line">    _Offset = float2(<span class="number">1</span> + _Offset, <span class="number">1</span> + _Offset);</span><br><span class="line">    </span><br><span class="line">    o.uv01.xy = uv + float2(-_MainTex_TexelSize.x * <span class="number">2</span>, <span class="number">0</span>) * _Offset;<span class="comment">//-2,0</span></span><br><span class="line">    o.uv01.zw = uv + float2(-_MainTex_TexelSize.x, _MainTex_TexelSize.y) * _Offset;<span class="comment">//-1 1</span></span><br><span class="line">    o.uv23.xy = uv + float2(<span class="number">0</span>, _MainTex_TexelSize.y * <span class="number">2</span>) * _Offset;<span class="comment">//0 2</span></span><br><span class="line">    o.uv23.zw = uv + _MainTex_TexelSize * _Offset;<span class="comment">//1 1</span></span><br><span class="line">    o.uv45.xy = uv + float2(_MainTex_TexelSize.x * <span class="number">2</span>, <span class="number">0</span>) * _Offset;<span class="comment">//2 0</span></span><br><span class="line">    o.uv45.zw = uv + float2(_MainTex_TexelSize.x, -_MainTex_TexelSize.y) * _Offset;<span class="comment">//1 -1</span></span><br><span class="line">    o.uv67.xy = uv + float2(<span class="number">0</span>, -_MainTex_TexelSize.y * <span class="number">2</span>) * _Offset;<span class="comment">//0 -2</span></span><br><span class="line">    o.uv67.zw = uv - _MainTex_TexelSize * _Offset;<span class="comment">// -1 -1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  half4 <span class="title function_">Frag_UpSample</span><span class="params">(v2f_UpSample i)</span>: SV_Target</span><br><span class="line">  &#123;</span><br><span class="line">    half4 sum = <span class="number">0</span>;</span><br><span class="line">    sum += tex2D(_MainTex, i.uv01.xy);</span><br><span class="line">    sum += tex2D(_MainTex, i.uv01.zw) * <span class="number">2</span>;</span><br><span class="line">    sum += tex2D(_MainTex, i.uv23.xy);</span><br><span class="line">    sum += tex2D(_MainTex, i.uv23.zw) * <span class="number">2</span>;</span><br><span class="line">    sum += tex2D(_MainTex, i.uv45.xy);</span><br><span class="line">    sum += tex2D(_MainTex, i.uv45.zw) * <span class="number">2</span>;</span><br><span class="line">    sum += tex2D(_MainTex, i.uv67.xy);</span><br><span class="line">    sum += tex2D(_MainTex, i.uv67.zw) * <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum * <span class="number">0.0833</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ENDCG</span><br><span class="line">  Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex(<span class="string">&quot;&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  SubShader</span><br><span class="line">  &#123;</span><br><span class="line">    Cull Off ZWrite Off ZTest Always</span><br><span class="line">    </span><br><span class="line">    Pass</span><br><span class="line">    &#123;</span><br><span class="line">      CGPROGRAM</span><br><span class="line">      <span class="meta">#<span class="keyword">pragma</span> vertex Vert_DownSample</span></span><br><span class="line">      <span class="meta">#<span class="keyword">pragma</span> fragment Frag_DownSample	</span></span><br><span class="line">      ENDCG		</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Pass</span><br><span class="line">    &#123;</span><br><span class="line">      CGPROGRAM	</span><br><span class="line">      <span class="meta">#<span class="keyword">pragma</span> vertex Vert_UpSample</span></span><br><span class="line">      <span class="meta">#<span class="keyword">pragma</span> fragment Frag_UpSample</span></span><br><span class="line">      ENDCG</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双重盒状模糊（Dual-Box-Blur）"><a href="#双重盒状模糊（Dual-Box-Blur）" class="headerlink" title="双重盒状模糊（Dual Box Blur）"></a>双重盒状模糊（Dual Box Blur）</h4><p>对原来的Box进行双重采样就行，最常用的算法。</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><h4 id="DualBoxBlur-cs"><a href="#DualBoxBlur-cs" class="headerlink" title="DualBoxBlur.cs"></a>DualBoxBlur.cs</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ExecuteInEditMode()</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DualBoxBlur</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Material material;</span><br><span class="line">    [<span class="meta">Range(0, 10)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> _Iteration = <span class="number">4</span>;</span><br><span class="line">    [<span class="meta">Range(0, 15)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> _BlurRadius = <span class="number">5.0f</span>;</span><br><span class="line">    [<span class="meta">Range(1, 10)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> _DownSample = <span class="number">2.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span> ()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material == <span class="literal">null</span> || SystemInfo.supportsImageEffects == <span class="literal">false</span></span><br><span class="line">            || material.shader == <span class="literal">null</span> || material.shader.isSupported == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            enabled = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture source, RenderTexture destination</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> width = (<span class="built_in">int</span>)(source.width / _DownSample);</span><br><span class="line">        <span class="built_in">int</span> height = (<span class="built_in">int</span>)(source.height / _DownSample);</span><br><span class="line">        RenderTexture RT1 = RenderTexture.GetTemporary(width,height);</span><br><span class="line">        RenderTexture RT2 = RenderTexture.GetTemporary(width, height);</span><br><span class="line"></span><br><span class="line">        Graphics.Blit(source, RT1);</span><br><span class="line"></span><br><span class="line">        material.SetVector(<span class="string">&quot;_BlurOffset&quot;</span>, <span class="keyword">new</span> Vector4(_BlurRadius / source.width, _BlurRadius / source.height, <span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="comment">//降采样</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; _Iteration; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            RenderTexture.ReleaseTemporary(RT2);</span><br><span class="line">            width = width / <span class="number">2</span>;</span><br><span class="line">            height = height / <span class="number">2</span>;</span><br><span class="line">            RT2 = RenderTexture.GetTemporary(width, height);</span><br><span class="line">            Graphics.Blit(RT1, RT2, material, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            RenderTexture.ReleaseTemporary(RT1);</span><br><span class="line">            width = width / <span class="number">2</span>;</span><br><span class="line">            height = height / <span class="number">2</span>;</span><br><span class="line">            RT1 = RenderTexture.GetTemporary(width, height);</span><br><span class="line">            Graphics.Blit(RT2, RT1, material, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//升采样</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; _Iteration; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            RenderTexture.ReleaseTemporary(RT2);</span><br><span class="line">            width = width * <span class="number">2</span>;</span><br><span class="line">            height = height * <span class="number">2</span>;</span><br><span class="line">            RT2 = RenderTexture.GetTemporary(width, height);</span><br><span class="line">            Graphics.Blit(RT1, RT2, material, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            RenderTexture.ReleaseTemporary(RT1);</span><br><span class="line">            width = width * <span class="number">2</span>;</span><br><span class="line">            height = height * <span class="number">2</span>;</span><br><span class="line">            RT1 = RenderTexture.GetTemporary(width, height);</span><br><span class="line">            Graphics.Blit(RT2, RT1, material, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Graphics.Blit(RT1, destination);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//release</span></span><br><span class="line">        RenderTexture.ReleaseTemporary(RT1);</span><br><span class="line">        RenderTexture.ReleaseTemporary(RT2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>就之前的BoxBlur.shader。</p>
<h1 id="其余算法"><a href="#其余算法" class="headerlink" title="其余算法"></a>其余算法</h1><p>可以参考毛星云大佬的其他算法。</p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>环境贴图技术</title>
    <url>/2022/04/01/%E7%8E%AF%E5%A2%83%E8%B4%B4%E5%9B%BE%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><p><img src="https://img-blog.csdnimg.cn/88c6172ddf434fe08f2402d04f5c72ed.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h1 id="环境贴图"><a href="#环境贴图" class="headerlink" title="环境贴图"></a>环境贴图</h1><p><img src="https://img-blog.csdnimg.cn/3dbe7748467c4b17b46bef1315a907f5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_15,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"></p>
<p>立方体贴图采样如上</p>
<h2 id="采样缺陷"><a href="#采样缺陷" class="headerlink" title="采样缺陷"></a>采样缺陷</h2><p>当同一角度，不同位置看过去会得到同样采样，所以不适合平面采样，解决方案后续说。</p>
<p><img src="https://img-blog.csdnimg.cn/992f6d6e2a2544f08ae0c748c47a10b6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">v2f <span class="title">vert</span> <span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function">         </span>&#123;</span><br><span class="line">             v2f o;</span><br><span class="line">             o.pos = <span class="built_in">UnityObjectToClipPos</span>(v.vertex);</span><br><span class="line">             o.normal_world = <span class="built_in">normalize</span>(<span class="built_in">mul</span>((v.normal),unity_WorldToObject).xyz);</span><br><span class="line">             o.tangent_world = <span class="built_in">normalize</span>(<span class="built_in">mul</span>((v.tangent),unity_WorldToObject).xyz);</span><br><span class="line">             o.binormal_world=<span class="built_in">normalize</span>(<span class="built_in">cross</span>(o.normal_world,o.tangent_world) * v.tangent.w);</span><br><span class="line">             o.pos_world = <span class="built_in">normalize</span>(<span class="built_in">mul</span>((v.vertex),unity_WorldToObject).xyz);</span><br><span class="line">             o.uv = v.uv*_NormalMap_ST.xy+_NormalMap_ST.zw;</span><br><span class="line">             </span><br><span class="line">             <span class="keyword">return</span> o;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function">fixed4 <span class="title">frag</span> <span class="params">(v2f i)</span> : SV_Target</span></span><br><span class="line"><span class="function">         &#123;</span></span><br><span class="line">             <span class="comment">// sample the texture</span></span><br><span class="line">             <span class="comment">//fixed4 base_col = tex2D(_MainTex, i.uv);</span></span><br><span class="line">             fixed4 base_col = <span class="built_in">fixed4</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">             half3 normaldata = <span class="built_in">UnpackNormal</span>( <span class="built_in">tex2D</span>(_NormalMap, i.uv));</span><br><span class="line">             half3 normal_world = <span class="built_in">normalize</span>(i.normal_world);</span><br><span class="line">             half3 tangent_world = <span class="built_in">normalize</span>(i.tangent_world);</span><br><span class="line">             half3 binormal_world = <span class="built_in">normalize</span>(i.binormal_world);</span><br><span class="line">             normal_world=<span class="built_in">mul</span>(normaldata, <span class="built_in">float3x3</span>(tangent_world,binormal_world,normal_world));</span><br><span class="line"></span><br><span class="line">             half3 view_dir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz-i.pos_world.xyz);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             half3 reflect_dir =<span class="built_in">reflect</span>(-view_dir,normal_world);</span><br><span class="line">             half4 finish_col = base_col;</span><br><span class="line">             </span><br><span class="line">             half4 Cube_col=<span class="built_in">texCUBE</span>(_CubeMap,reflect_dir); </span><br><span class="line">             half3 CubeHDR_col=<span class="built_in">DecodeHDR</span>(Cube_col,_CubeMap_HDR);</span><br><span class="line">             finish_col.rgb+=CubeHDR_col;</span><br><span class="line">             <span class="keyword">return</span> finish_col;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>



<h1 id="IBL-基于图像的光照技术"><a href="#IBL-基于图像的光照技术" class="headerlink" title="IBL 基于图像的光照技术"></a>IBL 基于图像的光照技术</h1><h2 id="预计算卷积"><a href="#预计算卷积" class="headerlink" title="预计算卷积"></a>预计算卷积</h2><p>通过模糊，得到不同层次的mip Map，便于模拟相应的磨砂层次。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">half4 Cube_col=<span class="built_in">texCUBElod</span>(_CubeMap,<span class="built_in">float4</span>(reflect_dir,_Roughness))</span><br></pre></td></tr></table></figure>

<p>粗糙度变成非线性</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">roughness=roughness*(<span class="number">1.7</span><span class="number">-0.7</span>*roughness);</span><br></pre></td></tr></table></figure>

<h2 id="反射探针"><a href="#反射探针" class="headerlink" title="反射探针"></a>反射探针</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">half4 Cube_col = <span class="built_in">UNITY_SAMPLE_TEXCUBE_LOD</span>(unity_SpecCube0,reflect_dir,_Roughness);</span><br></pre></td></tr></table></figure>

<p>为了用反射探针</p>
<p>UNITY_SAMPLE_TEXCUBE_LOD(反射贴图，反射向量，mip)</p>
<p>UNITY_SAMPLE_TEXCUBE(反射贴图，反射向量)  </p>
<p>反射探针贴图</p>
<p>unity_SpecCube0 </p>
<h1 id="SH球谐光照"><a href="#SH球谐光照" class="headerlink" title="SH球谐光照"></a>SH球谐光照</h1><h2 id="造轮子"><a href="#造轮子" class="headerlink" title="造轮子"></a>造轮子</h2><h3 id="shader"><a href="#shader" class="headerlink" title="shader"></a>shader</h3><p>将光照信息记录下来，实现间接光照。</p>
<p>属性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">custom_SHAr(<span class="string">&quot;Custom SHAr&quot;</span>, Vector) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">custom_SHAg(<span class="string">&quot;Custom SHAg&quot;</span>, Vector) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">custom_SHAb(<span class="string">&quot;Custom SHAb&quot;</span>, Vector) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">custom_SHBr(<span class="string">&quot;Custom SHBr&quot;</span>, Vector) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">custom_SHBg(<span class="string">&quot;Custom SHBg&quot;</span>, Vector) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">custom_SHBb(<span class="string">&quot;Custom SHBb&quot;</span>, Vector) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">custom_SHC(<span class="string">&quot;Custom SHC&quot;</span>, Vector) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>片元</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">float4 normalForSH = <span class="built_in">float4</span>(normal_dir, <span class="number">1.0</span>);</span><br><span class="line"><span class="comment">//SHEvalLinearL0L1</span></span><br><span class="line">half3 x;</span><br><span class="line">x.r = <span class="built_in">dot</span>(custom_SHAr, normalForSH);</span><br><span class="line">x.g = <span class="built_in">dot</span>(custom_SHAg, normalForSH);</span><br><span class="line">x.b = <span class="built_in">dot</span>(custom_SHAb, normalForSH);</span><br><span class="line"></span><br><span class="line"><span class="comment">//SHEvalLinearL2</span></span><br><span class="line">half3 x1, x2;</span><br><span class="line"><span class="comment">// 4 of the quadratic (L2) polynomials</span></span><br><span class="line">half4 vB = normalForSH.xyzz * normalForSH.yzzx;</span><br><span class="line">x1.r = <span class="built_in">dot</span>(custom_SHBr, vB);</span><br><span class="line">x1.g = <span class="built_in">dot</span>(custom_SHBg, vB);</span><br><span class="line">x1.b = <span class="built_in">dot</span>(custom_SHBb, vB);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Final (5th) quadratic (L2) polynomial</span></span><br><span class="line">half vC = normalForSH.x*normalForSH.x - normalForSH.y*normalForSH.y;</span><br><span class="line">x2 = custom_SHC.rgb * vC;</span><br><span class="line"></span><br><span class="line">float3 sh = <span class="built_in">max</span>(<span class="built_in">float3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>), (x + x1 + x2));</span><br><span class="line">sh = <span class="built_in">pow</span>(sh, <span class="number">1.0</span> / <span class="number">2.2</span>);</span><br><span class="line"></span><br><span class="line">half3 env_color = sh;</span><br></pre></td></tr></table></figure>

<p>部分函数可以放在顶点着色器中</p>
<h3 id="获取属性工具"><a href="#获取属性工具" class="headerlink" title="获取属性工具"></a>获取属性工具</h3><h4 id="SphericalHarmonicsCoefficient"><a href="#SphericalHarmonicsCoefficient" class="headerlink" title="SphericalHarmonicsCoefficient"></a>SphericalHarmonicsCoefficient</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 球谐光照因子计算方法,结果可以跟Unity内部的算法匹配上</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> http://sunandblackcat.com/tipFullView.php?l=eng&amp;topicid=32&amp;topic=Spherical-Harmonics-From-Cube-Texture</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> https://github.com/Microsoft/DirectXMath</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> http://www.ppsloan.org/publications/StupidSH36.pdf</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">SphericalHarmonicsCoefficient</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sphericalHarmonicsFromCubemap9</span>(<span class="params">Cubemap cubeTexture, <span class="keyword">ref</span> Vector3[] output</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// allocate memory for calculations</span></span><br><span class="line">        <span class="built_in">float</span>[] resultR = <span class="keyword">new</span> <span class="built_in">float</span>[<span class="number">9</span>];</span><br><span class="line">        <span class="built_in">float</span>[] resultG = <span class="keyword">new</span> <span class="built_in">float</span>[<span class="number">9</span>];</span><br><span class="line">        <span class="built_in">float</span>[] resultB = <span class="keyword">new</span> <span class="built_in">float</span>[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// initialize values</span></span><br><span class="line">        <span class="built_in">float</span> fWt = <span class="number">0.0f</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">uint</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            resultR[i] = <span class="number">0</span>;</span><br><span class="line">            resultG[i] = <span class="number">0</span>;</span><br><span class="line">            resultB[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">float</span>[] shBuff = <span class="keyword">new</span> <span class="built_in">float</span>[<span class="number">9</span>];</span><br><span class="line">        <span class="built_in">float</span>[] shBuffB = <span class="keyword">new</span> <span class="built_in">float</span>[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for each face of cube texture</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> face = <span class="number">0</span>; face &lt; <span class="number">6</span>; face++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// step between two texels for range [0, 1]</span></span><br><span class="line">            <span class="built_in">float</span> invWidth = <span class="number">1.0f</span> / cubeTexture.width;</span><br><span class="line">            <span class="comment">// initial negative bound for range [-1, 1]</span></span><br><span class="line">            <span class="built_in">float</span> negativeBound = <span class="number">-1.0f</span> + invWidth;</span><br><span class="line">            <span class="comment">// step between two texels for range [-1, 1]</span></span><br><span class="line">            <span class="built_in">float</span> invWidthBy2 = <span class="number">2.0f</span> / cubeTexture.width;</span><br><span class="line"></span><br><span class="line">            Color[] data = cubeTexture.GetPixels((CubemapFace)face);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> y = <span class="number">0</span>; y &lt; cubeTexture.width; y++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// texture coordinate V in range [-1 to 1]</span></span><br><span class="line">                <span class="built_in">float</span> fV = negativeBound + y * invWidthBy2;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> x = <span class="number">0</span>; x &lt; cubeTexture.width; x++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// texture coordinate U in range [-1 to 1]</span></span><br><span class="line">                    <span class="built_in">float</span> fU = negativeBound + x * invWidthBy2;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// determine direction from center of cube texture to current texel</span></span><br><span class="line">                    Vector3 dir;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">switch</span> ((CubemapFace)face)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">case</span> CubemapFace.PositiveX:</span><br><span class="line">                            dir.x = <span class="number">1.0f</span>;</span><br><span class="line">                            dir.y = <span class="number">1.0f</span> - (invWidthBy2 * y + invWidth);</span><br><span class="line">                            dir.z = <span class="number">1.0f</span> - (invWidthBy2 * x + invWidth);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> CubemapFace.NegativeX:</span><br><span class="line">                            dir.x = <span class="number">-1.0f</span>;</span><br><span class="line">                            dir.y = <span class="number">1.0f</span> - (invWidthBy2 * y + invWidth);</span><br><span class="line">                            dir.z = <span class="number">-1.0f</span> + (invWidthBy2 * x + invWidth);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> CubemapFace.PositiveY:</span><br><span class="line">                            dir.x = <span class="number">-1.0f</span> + (invWidthBy2 * x + invWidth);</span><br><span class="line">                            dir.y = <span class="number">1.0f</span>;</span><br><span class="line">                            dir.z = <span class="number">-1.0f</span> + (invWidthBy2 * y + invWidth);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> CubemapFace.NegativeY:</span><br><span class="line">                            dir.x = <span class="number">-1.0f</span> + (invWidthBy2 * x + invWidth);</span><br><span class="line">                            dir.y = <span class="number">-1.0f</span>;</span><br><span class="line">                            dir.z = <span class="number">1.0f</span> - (invWidthBy2 * y + invWidth);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> CubemapFace.PositiveZ:</span><br><span class="line">                            dir.x = <span class="number">-1.0f</span> + (invWidthBy2 * x + invWidth);</span><br><span class="line">                            dir.y = <span class="number">1.0f</span> - (invWidthBy2 * y + invWidth);</span><br><span class="line">                            dir.z = <span class="number">1.0f</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> CubemapFace.NegativeZ:</span><br><span class="line">                            dir.x = <span class="number">1.0f</span> - (invWidthBy2 * x + invWidth);</span><br><span class="line">                            dir.y = <span class="number">1.0f</span> - (invWidthBy2 * y + invWidth);</span><br><span class="line">                            dir.z = <span class="number">-1.0f</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="literal">default</span>:</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// normalize direction</span></span><br><span class="line">                    dir = dir.normalized;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// scale factor depending on distance from center of the face</span></span><br><span class="line">                    <span class="built_in">float</span> fDiffSolid = <span class="number">4.0f</span> / ((<span class="number">1.0f</span> + fU * fU + fV * fV) * Mathf.Sqrt(<span class="number">1.0f</span> + fU * fU + fV * fV));</span><br><span class="line">                    fWt += fDiffSolid;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// calculate coefficients of spherical harmonics for current direction</span></span><br><span class="line">                    sphericalHarmonicsEvaluateDirection9(<span class="keyword">ref</span> shBuff, dir);</span><br><span class="line">                    <span class="comment">//XMSHEvalDirection(dir, ref shBuff);</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// index of texel in texture</span></span><br><span class="line">                    <span class="built_in">int</span> pixOffsetIndex = x + y * cubeTexture.width;</span><br><span class="line">                    <span class="comment">// get color from texture and map to range [0, 1]</span></span><br><span class="line">                    Vector3 clr= <span class="keyword">new</span> Vector3(data[pixOffsetIndex].r, data[pixOffsetIndex].g, data[pixOffsetIndex].b);</span><br><span class="line">                    <span class="comment">//if (data[pixOffsetIndex].a == 1)</span></span><br><span class="line">                    <span class="comment">//&#123;</span></span><br><span class="line">                    <span class="comment">//    clr = new Vector3(data[pixOffsetIndex].r, data[pixOffsetIndex].g, data[pixOffsetIndex].b);</span></span><br><span class="line">                    <span class="comment">//&#125;</span></span><br><span class="line">                    <span class="comment">//else</span></span><br><span class="line">                    <span class="comment">//&#123;</span></span><br><span class="line">                    <span class="comment">//    clr = DecodeHDR(data[pixOffsetIndex]);</span></span><br><span class="line">                    <span class="comment">//&#125;</span></span><br><span class="line">                    <span class="keyword">if</span> (PlayerSettings.colorSpace == ColorSpace.Gamma)</span><br><span class="line">                    &#123;</span><br><span class="line">                        clr.x = Mathf.GammaToLinearSpace(clr.x);</span><br><span class="line">                        clr.y = Mathf.GammaToLinearSpace(clr.y);</span><br><span class="line">                        clr.z = Mathf.GammaToLinearSpace(clr.z);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// scale color and add to previously accumulated coefficients</span></span><br><span class="line">                    sphericalHarmonicsScale9(<span class="keyword">ref</span> shBuffB, shBuff, clr.x * fDiffSolid);</span><br><span class="line">                    sphericalHarmonicsAdd9(<span class="keyword">ref</span> resultR, resultR, shBuffB);</span><br><span class="line">                    sphericalHarmonicsScale9(<span class="keyword">ref</span> shBuffB, shBuff, clr.y * fDiffSolid);</span><br><span class="line">                    sphericalHarmonicsAdd9(<span class="keyword">ref</span> resultG, resultG, shBuffB);</span><br><span class="line">                    sphericalHarmonicsScale9(<span class="keyword">ref</span> shBuffB, shBuff, clr.z * fDiffSolid);</span><br><span class="line">                    sphericalHarmonicsAdd9(<span class="keyword">ref</span> resultB, resultB, shBuffB);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// final scale for coefficients</span></span><br><span class="line">        <span class="built_in">float</span> fNormProj = (<span class="number">4.0f</span> * Mathf.PI) / fWt;</span><br><span class="line">        sphericalHarmonicsScale9(<span class="keyword">ref</span> resultR, resultR, fNormProj);</span><br><span class="line">        sphericalHarmonicsScale9(<span class="keyword">ref</span> resultG, resultG, fNormProj);</span><br><span class="line">        sphericalHarmonicsScale9(<span class="keyword">ref</span> resultB, resultB, fNormProj);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// save result</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">uint</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            output[i].x = resultR[i];</span><br><span class="line">            output[i].y = resultG[i];</span><br><span class="line">            output[i].z = resultB[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Vector3 <span class="title">DecodeHDR</span>(<span class="params">Color clr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Vector3(clr.r, clr.g, clr.b) * clr.a;<span class="comment">// * Mathf.Pow(clr.a, 2);// * (Mathf.Pow(clr.a, 0.1f) * 1);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sphericalHarmonicsEvaluateDirection9</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">float</span>[] outsh, Vector3 dir</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 86 clocks</span></span><br><span class="line">        <span class="comment">// Make sure all constants are never computed at runtime</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">float</span> kInv2SqrtPI = <span class="number">0.28209479177387814347403972578039f</span>; <span class="comment">// 1 / (2*sqrt(kPI))</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">float</span> kSqrt3Div2SqrtPI = <span class="number">0.48860251190291992158638462283835f</span>; <span class="comment">// sqrt(3) / (2*sqrt(kPI))</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">float</span> kSqrt15Div2SqrtPI = <span class="number">1.0925484305920790705433857058027f</span>; <span class="comment">// sqrt(15) / (2*sqrt(kPI))</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">float</span> k3Sqrt5Div4SqrtPI = <span class="number">0.94617469575756001809268107088713f</span>; <span class="comment">// 3 * sqrtf(5) / (4*sqrt(kPI))</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">float</span> kSqrt15Div4SqrtPI = <span class="number">0.54627421529603953527169285290135f</span>; <span class="comment">// sqrt(15) / (4*sqrt(kPI))</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">float</span> kOneThird = <span class="number">0.3333333333333333333333f</span>; <span class="comment">// 1.0/3.0</span></span><br><span class="line">        outsh[<span class="number">0</span>] = kInv2SqrtPI;</span><br><span class="line">        outsh[<span class="number">1</span>] = -dir.y * kSqrt3Div2SqrtPI;</span><br><span class="line">        outsh[<span class="number">2</span>] = dir.z * kSqrt3Div2SqrtPI;</span><br><span class="line">        outsh[<span class="number">3</span>] = -dir.x * kSqrt3Div2SqrtPI;</span><br><span class="line">        outsh[<span class="number">4</span>] = dir.x * dir.y * kSqrt15Div2SqrtPI;</span><br><span class="line">        outsh[<span class="number">5</span>] = -dir.y * dir.z * kSqrt15Div2SqrtPI;</span><br><span class="line">        outsh[<span class="number">6</span>] = (dir.z * dir.z - kOneThird) * k3Sqrt5Div4SqrtPI;</span><br><span class="line">        outsh[<span class="number">7</span>] = -dir.x * dir.z * kSqrt15Div2SqrtPI;</span><br><span class="line">        outsh[<span class="number">8</span>] = (dir.x * dir.x - dir.y * dir.y) * kSqrt15Div4SqrtPI;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sphericalHarmonicsAdd9</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">float</span>[] result, <span class="built_in">float</span>[] inputA, <span class="built_in">float</span>[] inputB</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            result[i] = inputA[i] + inputB[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sphericalHarmonicsScale9</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">float</span>[] result, <span class="built_in">float</span>[] input, <span class="built_in">float</span> scale</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            result[i] = input[i] * scale;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">float</span> s_fSqrtPI = Mathf.Sqrt(Mathf.PI);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">float</span> fC0 = <span class="number">1.0f</span> / (<span class="number">2.0f</span> * s_fSqrtPI);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">float</span> fC1 = Mathf.Sqrt(<span class="number">3.0f</span>) / (<span class="number">3.0f</span> * s_fSqrtPI);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">float</span> fC2 = Mathf.Sqrt(<span class="number">15.0f</span>) / (<span class="number">8.0f</span> * s_fSqrtPI);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">float</span> fC3 = Mathf.Sqrt(<span class="number">5.0f</span>) / (<span class="number">16.0f</span> * s_fSqrtPI);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">float</span> fC4 = <span class="number">0.5f</span> * fC2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ConvertSHConstants</span>(<span class="params">Vector3[] sh, <span class="keyword">ref</span> Vector4[] SHArBrC</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> iC;</span><br><span class="line">        <span class="keyword">for</span> (iC = <span class="number">0</span>; iC &lt; <span class="number">3</span>; iC++)</span><br><span class="line">        &#123;</span><br><span class="line">            SHArBrC[iC].x = -fC1 * sh[<span class="number">3</span>][iC];</span><br><span class="line">            SHArBrC[iC].y = -fC1 * sh[<span class="number">1</span>][iC];</span><br><span class="line">            SHArBrC[iC].z = fC1 * sh[<span class="number">2</span>][iC];</span><br><span class="line">            SHArBrC[iC].w = fC0 * sh[<span class="number">0</span>][iC] - fC3 * sh[<span class="number">6</span>][iC];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (iC = <span class="number">0</span>; iC &lt; <span class="number">3</span>; iC++)</span><br><span class="line">        &#123;</span><br><span class="line">            SHArBrC[iC + <span class="number">3</span>].x = fC2 * sh[<span class="number">4</span>][iC];</span><br><span class="line">            SHArBrC[iC + <span class="number">3</span>].y = -fC2 * sh[<span class="number">5</span>][iC];</span><br><span class="line">            SHArBrC[iC + <span class="number">3</span>].z = <span class="number">3.0f</span> * fC3 * sh[<span class="number">6</span>][iC];</span><br><span class="line">            SHArBrC[iC + <span class="number">3</span>].w = -fC2 * sh[<span class="number">7</span>][iC];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SHArBrC[<span class="number">6</span>].x = fC4 * sh[<span class="number">8</span>][<span class="number">0</span>];</span><br><span class="line">        SHArBrC[<span class="number">6</span>].y = fC4 * sh[<span class="number">8</span>][<span class="number">1</span>];</span><br><span class="line">        SHArBrC[<span class="number">6</span>].z = fC4 * sh[<span class="number">8</span>][<span class="number">2</span>];</span><br><span class="line">        SHArBrC[<span class="number">6</span>].w = <span class="number">1.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CubemapSHProjector"><a href="#CubemapSHProjector" class="headerlink" title="CubemapSHProjector"></a>CubemapSHProjector</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CubemapSHProjector</span> : <span class="title">EditorWindow</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//PUBLIC FIELDS</span></span><br><span class="line">    <span class="keyword">public</span> Texture envMap;</span><br><span class="line">    <span class="keyword">public</span> Transform go;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//PRIVATE FIELDS</span></span><br><span class="line">    <span class="keyword">private</span> Material    view_mat;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span>       view_mode;</span><br><span class="line">    <span class="keyword">private</span> Vector4[]   coefficients;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SerializedObject so;</span><br><span class="line">    <span class="keyword">private</span> SerializedProperty sp_input_cubemap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Texture2D tmp = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CheckAndConvertEnvMap</span>(<span class="params"><span class="keyword">ref</span> Texture envMap, <span class="keyword">ref</span> Vector4[] sh_out</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!envMap) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> map_path = AssetDatabase.GetAssetPath(envMap);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(map_path)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        TextureImporter ti = AssetImporter.GetAtPath(map_path) <span class="keyword">as</span> TextureImporter;</span><br><span class="line">        <span class="keyword">if</span> (!ti) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">bool</span> read_able = ti.isReadable;</span><br><span class="line">        <span class="built_in">bool</span> need_reimport = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ti.textureShape != TextureImporterShape.TextureCube)</span><br><span class="line">        &#123;</span><br><span class="line">            ti.textureShape = TextureImporterShape.TextureCube;</span><br><span class="line">            need_reimport = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ti.mipmapEnabled)</span><br><span class="line">        &#123;</span><br><span class="line">            ti.mipmapEnabled = <span class="literal">true</span>;</span><br><span class="line">            need_reimport = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ti.sRGBTexture)</span><br><span class="line">        &#123;</span><br><span class="line">            ti.sRGBTexture = <span class="literal">true</span>;</span><br><span class="line">            need_reimport = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ti.filterMode != FilterMode.Trilinear)</span><br><span class="line">        &#123;</span><br><span class="line">            ti.filterMode = FilterMode.Trilinear;</span><br><span class="line">            need_reimport = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TextureImporterSettings tis = <span class="keyword">new</span> TextureImporterSettings();</span><br><span class="line">        ti.ReadTextureSettings(tis);</span><br><span class="line">        <span class="keyword">if</span> (tis.cubemapConvolution != TextureImporterCubemapConvolution.Specular)</span><br><span class="line">        &#123;</span><br><span class="line">            tis.cubemapConvolution = TextureImporterCubemapConvolution.Specular;</span><br><span class="line">            ti.SetTextureSettings(tis);</span><br><span class="line">            need_reimport = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if (ti.GetDefaultPlatformTextureSettings().maxTextureSize != 128)</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="comment">//    TextureImporterPlatformSettings tips = new TextureImporterPlatformSettings();</span></span><br><span class="line">        <span class="comment">//    tips.maxTextureSize = 128;</span></span><br><span class="line">        <span class="comment">//    ti.SetPlatformTextureSettings(tips);</span></span><br><span class="line">        <span class="comment">//    ti.maxTextureSize = 128;</span></span><br><span class="line">        <span class="comment">//    need_reimport = true;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!read_able)</span><br><span class="line">        &#123;</span><br><span class="line">            ti.isReadable = <span class="literal">true</span>;</span><br><span class="line">            need_reimport = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (need_reimport)</span><br><span class="line">        &#123;</span><br><span class="line">            ti.SaveAndReimport();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        envMap = AssetDatabase.LoadAssetAtPath&lt;Texture&gt;(map_path);</span><br><span class="line">        <span class="keyword">if</span> (!envMap) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        Vector3[] sh = <span class="keyword">new</span> Vector3[<span class="number">9</span>];</span><br><span class="line">        SphericalHarmonicsCoefficient.sphericalHarmonicsFromCubemap9((Cubemap)envMap, <span class="keyword">ref</span> sh);</span><br><span class="line">        SphericalHarmonicsCoefficient.ConvertSHConstants(sh, <span class="keyword">ref</span> sh_out);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ti.isReadable != read_able)</span><br><span class="line">        &#123;</span><br><span class="line">            ti.isReadable = read_able;</span><br><span class="line">            ti.SaveAndReimport();</span><br><span class="line">            envMap = AssetDatabase.LoadAssetAtPath&lt;Texture&gt;(map_path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">MenuItem(<span class="string">&quot;美术/SH系数生成&quot;</span>, false, 2100)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Init</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CubemapSHProjector window = (CubemapSHProjector)EditorWindow.GetWindow(<span class="keyword">typeof</span>(CubemapSHProjector));</span><br><span class="line">        window.Show();</span><br><span class="line">        window.titleContent = <span class="keyword">new</span> GUIContent(<span class="string">&quot;SH生成器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnFocus</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Initialize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Initialize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Initialize</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        so = <span class="keyword">new</span> SerializedObject(<span class="keyword">this</span>);</span><br><span class="line">        sp_input_cubemap = so.FindProperty(<span class="string">&quot;input_cubemap&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGUI</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        EditorGUI.BeginChangeCheck();</span><br><span class="line">        envMap = EditorGUILayout.ObjectField(<span class="string">&quot;环境图&quot;</span>, envMap, <span class="keyword">typeof</span>(Texture), <span class="literal">false</span>) <span class="keyword">as</span> Texture;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (envMap != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            EditorGUILayout.Space();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (GUILayout.Button(<span class="string">&quot;Calc&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (envMap != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    coefficients = <span class="keyword">new</span> Vector4[<span class="number">7</span>];</span><br><span class="line">                    CheckAndConvertEnvMap(<span class="keyword">ref</span> envMap, <span class="keyword">ref</span> coefficients);</span><br><span class="line">                &#125;</span><br><span class="line">                SceneView.RepaintAll();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            EditorGUILayout.Space();</span><br><span class="line"></span><br><span class="line">            go = EditorGUILayout.ObjectField(<span class="string">&quot;Obj&quot;</span>, go, <span class="keyword">typeof</span>(Transform), <span class="literal">true</span>) <span class="keyword">as</span> Transform;</span><br><span class="line">            <span class="keyword">if</span> (go != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (GUILayout.Button(<span class="string">&quot;Apply&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    List&lt;Material&gt; mat_list = <span class="keyword">new</span> List&lt;Material&gt;();</span><br><span class="line">                    <span class="keyword">var</span> renders = go.GetComponentsInChildren&lt;Renderer&gt;();</span><br><span class="line">                    <span class="keyword">foreach</span> (<span class="keyword">var</span> render <span class="keyword">in</span> renders)</span><br><span class="line">                    &#123;</span><br><span class="line">                        mat_list.AddRange(render.sharedMaterials);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">foreach</span> (<span class="keyword">var</span> mat <span class="keyword">in</span> mat_list)</span><br><span class="line">                    &#123;</span><br><span class="line">                        mat.SetVector(<span class="string">&quot;custom_SHAr&quot;</span>, coefficients[<span class="number">0</span>]);</span><br><span class="line">                        mat.SetVector(<span class="string">&quot;custom_SHAg&quot;</span>, coefficients[<span class="number">1</span>]);</span><br><span class="line">                        mat.SetVector(<span class="string">&quot;custom_SHAb&quot;</span>, coefficients[<span class="number">2</span>]);</span><br><span class="line">                        mat.SetVector(<span class="string">&quot;custom_SHBr&quot;</span>, coefficients[<span class="number">3</span>]);</span><br><span class="line">                        mat.SetVector(<span class="string">&quot;custom_SHBg&quot;</span>, coefficients[<span class="number">4</span>]);</span><br><span class="line">                        mat.SetVector(<span class="string">&quot;custom_SHBb&quot;</span>, coefficients[<span class="number">5</span>]);</span><br><span class="line">                        mat.SetVector(<span class="string">&quot;custom_SHC&quot;</span>, coefficients[<span class="number">6</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mat_list.Clear();</span><br><span class="line">                    SceneView.RepaintAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            EditorGUILayout.Space();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//print the 9 coefficients</span></span><br><span class="line">            <span class="keyword">if</span> (coefficients != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                EditorGUILayout.LabelField(<span class="string">&quot;custom_SHAr&quot;</span> + <span class="string">&quot;: &quot;</span> + coefficients[<span class="number">0</span>].ToString(<span class="string">&quot;F4&quot;</span>));</span><br><span class="line">                EditorGUILayout.LabelField(<span class="string">&quot;custom_SHAg&quot;</span> + <span class="string">&quot;: &quot;</span> + coefficients[<span class="number">1</span>].ToString(<span class="string">&quot;F4&quot;</span>));</span><br><span class="line">                EditorGUILayout.LabelField(<span class="string">&quot;custom_SHAb&quot;</span> + <span class="string">&quot;: &quot;</span> + coefficients[<span class="number">2</span>].ToString(<span class="string">&quot;F4&quot;</span>));</span><br><span class="line">                EditorGUILayout.LabelField(<span class="string">&quot;custom_SHBr&quot;</span> + <span class="string">&quot;: &quot;</span> + coefficients[<span class="number">3</span>].ToString(<span class="string">&quot;F4&quot;</span>));</span><br><span class="line">                EditorGUILayout.LabelField(<span class="string">&quot;custom_SHBg&quot;</span> + <span class="string">&quot;: &quot;</span> + coefficients[<span class="number">4</span>].ToString(<span class="string">&quot;F4&quot;</span>));</span><br><span class="line">                EditorGUILayout.LabelField(<span class="string">&quot;custom_SHBb&quot;</span> + <span class="string">&quot;: &quot;</span> + coefficients[<span class="number">5</span>].ToString(<span class="string">&quot;F4&quot;</span>));</span><br><span class="line">                EditorGUILayout.LabelField(<span class="string">&quot;custom_SHC&quot;</span> + <span class="string">&quot;: &quot;</span> + coefficients[<span class="number">6</span>].ToString(<span class="string">&quot;F4&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        EditorGUILayout.Space();</span><br><span class="line">        <span class="keyword">if</span> (tmp != <span class="literal">null</span>)</span><br><span class="line">            GUILayout.Label(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Unity内置函数"><a href="#Unity内置函数" class="headerlink" title="Unity内置函数"></a>Unity内置函数</h2><p>换上小皮肤</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Tags&#123;<span class="string">&quot;LightMode&quot;</span>=<span class="string">&quot;ForwardBase&quot;</span>&#125;</span><br><span class="line">CGPROGRAM</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdbase</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AutoLight.cginc&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>片元</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">half3 env_color = <span class="built_in">ShadeSH9</span>(<span class="built_in">float4</span>(normal_dir,<span class="number">1.0</span>));</span><br></pre></td></tr></table></figure>

<p>完成</p>
<h2 id="光照探测器"><a href="#光照探测器" class="headerlink" title="光照探测器"></a>光照探测器</h2><p>光照探测器的小球记录下问题的球谐数值，然后物体在范围内时，用物体周围小球的球谐数值做插值。</p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端人物渲染</title>
    <url>/2022/04/14/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BA%BA%E7%89%A9%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/c4b325b53d024b859f7199f85712707f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="模型与贴图分析"><a href="#模型与贴图分析" class="headerlink" title="模型与贴图分析"></a>模型与贴图分析</h1><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>导入武器时属于泛型。</p>
<p>psk导入模型时3dmax效果比blender好，blender的模型不会平滑，选用3dmax加载模型。</p>
<h2 id="贴图分析"><a href="#贴图分析" class="headerlink" title="贴图分析"></a>贴图分析</h2><h3 id="Albedo-贴图"><a href="#Albedo-贴图" class="headerlink" title="Albedo 贴图"></a>Albedo 贴图</h3><p>包含金属非金属部分的基本颜色</p>
<h3 id="combmap-贴图"><a href="#combmap-贴图" class="headerlink" title="combmap 贴图"></a>combmap 贴图</h3><p>R通道是roughness 粗糙度</p>
<p>G通道是金属度</p>
<p>B，如果皮肤通道为红色部分地方为蓝色就是皮肤部分</p>
<h3 id="法线贴图"><a href="#法线贴图" class="headerlink" title="法线贴图"></a>法线贴图</h3><p>见之前文章</p>
<h1 id="光照框架"><a href="#光照框架" class="headerlink" title="光照框架"></a>光照框架</h1><h2 id="直接光照反射"><a href="#直接光照反射" class="headerlink" title="直接光照反射"></a>直接光照反射</h2><h3 id="lambert"><a href="#lambert" class="headerlink" title="lambert"></a>lambert</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">half half_lambert = (diffuse_term+<span class="number">1.0</span>)*<span class="number">0.5</span>;</span><br></pre></td></tr></table></figure>

<h3 id="SSS-散光"><a href="#SSS-散光" class="headerlink" title="SSS 散光"></a>SSS 散光</h3><p><img src="https://img-blog.csdnimg.cn/5a277f97ec634e89b0a8a50794534582.png" alt="请添加图片描述"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">half skin_area  = <span class="number">1</span>- comb_map.b;<span class="comment">//获取颜色部分</span></span><br><span class="line">half2 uv_lut = <span class="built_in">float2</span>(<span class="built_in">min</span>(<span class="number">1</span>, diffuse_term*atten  +_LUTOffset),_CurveOffset);<span class="comment">//将颜色分布在光照边缘</span></span><br><span class="line">half3 lut_color = <span class="built_in">tex2D</span>(_SSSTrick,uv_lut);</span><br><span class="line">half3 sss_diffuse = lut_color *base_col*_LightColor0.xyz* half_lambert;<span class="comment">//散射部分光照</span></span><br><span class="line">half3 diffuse = <span class="built_in">lerp</span>(comm_diffuse,sss_diffuse,skin_area);<span class="comment">//区分皮肤和非皮肤部分</span></span><br></pre></td></tr></table></figure>

<h2 id="直接光镜面反射"><a href="#直接光镜面反射" class="headerlink" title="直接光镜面反射"></a>直接光镜面反射</h2><h3 id="Blin-Phong"><a href="#Blin-Phong" class="headerlink" title="Blin-Phong"></a>Blin-Phong</h3><p>利用V+L代替reflect(-L,N)</p>
<h3 id="KK各项异性"><a href="#KK各项异性" class="headerlink" title="KK各项异性"></a>KK各项异性</h3><p> 光照射头发、不锈钢锅底，光碟会出现这样的现象。头发可以去除间接光的漫反射。</p>
<p><strong>简单原理版</strong></p>
<p><img src="https://img-blog.csdnimg.cn/274730248572485cb0c99a614a6ff9e7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/d25cb401a6fe4aff9336ce2fa3dc51e3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUEMgRXJyb3I=,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">half3 half_dir =<span class="built_in">normalize</span>( light_dir+view_dir);<span class="comment">//得到半角向量</span></span><br><span class="line">           half2 uv_shift = i.texcoord * _ShiftNoise_ST.xy+_ShiftNoise_ST.zw;<span class="comment">//控制发丝密度</span></span><br><span class="line">           half shiftnoise = <span class="built_in">tex2D</span>(_ShiftNoise,uv_shift).r;</span><br><span class="line">           shiftnoise =(shiftnoise*<span class="number">2.0</span><span class="number">-1.0</span>)*_NoiseIntensity;<span class="comment">//从-1 - 1 映射到 0 - 1</span></span><br><span class="line">           half3 b_offset =    normal_dir*(_Shiftoffset+shiftnoise);<span class="comment">//法线方向偏移（上下移动）</span></span><br><span class="line">          </span><br><span class="line">           binormal_dir = <span class="built_in">normalize</span>(binormal_dir+ b_offset);</span><br><span class="line">           half TdotN=<span class="built_in">dot</span>(binormal_dir,half_dir);</span><br><span class="line">           half sinTH = <span class="built_in">sqrt</span>(<span class="number">1</span>-TdotN*TdotN);</span><br><span class="line">           fixed3 specular_color = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>,sinTH),_Shininess)<span class="comment">//将公式</span></span><br><span class="line">           *_LightColor0.xyz;</span><br></pre></td></tr></table></figure>

<p><img src="https://o.130014.xyz/2022/04/14/_ShiftTexture.png" alt="ShiftNoises"></p>
<p>​                                                                                        <strong>_ShiftNoise</strong></p>
<p>头发部分体现,调了半天没调好，开摆。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">half roughness = <span class="number">0.2</span>;</span><br><span class="line">         half3 half_dir =<span class="built_in">normalize</span>( light_dir+view_dir);</span><br><span class="line">         half2 uv_Anoise = i.texcoord*_AnoiseMap_ST.xy+_AnoiseMap_ST.zw;</span><br><span class="line">         half3 aniso_noise = <span class="built_in">tex2D</span>(_AnoiseMap,uv_Anoise);</span><br><span class="line"></span><br><span class="line">         half NdotH = <span class="built_in">dot</span>(normal_dir,half_dir);</span><br><span class="line">         half TdotH = <span class="built_in">dot</span>(tangent_dir,half_dir);</span><br><span class="line"></span><br><span class="line">         half NdotV = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(normal_dir,view_dir));</span><br><span class="line">         half aniso_atten = <span class="built_in">saturate</span>(<span class="built_in">sqrt</span>(<span class="built_in">max</span>(<span class="number">0</span>,half_lambert/NdotV)))*atten;</span><br><span class="line">         <span class="comment">//spec1</span></span><br><span class="line">         half3 specular_color1 = _SpecularColor1 + base_col;</span><br><span class="line">         half3 aniso_offset1 = normal_dir *(aniso_noise*_SpecNoise1+_Shiftoffset1);</span><br><span class="line">         half3 binormal_dir1 = <span class="built_in">normalize</span>(binormal_dir + aniso_offset1);</span><br><span class="line">         half BdotH1 = <span class="built_in">dot</span>(binormal_dir1,half_dir)/ _SpecShininess1;</span><br><span class="line">         half3 specular_term1 = <span class="built_in">exp</span>(-(TdotH*TdotH+BdotH1*BdotH1)/(<span class="number">1.0</span>+NdotH));</span><br><span class="line">         half3 specular1 = specular_term1*aniso_atten*specular_color1*_LightColor0.xyz;</span><br><span class="line">         </span><br><span class="line">         half3 specular_color2 = _SpecularColor2 + base_col;</span><br><span class="line">         half3 aniso_offset2 = normal_dir *(aniso_noise*_SpecNoise2+_Shiftoffset2);</span><br><span class="line">         half3 binormal_dir2 = <span class="built_in">normalize</span>(binormal_dir + aniso_offset2);</span><br><span class="line">         half BdotH2 = <span class="built_in">dot</span>(binormal_dir2,half_dir)/ _SpecShininess2;</span><br><span class="line">         half3 specular_term2 = <span class="built_in">exp</span>(-(TdotH*TdotH+BdotH2*BdotH2)/(<span class="number">1.0</span>+NdotH));</span><br><span class="line">         half3 specular2 = specular_term2*aniso_atten*specular_color2*_LightColor0.xyz;</span><br><span class="line">         half3 specular = specular1+specular2;</span><br><span class="line">         col.xyz+=specular;</span><br></pre></td></tr></table></figure>

<h1 id="ACES-Tonemapping"><a href="#ACES-Tonemapping" class="headerlink" title="ACES_Tonemapping"></a>ACES_Tonemapping</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">float3 <span class="title">ACES_Tonemapping</span><span class="params">(float3 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">float</span> a = <span class="number">2.51f</span>;</span><br><span class="line">  <span class="type">float</span> b = <span class="number">0.03f</span>;</span><br><span class="line">  <span class="type">float</span> c = <span class="number">2.43f</span>;</span><br><span class="line">  <span class="type">float</span> d = <span class="number">0.59f</span>;</span><br><span class="line">  <span class="type">float</span> e = <span class="number">0.14f</span>;</span><br><span class="line">  float3 encode_color = <span class="built_in">saturate</span>((x*(a*x + b)) / (x*(c*x + d) + e));</span><br><span class="line">  <span class="keyword">return</span> encode_color;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="宏开关"><a href="#宏开关" class="headerlink" title="宏开关"></a>宏开关</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Properties</span></span><br><span class="line">[<span class="built_in">Toggle</span>(_D_ok)] _DiffuseCheck(<span class="string">&quot;_DiffuseCheck&quot;</span>,Float) = <span class="number">1.0</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//Pass</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> shader_feature _D_ok;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _D_ok</span></span><br><span class="line">    one</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    two</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>或者把</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> shader_feature _D_ok;</span></span><br></pre></td></tr></table></figure>

<p>换成</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> multi_compile _D_ok;</span></span><br></pre></td></tr></table></figure>

<h1 id="人物代码"><a href="#人物代码" class="headerlink" title="人物代码"></a>人物代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Human&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Diffuse(<span class="string">&quot;Diffuse&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Normal(<span class="string">&quot;Normal&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;bump&quot;</span> &#123;&#125;</span><br><span class="line">        _NormalIntensity(<span class="string">&quot;Normal Intensity&quot;</span>, Float) = <span class="number">1.0</span></span><br><span class="line">        _Combmap(<span class="string">&quot;Combmap&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;black&quot;</span> &#123;&#125;</span><br><span class="line">        _SSSTrick(<span class="string">&quot;SSSTrick&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;black&quot;</span> &#123;&#125;</span><br><span class="line">        _CurveOffset(<span class="string">&quot;Curve Offset&quot;</span>, <span class="built_in">Range</span>(<span class="number">-1</span>,<span class="number">1</span>)) = <span class="number">1.0</span></span><br><span class="line">        _LUTOffset(<span class="string">&quot;LUT Offset&quot;</span>, <span class="built_in">Range</span>(<span class="number">-1</span>,<span class="number">1</span>)) = <span class="number">1.0</span></span><br><span class="line">        _SpecShininess(<span class="string">&quot;Spec Shininess&quot;</span>, Float) = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">        _EnvMap(<span class="string">&quot;EnvMap&quot;</span>, Cube) = <span class="string">&quot;black&quot;</span> &#123;&#125;</span><br><span class="line">        _Expose(<span class="string">&quot;Expose&quot;</span>, Float) = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">        [HideInInspector]<span class="built_in">custom_SHAr</span>(<span class="string">&quot;Custom SHAr&quot;</span>, Vector) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        [HideInInspector]<span class="built_in">custom_SHAg</span>(<span class="string">&quot;Custom SHAg&quot;</span>, Vector) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        [HideInInspector]<span class="built_in">custom_SHAb</span>(<span class="string">&quot;Custom SHAb&quot;</span>, Vector) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        [HideInInspector]<span class="built_in">custom_SHBr</span>(<span class="string">&quot;Custom SHBr&quot;</span>, Vector) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        [HideInInspector]<span class="built_in">custom_SHBg</span>(<span class="string">&quot;Custom SHBg&quot;</span>, Vector) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        [HideInInspector]<span class="built_in">custom_SHBb</span>(<span class="string">&quot;Custom SHBb&quot;</span>, Vector) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        [HideInInspector]<span class="built_in">custom_SHC</span>(<span class="string">&quot;Custom SHC&quot;</span>, Vector) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">           Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span> &#125;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdbase</span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AutoLight.cginc&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">            <span class="keyword">struct</span> appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 normal:NORMAL;</span><br><span class="line">                float4 tangent:TANGENT;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">v2f</span></span><br><span class="line">            &#123;</span><br><span class="line">                float2 texcoord : TEXCOORD0;</span><br><span class="line">                </span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 normal_world:TEXCOORD1;</span><br><span class="line">                float3 binormal_world:TEXCOORD2;</span><br><span class="line">                float3 tangent_world:TEXCOORD3;</span><br><span class="line">                float3 pos_world:TEXCOORD4;</span><br><span class="line">                <span class="built_in">LIGHTING_COORDS</span>(<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            sampler2D _Diffuse;</span><br><span class="line">            float4 _Diffuse_ST;</span><br><span class="line">            sampler2D _Normal;</span><br><span class="line">            <span class="type">float</span> _NormalIntensity;</span><br><span class="line">            <span class="type">float</span> _SpecShininess;</span><br><span class="line">            <span class="type">float</span> _Expose;</span><br><span class="line">            float4 _LightColor0;</span><br><span class="line">            sampler2D _Combmap;</span><br><span class="line">            sampler2D _SSSTrick;</span><br><span class="line">            </span><br><span class="line">            samplerCUBE _EnvMap;</span><br><span class="line">            float4 _EnvMap_HDR;</span><br><span class="line">            <span class="type">float</span> _CurveOffset;</span><br><span class="line">            <span class="type">float</span> _LUTOffset;</span><br><span class="line">            </span><br><span class="line">            float4 custom_SHAr;</span><br><span class="line">            float4 custom_SHAg;</span><br><span class="line">            float4 custom_SHAb;</span><br><span class="line">            float4 custom_SHBr;</span><br><span class="line">            float4 custom_SHBg;</span><br><span class="line">            float4 custom_SHBb;</span><br><span class="line">            float4 custom_SHC;</span><br><span class="line">            <span class="function">float3 <span class="title">SH</span><span class="params">(half3 normal_dir)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                float4 normalForSH = <span class="built_in">float4</span>(normal_dir, <span class="number">1.0</span>);</span><br><span class="line">                <span class="comment">//SHEvalLinearL0L1</span></span><br><span class="line">                half3 x;</span><br><span class="line">                x.r = <span class="built_in">dot</span>(custom_SHAr, normalForSH);</span><br><span class="line">                x.g = <span class="built_in">dot</span>(custom_SHAg, normalForSH);</span><br><span class="line">                x.b = <span class="built_in">dot</span>(custom_SHAb, normalForSH);</span><br><span class="line">                <span class="comment">//SHEvalLinearL2</span></span><br><span class="line">                half3 x1, x2;</span><br><span class="line">                <span class="comment">// 4 of the quadratic (L2) polynomials</span></span><br><span class="line">                half4 vB = normalForSH.xyzz * normalForSH.yzzx;</span><br><span class="line">                x1.r = <span class="built_in">dot</span>(custom_SHBr, vB);</span><br><span class="line">                x1.g = <span class="built_in">dot</span>(custom_SHBg, vB);</span><br><span class="line">                x1.b = <span class="built_in">dot</span>(custom_SHBb, vB);</span><br><span class="line">                <span class="comment">// Final (5th) quadratic (L2) polynomial</span></span><br><span class="line">                half vC = normalForSH.x*normalForSH.x - normalForSH.y*normalForSH.y;</span><br><span class="line">                x2 = custom_SHC.rgb * vC;</span><br><span class="line">                float3 sh = <span class="built_in">max</span>(<span class="built_in">float3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>), (x + x1 + x2));</span><br><span class="line">                sh = <span class="built_in">pow</span>(sh, <span class="number">1.0</span> / <span class="number">2.2</span>);</span><br><span class="line">                <span class="keyword">return</span> sh;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="function">v2f <span class="title">vert</span> <span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = <span class="built_in">UnityObjectToClipPos</span>(v.vertex);</span><br><span class="line">                o.texcoord =v.uv;</span><br><span class="line">                o.normal_world = <span class="built_in">normalize</span>(<span class="built_in">mul</span>(<span class="built_in">float4</span>(v.normal,<span class="number">0.0</span>),unity_WorldToObject)).xyz;</span><br><span class="line">                o.tangent_world = <span class="built_in">normalize</span>(<span class="built_in">mul</span>(unity_ObjectToWorld,<span class="built_in">float4</span>(v.tangent.xyz,<span class="number">0.0</span>)));</span><br><span class="line">                o.pos_world = <span class="built_in">normalize</span>(<span class="built_in">mul</span>(unity_ObjectToWorld,<span class="built_in">float4</span>(v.vertex.xyz,<span class="number">0.0</span>)));</span><br><span class="line">                o.binormal_world =<span class="built_in">normalize</span>(<span class="built_in">cross</span>(o.normal_world,o.tangent_world)*v.tangent.w);</span><br><span class="line">                <span class="built_in">TRANSFER_VERTEX_TO_FRAGMENT</span>(o);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span> <span class="params">(v2f i)</span> : SV_Target</span></span><br><span class="line"><span class="function">            &#123;</span></span><br><span class="line">                half atten = <span class="built_in">LIGHT_ATTENUATION</span> (i);</span><br><span class="line">                fixed4 col = <span class="built_in">fixed4</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">                fixed3 albedo = <span class="built_in">tex2D</span>(_Diffuse, i.texcoord).xyz;</span><br><span class="line">                fixed3 comb_map = <span class="built_in">tex2D</span>(_Combmap, i.texcoord).xyz;</span><br><span class="line">                </span><br><span class="line">                half metal = comb_map.g;</span><br><span class="line">                fixed3 base_col =albedo * (<span class="number">1</span>-metal);</span><br><span class="line">                fixed3 spec_color = <span class="built_in">lerp</span>(<span class="number">0.04</span>,albedo,metal);</span><br><span class="line"></span><br><span class="line">                half3 normal_dir    = <span class="built_in">normalize</span>(i.normal_world);</span><br><span class="line">                half3 pos_world    = <span class="built_in">normalize</span>(i.pos_world);</span><br><span class="line">                half3 tangent_dir   = <span class="built_in">normalize</span>(i.tangent_world)*_NormalIntensity;</span><br><span class="line">                half3 binormal_dir  = <span class="built_in">normalize</span>(i.binormal_world)*_NormalIntensity;</span><br><span class="line">                half4 normalmap= <span class="built_in">tex2D</span>(_Normal,i.texcoord);</span><br><span class="line">                half3 normal_data = <span class="built_in">UnpackNormal</span>( normalmap);</span><br><span class="line">                float3x3 TBN = <span class="built_in">float3x3</span>(tangent_dir,binormal_dir,normal_dir);</span><br><span class="line">                normal_dir = <span class="built_in">normalize</span>(<span class="built_in">mul</span>(normal_data,TBN));</span><br><span class="line"></span><br><span class="line">                half3 view_dir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz-pos_world);</span><br><span class="line">                half3 light_dir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//直接光漫反射</span></span><br><span class="line"></span><br><span class="line">                half diffuse_term = <span class="built_in">max</span>(<span class="built_in">dot</span>(normal_dir,light_dir),<span class="number">0</span>);</span><br><span class="line">                half3 comm_diffuse = diffuse_term*base_col*atten*_LightColor0.xyz;</span><br><span class="line">                half half_lambert = (diffuse_term+<span class="number">1.0</span>)*<span class="number">0.5</span>;</span><br><span class="line">                half skin_area  = <span class="number">1</span>- comb_map.b;</span><br><span class="line">                half2 uv_lut = <span class="built_in">float2</span>(<span class="built_in">min</span>(<span class="number">1</span>, diffuse_term*atten  +_LUTOffset),_CurveOffset);</span><br><span class="line">                half3 lut_color = <span class="built_in">tex2D</span>(_SSSTrick,uv_lut);</span><br><span class="line">                half3 sss_diffuse = lut_color *base_col*_LightColor0.xyz* half_lambert;</span><br><span class="line">                half3 diffuse = <span class="built_in">lerp</span>(comm_diffuse,sss_diffuse,skin_area);</span><br><span class="line">                col.xyz+=diffuse;</span><br><span class="line">              <span class="comment">//直接光镜面反射</span></span><br><span class="line">               half3 half_dir =<span class="built_in">normalize</span>( light_dir+view_dir);</span><br><span class="line">               half roughness = comb_map.r;</span><br><span class="line">               half smoothness = <span class="number">1.0</span>-roughness;</span><br><span class="line">               half shininess = <span class="built_in">lerp</span>(<span class="number">1.0</span>,_SpecShininess,smoothness);</span><br><span class="line">               half reflect_term = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">dot</span>(normal_dir,half_dir)),shininess);</span><br><span class="line">               half3 specular = reflect_term *  spec_color*atten*_LightColor0.xyz;</span><br><span class="line">               col.xyz+=specular;</span><br><span class="line">               <span class="comment">//间接光照</span></span><br><span class="line">               </span><br><span class="line">               half3 env_diffuse = <span class="built_in">SH</span>(normal_dir)*base_col*half_lambert; </span><br><span class="line">               <span class="comment">// sample the texture</span></span><br><span class="line">               col.xyz+=env_diffuse;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//间接镜面反射</span></span><br><span class="line">               roughness=roughness*(<span class="number">1.7</span><span class="number">-0.7</span>*roughness);</span><br><span class="line">               half mip_level = roughness*<span class="number">6.0</span>;</span><br><span class="line">               half4 Cube_col=<span class="built_in">texCUBElod</span>(_EnvMap,<span class="built_in">float4</span>(half_dir,mip_level));</span><br><span class="line">               half3 EnvHDR_col=<span class="built_in">DecodeHDR</span>(Cube_col,_EnvMap_HDR);</span><br><span class="line">               half3 env_specular = EnvHDR_col *spec_color*half_lambert*_Expose;</span><br><span class="line">               col.xyz+=env_specular;</span><br><span class="line">               col.xyz*=<span class="number">0.8</span>;</span><br><span class="line">               <span class="keyword">return</span> col;</span><br><span class="line">              <span class="comment">// return fixed4(diffuse,1.0);</span></span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="头发代码"><a href="#头发代码" class="headerlink" title="头发代码"></a>头发代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Hair&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Diffuse(<span class="string">&quot;Diffuse&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _DiffuseColor(<span class="string">&quot;Diffuse Color&quot;</span>, Color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        _Normal(<span class="string">&quot;Normal&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;bump&quot;</span> &#123;&#125;</span><br><span class="line">        _NormalIntensity(<span class="string">&quot;Normal Intensity&quot;</span>, Float) = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">        _AnoiseMap(<span class="string">&quot;AnoiseMap&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;gray&quot;</span> &#123;&#125;</span><br><span class="line">        _SpecularColor1(<span class="string">&quot;Specular Color1&quot;</span>, Color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        _SpecShininess1(<span class="string">&quot;Spec Shininess1&quot;</span>, Float) = <span class="number">1.0</span></span><br><span class="line">        _Shiftoffset1 (<span class="string">&quot;Shift offset1&quot;</span>, <span class="built_in">Range</span>(<span class="number">-10</span>,<span class="number">10</span>)) = <span class="number">1.0</span></span><br><span class="line">        _SpecNoise1 (<span class="string">&quot;Spec Noise1&quot;</span>, Float) = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">        _SpecularColor2(<span class="string">&quot;Specular Color2&quot;</span>, Color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        _SpecShininess2(<span class="string">&quot;Spec Shininess2&quot;</span>, Float) = <span class="number">1.0</span></span><br><span class="line">        _Shiftoffset2 (<span class="string">&quot;Shift offset2&quot;</span>, <span class="built_in">Range</span>(<span class="number">-10</span>,<span class="number">10</span>)) = <span class="number">1.0</span></span><br><span class="line">        _SpecNoise2 (<span class="string">&quot;Spec Noise2&quot;</span>, Float) = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">        _EnvMap(<span class="string">&quot;EnvMap&quot;</span>, Cube) = <span class="string">&quot;black&quot;</span> &#123;&#125;</span><br><span class="line">        _Expose(<span class="string">&quot;Expose&quot;</span>, Float) = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">           Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span> &#125;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdbase</span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AutoLight.cginc&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 normal:NORMAL;</span><br><span class="line">                float4 tangent:TANGENT;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">v2f</span></span><br><span class="line">            &#123;</span><br><span class="line">                float2 texcoord : TEXCOORD0;</span><br><span class="line">                </span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 normal_world:TEXCOORD1;</span><br><span class="line">                float3 binormal_world:TEXCOORD2;</span><br><span class="line">                float3 tangent_world:TEXCOORD3;</span><br><span class="line">                float3 pos_world:TEXCOORD4;</span><br><span class="line">                <span class="built_in">LIGHTING_COORDS</span>(<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _Diffuse;</span><br><span class="line">            float4 _Diffuse_ST;</span><br><span class="line">            sampler2D _Normal;</span><br><span class="line">            <span class="type">float</span> _NormalIntensity;</span><br><span class="line">            <span class="type">float</span> _SpecShininess;</span><br><span class="line">            <span class="type">float</span> _Expose;</span><br><span class="line">            float4 _LightColor0;</span><br><span class="line">            float4 _DiffuseColor;</span><br><span class="line">            </span><br><span class="line">            samplerCUBE _EnvMap;</span><br><span class="line">            float4 _EnvMap_HDR;</span><br><span class="line">            <span class="type">float</span> _CurveOffset;</span><br><span class="line">            <span class="type">float</span> _LUTOffset;</span><br><span class="line"></span><br><span class="line">            sampler2D _AnoiseMap;</span><br><span class="line">            float4 _AnoiseMap_ST;</span><br><span class="line">            float4 _SpecularColor1;</span><br><span class="line">            <span class="type">float</span> _SpecShininess1;</span><br><span class="line">            <span class="type">float</span> _Shiftoffset1 ;</span><br><span class="line">            <span class="type">float</span> _SpecNoise1 ;</span><br><span class="line"></span><br><span class="line">            float4 _SpecularColor2;</span><br><span class="line">            <span class="type">float</span> _SpecShininess2;</span><br><span class="line">            <span class="type">float</span> _Shiftoffset2 ;</span><br><span class="line">            <span class="type">float</span> _SpecNoise2 ;</span><br><span class="line">            </span><br><span class="line">             <span class="function">v2f <span class="title">vert</span> <span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = <span class="built_in">UnityObjectToClipPos</span>(v.vertex);</span><br><span class="line">                o.texcoord =v.uv;</span><br><span class="line">                o.normal_world = <span class="built_in">normalize</span>(<span class="built_in">mul</span>(<span class="built_in">float4</span>(v.normal,<span class="number">0.0</span>),unity_WorldToObject)).xyz;</span><br><span class="line">                o.tangent_world = <span class="built_in">normalize</span>(<span class="built_in">mul</span>(unity_ObjectToWorld,<span class="built_in">float4</span>(v.tangent.xyz,<span class="number">0.0</span>)));</span><br><span class="line">                o.pos_world = <span class="built_in">normalize</span>(<span class="built_in">mul</span>(unity_ObjectToWorld,<span class="built_in">float4</span>(v.vertex.xyz,<span class="number">0.0</span>)));</span><br><span class="line">                o.binormal_world =<span class="built_in">normalize</span>(<span class="built_in">cross</span>(o.normal_world,o.tangent_world)*v.tangent.w);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//o.texcoord = TRANSFORM_TEX(v.uv, _MainTex);</span></span><br><span class="line">                <span class="built_in">TRANSFER_VERTEX_TO_FRAGMENT</span>(o);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span> <span class="params">(v2f i)</span> : SV_Target</span></span><br><span class="line"><span class="function">            &#123;</span></span><br><span class="line">            </span><br><span class="line">                </span><br><span class="line">                half atten = <span class="built_in">LIGHT_ATTENUATION</span> (i);</span><br><span class="line">                fixed4 col = <span class="built_in">fixed4</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">                fixed3 albedo = <span class="built_in">tex2D</span>(_Diffuse, i.texcoord).xyz*_DiffuseColor;</span><br><span class="line">                </span><br><span class="line">                fixed3 base_col =albedo ;</span><br><span class="line">                fixed3 spec_color =albedo ;</span><br><span class="line"></span><br><span class="line">                half3 normal_dir    = <span class="built_in">normalize</span>(i.normal_world);</span><br><span class="line">                half3 pos_world    = <span class="built_in">normalize</span>(i.pos_world);</span><br><span class="line">                half3 tangent_dir   = <span class="built_in">normalize</span>(i.tangent_world)*_NormalIntensity;</span><br><span class="line">                half3 binormal_dir  = <span class="built_in">normalize</span>(i.binormal_world)*_NormalIntensity;</span><br><span class="line">                half4 normalmap= <span class="built_in">tex2D</span>(_Normal,i.texcoord);</span><br><span class="line">                half3 normal_data = <span class="built_in">UnpackNormal</span>( normalmap);</span><br><span class="line">                float3x3 TBN = <span class="built_in">float3x3</span>(tangent_dir,binormal_dir,normal_dir);</span><br><span class="line">                normal_dir = <span class="built_in">normalize</span>(<span class="built_in">mul</span>(normal_data,TBN));</span><br><span class="line"></span><br><span class="line">                half3 view_dir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz-pos_world);</span><br><span class="line">                half3 light_dir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//直接光漫反射</span></span><br><span class="line">               </span><br><span class="line">                half diffuse_term = <span class="built_in">max</span>(<span class="built_in">dot</span>(normal_dir,light_dir),<span class="number">0</span>);</span><br><span class="line">                half half_lambert = (diffuse_term+<span class="number">1.0</span>)*<span class="number">0.5</span>;</span><br><span class="line">                half3 comm_diffuse = diffuse_term*base_col*atten*_LightColor0.xyz;</span><br><span class="line">                half3 diffuse = comm_diffuse;</span><br><span class="line">                </span><br><span class="line">                col.xyz+=diffuse;</span><br><span class="line">              <span class="comment">//直接光镜面反射</span></span><br><span class="line">               half roughness = <span class="number">0.2</span>;</span><br><span class="line">               half3 half_dir =<span class="built_in">normalize</span>( light_dir+view_dir);</span><br><span class="line">               half2 uv_Anoise = i.texcoord*_AnoiseMap_ST.xy+_AnoiseMap_ST.zw;</span><br><span class="line">               half3 aniso_noise = <span class="built_in">tex2D</span>(_AnoiseMap,uv_Anoise);</span><br><span class="line"></span><br><span class="line">               half NdotH = <span class="built_in">dot</span>(normal_dir,half_dir);</span><br><span class="line">               half TdotH = <span class="built_in">dot</span>(tangent_dir,half_dir);</span><br><span class="line"></span><br><span class="line">               half NdotV = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(normal_dir,view_dir));</span><br><span class="line">               half aniso_atten = <span class="built_in">saturate</span>(<span class="built_in">sqrt</span>(<span class="built_in">max</span>(<span class="number">0</span>,half_lambert/NdotV)))*atten;</span><br><span class="line">               <span class="comment">//spec1</span></span><br><span class="line">               half3 specular_color1 = _SpecularColor1 + base_col;</span><br><span class="line">               half3 aniso_offset1 = normal_dir *(aniso_noise*_SpecNoise1+_Shiftoffset1);</span><br><span class="line">               half3 binormal_dir1 = <span class="built_in">normalize</span>(binormal_dir + aniso_offset1);</span><br><span class="line">               half BdotH1 = <span class="built_in">dot</span>(binormal_dir1,half_dir)/ _SpecShininess1;</span><br><span class="line">               half3 specular_term1 = <span class="built_in">exp</span>(-(TdotH*TdotH+BdotH1*BdotH1)/(<span class="number">1.0</span>+NdotH));</span><br><span class="line">               half3 specular1 = specular_term1*aniso_atten*specular_color1*_LightColor0.xyz;</span><br><span class="line">               </span><br><span class="line">               half3 specular_color2 = _SpecularColor2 + base_col;</span><br><span class="line">               half3 aniso_offset2 = normal_dir *(aniso_noise*_SpecNoise2+_Shiftoffset2);</span><br><span class="line">               half3 binormal_dir2 = <span class="built_in">normalize</span>(binormal_dir + aniso_offset2);</span><br><span class="line">               half BdotH2 = <span class="built_in">dot</span>(binormal_dir2,half_dir)/ _SpecShininess2;</span><br><span class="line">               half3 specular_term2 = <span class="built_in">exp</span>(-(TdotH*TdotH+BdotH2*BdotH2)/(<span class="number">1.0</span>+NdotH));</span><br><span class="line">               half3 specular2 = specular_term2*aniso_atten*specular_color2*_LightColor0.xyz;</span><br><span class="line">               half3 specular = specular1+specular2;</span><br><span class="line">               col.xyz+=specular;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">//间接镜面反射</span></span><br><span class="line">               roughness=roughness*(<span class="number">1.7</span><span class="number">-0.7</span>*roughness);</span><br><span class="line">               half mip_level = roughness*<span class="number">6.0</span>;</span><br><span class="line">               half4 Cube_col=<span class="built_in">texCUBElod</span>(_EnvMap,<span class="built_in">float4</span>(half_dir,mip_level));</span><br><span class="line">               half3 EnvHDR_col=<span class="built_in">DecodeHDR</span>(Cube_col,_EnvMap_HDR);</span><br><span class="line">               half3 env_specular = EnvHDR_col *spec_color*half_lambert*_Expose;</span><br><span class="line">               col.xyz+=env_specular;</span><br><span class="line">               <span class="comment">//return col;</span></span><br><span class="line">               <span class="keyword">return</span> <span class="built_in">fixed4</span>(specular,<span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>人物3渲2学习总结</title>
    <url>/2022/05/11/%E4%BA%BA%E7%89%A93%E6%B8%B22%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="描边"><a href="#描边" class="headerlink" title="描边"></a>描边</h1><h2 id="法线外扩法"><a href="#法线外扩法" class="headerlink" title="法线外扩法"></a>法线外扩法</h2><p>中文一般称为“法线外扩法”、“背面膨胀法”，日文资料中会称作「背面法」，它们指的是同一个技术</p>
<h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><p>第一个Pass：正常打光和绘制<br>第二个Pass：</p>
<p>Vertex Shader阶段将顶点向顶点法线方向移动一定距离<br>Rasterization阶段将Cull Mode设置为Cull Front</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">Name <span class="string">&quot;OUTLINE&quot;</span></span><br><span class="line">Cull Front</span><br><span class="line">ZWrite On</span><br><span class="line">ColorMask RGB</span><br><span class="line">Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">    CGPROGRAM</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">appdata</span> &#123;</span><br><span class="line">        float4 vertex : POSITION;</span><br><span class="line">        float3 normal : NORMAL;</span><br><span class="line">        float4 texCoord : TEXCOORD0;</span><br><span class="line">        float4 vertexColor : COLOR;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">v2f</span> &#123;</span><br><span class="line">      float4 pos : POSITION;</span><br><span class="line">      float4 color : COLOR;</span><br><span class="line">      float4 tex : TEXCOORD0;</span><br><span class="line">    &#125;;</span><br><span class="line">    sampler2D _MainTex;</span><br><span class="line">    <span class="type">float</span> _Outline;</span><br><span class="line">    float4 _OutlineColor;</span><br><span class="line">    <span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// just make a copy of incoming vertex data but scaled according to normal direction</span></span><br><span class="line">      v2f o;</span><br><span class="line">      o.pos = <span class="built_in">UnityObjectToClipPos</span>(v.vertex);</span><br><span class="line">        float3 norm = <span class="built_in">mul</span>((float3x3)UNITY_MATRIX_IT_MV, v.normal);</span><br><span class="line">        float2 offset = <span class="built_in">TransformViewToProjection</span>(norm.xy);</span><br><span class="line">       <span class="comment">// float2 offset = (norm.xy);</span></span><br><span class="line">      o.pos.xy += offset * _Outline*<span class="number">0.0001</span>;</span><br><span class="line">      o.tex = v.texCoord;</span><br><span class="line">      o.color = v.vertexColor;</span><br><span class="line">      <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">fixed4 <span class="title">frag</span> <span class="params">(v2f i)</span> : SV_Target</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        half4 base_col = <span class="built_in">tex2D</span>(_MainTex,i.tex);</span><br><span class="line">        <span class="keyword">return</span> _OutlineColor*base_col;</span><br><span class="line">    &#125;</span><br><span class="line">    ENDCG</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>描边出现断裂，或者出现了看起来很奇怪的描边<br><img src="https://img-blog.csdnimg.cn/15c86e7c8bef4fc4aa24ece0905fae53.png" alt="在这里插入图片描述"><br>解决方案：用法线刷修改顶点让顶点平滑，出现这个问题的原因是每个面的法线都是垂直于平面的，所以在边角处就连接不上了。一般这种问题的解决方案是另外存储一套平滑法线。具体做法是计算与该点位置相同的所有点的法线的平均值并存储在顶点上。</li>
<li>描边线条控制<br>想眼睛，头发这种细节描边需要修正的<br>头发，由于模型的复杂性，在使用法线外扩法时往往会出现不太想要的描边。为了防止出现这些不受欢迎的描边，可以给每个顶点设置一个深度值、将顶点埋进里面从而被遮挡住。《罪恶装备Xrd》里就将这个信息写入了顶点色B通道中。<br>细节：由于法线外扩法是基于模型的，所以实际上对线条还是有较高的自由度来控制。如果想要做到有粗细变化的描边，可以参考罪恶装备Xrd中将粗细变化的数值写入顶点色当中。实际上就是一个外扩系数：数值越大，越向外扩，线条越粗。至于线条的颜色，如果顶点色或者其他UV通道够用，可以将描边颜色写进顶点里面。然后相乘。<h2 id="菲涅尔方程"><a href="#菲涅尔方程" class="headerlink" title="菲涅尔方程"></a>菲涅尔方程</h2><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3>N*V<br>适用于球形物体的描边<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3>但平面时不好控制轮廓线<h2 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h2>blender  的Freestyle<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3>他们首先通过预处理的方式提取那些感兴趣的边缘，保存到额外的Mesh资源上。在渲染时通过Geometry Shader将这些边缘绘制出来。<br>出于性能跟兼容性问题还是尽量避免使用Geometry Shader的好。但是这种思路还是非常不错的，因为这种方式对线条的控制也有很高的自由度，并且相比起法线外扩法可以创造更多细节。而且目前Compute Shader已经相当成熟且普及了，所以考虑用Compute Shader＋软光栅的方式说不定也是一条走得通的道路。<h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3>颜色不能自定义，塞到顶点色里面，而且性价比不高。<h2 id="基于图像空间的线条检测"><a href="#基于图像空间的线条检测" class="headerlink" title="基于图像空间的线条检测"></a>基于图像空间的线条检测</h2></li>
</ol>
<p><a href="https://game.academy.163.com/course/careerArticle?course=771">参考文章</a><br>通过检测场景图像中 Normal 和 Depth 的不连续性，我们可以获得细节较为丰富的勾线。无论场景的复杂性如何，这种方法的性能都是恒定的，我们还添加了对勾线颜色的色相、明度、饱和度的调整，使勾线更为自然。<br><img src="https://img-blog.csdnimg.cn/3c57005ad1a741d29931a3e186cd7ffe.png" alt="在这里插入图片描述"></p>
<p>常用的算法是Sobel算子<br>缺点则是较难控制勾线的宽度，如果我们想实现距离相关的线宽，我们只能在几个像素的范围内调整它，因此基于图像的方法主要适用于场景线条渲染，对于靠近摄像头很近的物体，我们最好使用 Backface 的方法。<br><img src="https://img-blog.csdnimg.cn/6f6b3473bb4b4711b738976dfeec81d3.png" alt="在这里插入图片描述"><br><a href="https://game.academy.163.com/course/careerArticle?course=522">看这里实现方式</a></p>
<h2 id="对于后处理进行canny卷积"><a href="#对于后处理进行canny卷积" class="headerlink" title="对于后处理进行canny卷积"></a>对于后处理进行canny卷积</h2><p>我卷失败了，没卷出来以后有时间再搞。<br>和上一方法有异曲同工之处。<br>转化为灰度图进行canny卷积</p>
<h1 id="打光"><a href="#打光" class="headerlink" title="打光"></a>打光</h1><h2 id="皮肤和衣服部分"><a href="#皮肤和衣服部分" class="headerlink" title="皮肤和衣服部分"></a>皮肤和衣服部分</h2><h3 id="多通道Ramp的shading方法"><a href="#多通道Ramp的shading方法" class="headerlink" title="多通道Ramp的shading方法"></a>多通道Ramp的shading方法</h3><p> <img src="https://img-blog.csdnimg.cn/img_convert/5498cba268da6539c44be4ea58fbdf47.png" alt="T_SpecularRamp1.png"><br><img src="https://img-blog.csdnimg.cn/d90f24dfc2e34d13b9e6de9c073f5586.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/cec471392ce64025a360a5ff3f6f5195.png" alt="在这里插入图片描述"><br>采用多层上色，我的效果好拉，没官方好看。</p>
<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>RampLayerSoftness越大越软阴影，小则硬<br>我没将_TintBase 叠加上去<br>我没加阴影是因为，当阴影加上后会映在人身上看起来就不二次元了。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Properties :</span><br><span class="line">    [<span class="built_in">Header</span>(Tint Base)]</span><br><span class="line">    _DiffuseRamp (<span class="string">&quot;DiffuseRamp&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;Black&quot;</span> &#123;&#125;</span><br><span class="line">        _SpecularRamp (<span class="string">&quot;SpecularRamp&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;Black&quot;</span> &#123;&#125;</span><br><span class="line">        _TintBase (<span class="string">&quot;Tint Base&quot;</span>, COLOR) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        [<span class="built_in">Header</span>(RampLayer1)]</span><br><span class="line">        _RampLayerOffset1 (<span class="string">&quot;RampLayerOffset1&quot;</span>, <span class="built_in">Range</span>(<span class="number">-0.5</span>,<span class="number">0.5</span>)) = <span class="number">0.5</span></span><br><span class="line">        _TintLayer1 (<span class="string">&quot;Tint_Layer1&quot;</span>, COLOR) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        [<span class="built_in">Header</span>(RampLayer2)]</span><br><span class="line">        _RampLayerOffset2 (<span class="string">&quot;RampLayerOffset2&quot;</span>, <span class="built_in">Range</span>(<span class="number">-0.5</span>,<span class="number">0.5</span>)) = <span class="number">0.5</span></span><br><span class="line">        _RampLayerSoftness2 (<span class="string">&quot;RampLayerSoftness2&quot;</span>, <span class="built_in">Range</span>(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">        __TintLayer2 (<span class="string">&quot;Tint Layer2&quot;</span>, COLOR) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        [<span class="built_in">Header</span>(RampLayer3)]</span><br><span class="line">        _RampLayerOffset3 (<span class="string">&quot;RampLayerOffset3&quot;</span>, <span class="built_in">Range</span>(<span class="number">-0.5</span>,<span class="number">0.5</span>)) = <span class="number">0.5</span></span><br><span class="line">        _RampLayerSoftness3 (<span class="string">&quot;RampLayerSoftness3&quot;</span>, <span class="built_in">Range</span>(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">        __TintLayer3 (<span class="string">&quot;Tint Layer3&quot;</span>, COLOR) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        [<span class="built_in">Header</span>(Specular)]</span><br><span class="line">         _Shineness (<span class="string">&quot;Shineness&quot;</span>, Float) = <span class="number">0.5</span></span><br><span class="line">         _SpecularColor (<span class="string">&quot;Specular Color&quot;</span>, COLOR) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">         _SpecularIntensity (<span class="string">&quot;SpecularIntensity&quot;</span>, Float) = <span class="number">1</span></span><br><span class="line">         _SpecularSmooth (<span class="string">&quot;Specular Smooth&quot;</span>, Float) = <span class="number">1</span></span><br><span class="line">Pass :</span><br><span class="line">      sampler2D _DiffuseRamp;</span><br><span class="line">          sampler2D _SpecularRamp;</span><br><span class="line">            float4 _TintBase;</span><br><span class="line">            float4 __TintLayer1;</span><br><span class="line">            <span class="type">float</span> _RampLayerOffset1;</span><br><span class="line"></span><br><span class="line">            float4 __TintLayer2;</span><br><span class="line">            <span class="type">float</span> _RampLayerOffset2;</span><br><span class="line">            <span class="type">float</span> _RampLayerSoftness2;</span><br><span class="line">            </span><br><span class="line">            float4 __TintLayer3;</span><br><span class="line">            <span class="type">float</span> _RampLayerOffset3;</span><br><span class="line">            <span class="type">float</span> _RampLayerSoftness3;</span><br><span class="line"></span><br><span class="line">            <span class="type">float</span> _Shineness;</span><br><span class="line">            <span class="type">float</span> _SpecularIntensity;</span><br><span class="line">            float4 _SpecularColor;</span><br><span class="line">            <span class="type">float</span> _SpecularSmooth;</span><br><span class="line">frag :</span><br><span class="line">        half atten = <span class="built_in">LIGHT_ATTENUATION</span> (i);</span><br><span class="line">                half3 base_col = <span class="built_in">tex2D</span>(_MainTex, i.uv).xyz;</span><br><span class="line">                half3 normal_world= <span class="built_in">normalize</span>(i.normalDir);</span><br><span class="line">                half3 tangent_world= <span class="built_in">normalize</span>(i.tangentDir);</span><br><span class="line">                half3 binormal_world= <span class="built_in">normalize</span>(i.binormalDir);</span><br><span class="line">                half3 pos_world= <span class="built_in">normalize</span>(i.pos_world);</span><br><span class="line">                half3 normal_data = <span class="built_in">UnpackNormal</span>(<span class="built_in">tex2D</span>(_Normal,i.uv));</span><br><span class="line">                half3x3 TBN = <span class="built_in">half3x3</span> (tangent_world,binormal_world,normal_world);</span><br><span class="line">                </span><br><span class="line">                normal_world = <span class="built_in">mul</span>(normal_data,TBN);</span><br><span class="line">                half3 ViewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz-pos_world);</span><br><span class="line">                half3 lightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                <span class="comment">//漫反射</span></span><br><span class="line">                half NdotL =  <span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">dot</span>(normal_world,lightDir));</span><br><span class="line">                half half_lambert = (NdotL+<span class="number">1.0</span>)*<span class="number">0.5</span>;</span><br><span class="line">                <span class="comment">//half half_lambert = half_lambert*ao //本来要乘上AO因为素材没有算了</span></span><br><span class="line"></span><br><span class="line">                half3 tint_Base_color1 = base_col;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//第一层ramp</span></span><br><span class="line">                half2 uv_ramp1 = <span class="built_in">half2</span>(half_lambert+_RampLayerOffset1,<span class="number">0.5</span>);</span><br><span class="line">                half toon_diffuse1 = <span class="built_in">tex2D</span>(_DiffuseRamp,uv_ramp1).r;</span><br><span class="line">                half3 tint_color1 = <span class="built_in">lerp</span>(<span class="built_in">half3</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),__TintLayer1,toon_diffuse1*__TintLayer1.a);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//第二层ramp</span></span><br><span class="line">                half2 uv_ramp2 = <span class="built_in">half2</span>(half_lambert+_RampLayerOffset2,<span class="number">1</span>-i.VertexColor.g+_RampLayerSoftness2);<span class="comment">//1-i.VertexColor.g可以用_RampLayerSoftness2代替越大越柔和</span></span><br><span class="line">                half toon_diffuse2 = <span class="built_in">tex2D</span>(_DiffuseRamp,uv_ramp2).g;</span><br><span class="line">                half3 tint_color2 = <span class="built_in">lerp</span>(<span class="built_in">half3</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),__TintLayer2,toon_diffuse2*__TintLayer2.a);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//第三层ramp</span></span><br><span class="line">                half2 uv_ramp3 = <span class="built_in">half2</span>(half_lambert+_RampLayerOffset3,<span class="number">1</span>-i.VertexColor.b+_RampLayerSoftness3);<span class="comment">//1-i.VertexColor.b可以用_RampLayerSoftness3代替越大越柔和</span></span><br><span class="line">                half toon_diffuse3 = <span class="built_in">tex2D</span>(_DiffuseRamp,uv_ramp3).b;</span><br><span class="line">                half3 tint_color3 = <span class="built_in">lerp</span>(<span class="built_in">half3</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),__TintLayer3,toon_diffuse3*__TintLayer3.a);</span><br><span class="line">                </span><br><span class="line">                half3 final_diffuse = tint_Base_color1 * tint_color1 *tint_color2 *tint_color3  ;</span><br><span class="line">                <span class="comment">//高光</span></span><br><span class="line">                <span class="comment">//half3 half_R = normalize(lightDir+ViewDir);</span></span><br><span class="line">                half3 R = <span class="built_in">normalize</span>(<span class="built_in">reflect</span>(-lightDir,normal_world));</span><br><span class="line">                half specular_term = <span class="built_in">max</span>(<span class="built_in">pow</span>(<span class="built_in">dot</span>(R,ViewDir),_Shineness),<span class="number">0.0001</span>);<span class="comment">//本来要乘上AO因为素材没有算了</span></span><br><span class="line">                specular_term = <span class="built_in">smoothstep</span>(<span class="number">0.5</span>-_SpecularSmooth*<span class="number">0.5</span>,<span class="number">0.5</span>+_SpecularSmooth*<span class="number">0.5</span>,specular_term);<span class="comment">//风格化高光</span></span><br><span class="line">            </span><br><span class="line">                half3 final_specular = base_col  * specular_term *_SpecularColor *atten *_LightColor0.xyz *_SpecularIntensity  ;</span><br><span class="line">               half3 final_col = final_diffuse+final_specular ;</span><br></pre></td></tr></table></figure>

<h3 id="卖家秀"><a href="#卖家秀" class="headerlink" title="卖家秀"></a>卖家秀</h3><p><img src="https://img-blog.csdnimg.cn/0208c26a6f904323b643231225ead81a.png" alt="在这里插入图片描述"></p>
<h3 id="买家秀"><a href="#买家秀" class="headerlink" title="买家秀"></a>买家秀</h3><p><img src="https://img-blog.csdnimg.cn/48f78fef3cee4385902745f21bd42f3a.png" alt="在这里插入图片描述"></p>
<h3 id="边缘光，环境光"><a href="#边缘光，环境光" class="headerlink" title="边缘光，环境光"></a>边缘光，环境光</h3><p><img src="https://img-blog.csdnimg.cn/a2ed782f9f1d4108b0b154e904144cef.png" alt="在这里插入图片描述"></p>
<h4 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h4><p>_MatCap是我自己加上去的，有点多余</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Properties :</span><br><span class="line">    _MatCap (<span class="string">&quot;MatCap&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;Black&quot;</span> &#123;&#125;</span><br><span class="line">        _Envmap (<span class="string">&quot;Envmap&quot;</span>, Cube) = <span class="string">&quot;Black&quot;</span> &#123;&#125;</span><br><span class="line">        [<span class="built_in">Header</span>(Rim)]</span><br><span class="line">        _RimMin(<span class="string">&quot;RimMin&quot;</span>, <span class="built_in">Range</span>(<span class="number">-2</span>,<span class="number">2</span>)) = <span class="number">0.5</span></span><br><span class="line">        _RimMax(<span class="string">&quot;RimMax&quot;</span>, <span class="built_in">Range</span>(<span class="number">-2</span>,<span class="number">2</span>)) = <span class="number">0.5</span></span><br><span class="line">        _Roughness(<span class="string">&quot;Roughness&quot;</span>, Float) = <span class="number">0</span></span><br><span class="line">        _EnvIntensity(<span class="string">&quot;Env Intensity&quot;</span>, Float) = <span class="number">0</span></span><br><span class="line">pass :</span><br><span class="line">            sampler2D _MatCap;</span><br><span class="line">            samplerCUBE _Envmap;</span><br><span class="line">            <span class="type">float</span> _RimMax;</span><br><span class="line">            <span class="type">float</span> _RimMin;</span><br><span class="line">            <span class="type">float</span> _Roughness;</span><br><span class="line">            <span class="type">float</span> _EnvIntensity;</span><br><span class="line">            float4 _Envmap_HDR;</span><br><span class="line">frag :</span><br><span class="line">        <span class="comment">//边缘光,环境光</span></span><br><span class="line">                </span><br><span class="line">                half fresnel = <span class="number">1</span>- <span class="built_in">dot</span>(ViewDir,normal_world);</span><br><span class="line">                half rim = <span class="built_in">smoothstep</span>(_RimMin,_RimMax,fresnel);<span class="comment">//本来要乘上AO因为素材没有算了</span></span><br><span class="line">                half3 mc=<span class="built_in">tex2D</span>(_MatCap,fresnel.xx);</span><br><span class="line">                half3 r = <span class="built_in">reflect</span>(-ViewDir,normal_world);</span><br><span class="line">                half roughness = <span class="built_in">lerp</span>(<span class="number">0</span>,<span class="number">0.95</span>,<span class="built_in">saturate</span>(_Roughness));</span><br><span class="line">                roughness = roughness * (<span class="number">1.7</span><span class="number">-0.7</span>*roughness );</span><br><span class="line">                half mip_level = roughness * <span class="number">6.0</span>;</span><br><span class="line">                half4 color_cubemap = <span class="built_in">texCUBElod</span>(_Envmap,<span class="built_in">half4</span>(r,mip_level));</span><br><span class="line">                half3 color_env = <span class="built_in">DecodeHDR</span>(color_cubemap,_Envmap_HDR);</span><br><span class="line">                half3 final_env =color_env * rim * _EnvIntensity;</span><br></pre></td></tr></table></figure>
<h3 id="总体代码"><a href="#总体代码" class="headerlink" title="总体代码"></a>总体代码</h3><p>Character_Skin.shader</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Character/Skin&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;MainTex&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Normal(<span class="string">&quot;Normal&quot;</span>,<span class="number">2</span>D) = <span class="string">&quot;bump&quot;</span> &#123;&#125;</span><br><span class="line">        _DiffuseRamp (<span class="string">&quot;DiffuseRamp&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;Black&quot;</span> &#123;&#125;</span><br><span class="line">        _Envmap (<span class="string">&quot;Envmap&quot;</span>, Cube) = <span class="string">&quot;Black&quot;</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        [<span class="built_in">Header</span>(Tint Base)]</span><br><span class="line">        _TintBase (<span class="string">&quot;Tint Base&quot;</span>, COLOR) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        [<span class="built_in">Header</span>(RampLayer1)]</span><br><span class="line">        _RampLayerOffset1 (<span class="string">&quot;RampLayerOffset1&quot;</span>, <span class="built_in">Range</span>(<span class="number">-0.5</span>,<span class="number">0.5</span>)) = <span class="number">0.5</span></span><br><span class="line">        _TintLayer1 (<span class="string">&quot;Tint_Layer1&quot;</span>, COLOR) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        [<span class="built_in">Header</span>(RampLayer2)]</span><br><span class="line">        _RampLayerOffset2 (<span class="string">&quot;RampLayerOffset2&quot;</span>, <span class="built_in">Range</span>(<span class="number">-0.5</span>,<span class="number">0.5</span>)) = <span class="number">0.5</span></span><br><span class="line">        _RampLayerSoftness2 (<span class="string">&quot;RampLayerSoftness2&quot;</span>, <span class="built_in">Range</span>(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">        __TintLayer2 (<span class="string">&quot;Tint Layer2&quot;</span>, COLOR) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        [<span class="built_in">Header</span>(RampLayer3)]</span><br><span class="line">        _RampLayerOffset3 (<span class="string">&quot;RampLayerOffset3&quot;</span>, <span class="built_in">Range</span>(<span class="number">-0.5</span>,<span class="number">0.5</span>)) = <span class="number">0.5</span></span><br><span class="line">        _RampLayerSoftness3 (<span class="string">&quot;RampLayerSoftness3&quot;</span>, <span class="built_in">Range</span>(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">        __TintLayer3 (<span class="string">&quot;Tint Layer3&quot;</span>, COLOR) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        [<span class="built_in">Header</span>(Specular)]</span><br><span class="line">         _Shineness (<span class="string">&quot;Shineness&quot;</span>, Float) = <span class="number">0.5</span></span><br><span class="line">         _SpecularColor (<span class="string">&quot;Specular Color&quot;</span>, COLOR) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">         _SpecularIntensity (<span class="string">&quot;SpecularIntensity&quot;</span>, Float) = <span class="number">1</span></span><br><span class="line">         _SpecularSmooth (<span class="string">&quot;Specular Smooth&quot;</span>, Float) = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        [<span class="built_in">Header</span>(Rim)]</span><br><span class="line">        _RimMin(<span class="string">&quot;RimMin&quot;</span>, <span class="built_in">Range</span>(<span class="number">-2</span>,<span class="number">2</span>)) = <span class="number">0.5</span></span><br><span class="line">        _RimMax(<span class="string">&quot;RimMax&quot;</span>, <span class="built_in">Range</span>(<span class="number">-2</span>,<span class="number">2</span>)) = <span class="number">0.5</span></span><br><span class="line">        _Roughness(<span class="string">&quot;Roughness&quot;</span>, Float) = <span class="number">0</span></span><br><span class="line">        _EnvIntensity(<span class="string">&quot;Env Intensity&quot;</span>, Float) = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        [<span class="built_in">Header</span>(Outline)]</span><br><span class="line">        _Outline (<span class="string">&quot;Outline&quot;</span>, Float) = <span class="number">0.6</span></span><br><span class="line">        _OutlineColor (<span class="string">&quot;OutlineColor&quot;</span>, COLOR) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line">        </span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Name <span class="string">&quot;Skin&quot;</span></span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span> &#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdbase</span></span><br><span class="line">            <span class="comment">// make fog work</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fog</span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AutoLight.cginc&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 texcoord0 : TEXCOORD0;</span><br><span class="line">                float4 normal :NORMAL;</span><br><span class="line">                float4 tangent:TANGENT;</span><br><span class="line">                float4 VertexColor:COLOR;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">v2f</span></span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line"></span><br><span class="line">                float3 normalDir: TEXCOORD1;</span><br><span class="line">                float3 tangentDir: TEXCOORD2;</span><br><span class="line">                float3 binormalDir: TEXCOORD3;</span><br><span class="line">                float4 VertexColor: TEXCOORD4;</span><br><span class="line">                float3 pos_world: TEXCOORD5;</span><br><span class="line">                <span class="built_in">LIGHTING_COORDS</span>(<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            sampler2D _Normal;</span><br><span class="line">            sampler2D _DiffuseRamp;</span><br><span class="line">            samplerCUBE _Envmap;</span><br><span class="line"></span><br><span class="line">            float4 _LightColor0;</span><br><span class="line"></span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            float4 _TintBase;</span><br><span class="line">            float4 __TintLayer1;</span><br><span class="line">            <span class="type">float</span> _RampLayerOffset1;</span><br><span class="line"></span><br><span class="line">            float4 __TintLayer2;</span><br><span class="line">            <span class="type">float</span> _RampLayerOffset2;</span><br><span class="line">            <span class="type">float</span> _RampLayerSoftness2;</span><br><span class="line">            </span><br><span class="line">            float4 __TintLayer3;</span><br><span class="line">            <span class="type">float</span> _RampLayerOffset3;</span><br><span class="line">            <span class="type">float</span> _RampLayerSoftness3;</span><br><span class="line"></span><br><span class="line">            <span class="type">float</span> _Shineness;</span><br><span class="line">            <span class="type">float</span> _SpecularIntensity;</span><br><span class="line">            float4 _SpecularColor;</span><br><span class="line">            <span class="type">float</span> _SpecularSmooth;</span><br><span class="line"></span><br><span class="line">            <span class="type">float</span> _RimMax;</span><br><span class="line">            <span class="type">float</span> _RimMin;</span><br><span class="line">            <span class="type">float</span> _Roughness;</span><br><span class="line">            <span class="type">float</span> _EnvIntensity;</span><br><span class="line">            float4 _Envmap_HDR;</span><br><span class="line"></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span> <span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = <span class="built_in">UnityObjectToClipPos</span>(v.vertex);</span><br><span class="line">                o.uv = v.texcoord0;</span><br><span class="line">                o.normalDir=<span class="built_in">normalize</span>( <span class="built_in">mul</span>(unity_ObjectToWorld,v.normal).xyz);</span><br><span class="line">                o.tangentDir=<span class="built_in">normalize</span>( <span class="built_in">mul</span>(unity_ObjectToWorld,v.tangent).xyz);</span><br><span class="line">                o.pos_world=<span class="built_in">normalize</span>( <span class="built_in">mul</span>(unity_ObjectToWorld,v.vertex).xyz);</span><br><span class="line">                o.binormalDir=<span class="built_in">normalize</span>( <span class="built_in">cross</span>(o.normalDir,o.tangentDir)*v.tangent.w);</span><br><span class="line">                o.VertexColor = v.VertexColor;</span><br><span class="line">                <span class="built_in">TRANSFER_VERTEX_TO_FRAGMENT</span>(o);</span><br><span class="line">                <span class="keyword">return</span> o;   </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">half4 <span class="title">frag</span> <span class="params">(v2f i)</span> : SV_Target</span></span><br><span class="line"><span class="function">            &#123;</span></span><br><span class="line">                <span class="comment">// sample the texture</span></span><br><span class="line">                half atten = <span class="built_in">LIGHT_ATTENUATION</span> (i);</span><br><span class="line">                half3 base_col = <span class="built_in">tex2D</span>(_MainTex, i.uv).xyz;</span><br><span class="line">                half3 normal_world= <span class="built_in">normalize</span>(i.normalDir);</span><br><span class="line">                half3 tangent_world= <span class="built_in">normalize</span>(i.tangentDir);</span><br><span class="line">                half3 binormal_world= <span class="built_in">normalize</span>(i.binormalDir);</span><br><span class="line">                half3 pos_world= <span class="built_in">normalize</span>(i.pos_world);</span><br><span class="line">                half3 normal_data = <span class="built_in">UnpackNormal</span>(<span class="built_in">tex2D</span>(_Normal,i.uv));</span><br><span class="line">                half3x3 TBN = <span class="built_in">half3x3</span> (tangent_world,binormal_world,normal_world);</span><br><span class="line">                </span><br><span class="line">                normal_world = <span class="built_in">mul</span>(normal_data,TBN);</span><br><span class="line">                half3 ViewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz-pos_world);</span><br><span class="line">                half3 lightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                <span class="comment">//漫反射</span></span><br><span class="line">                half NdotL =  <span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">dot</span>(normal_world,lightDir));</span><br><span class="line">                half half_lambert = (NdotL+<span class="number">1.0</span>)*<span class="number">0.5</span>;</span><br><span class="line">                <span class="comment">//half half_lambert = half_lambert*ao //本来要乘上AO因为素材没有算了</span></span><br><span class="line"></span><br><span class="line">                half3 tint_Base_color1 = base_col;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//第一层ramp</span></span><br><span class="line">                half2 uv_ramp1 = <span class="built_in">half2</span>(half_lambert+_RampLayerOffset1,<span class="number">0.5</span>);</span><br><span class="line">                half toon_diffuse1 = <span class="built_in">tex2D</span>(_DiffuseRamp,uv_ramp1).r;</span><br><span class="line">                half3 tint_color1 = <span class="built_in">lerp</span>(<span class="built_in">half3</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),__TintLayer1,toon_diffuse1*__TintLayer1.a);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//第二层ramp</span></span><br><span class="line">                half2 uv_ramp2 = <span class="built_in">half2</span>(half_lambert+_RampLayerOffset2,<span class="number">1</span>-i.VertexColor.g+_RampLayerSoftness2);<span class="comment">//1-i.VertexColor.g可以用_RampLayerSoftness2代替越大越柔和</span></span><br><span class="line">                half toon_diffuse2 = <span class="built_in">tex2D</span>(_DiffuseRamp,uv_ramp2).g;</span><br><span class="line">                half3 tint_color2 = <span class="built_in">lerp</span>(<span class="built_in">half3</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),__TintLayer2,toon_diffuse2*__TintLayer2.a);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//第三层ramp</span></span><br><span class="line">                half2 uv_ramp3 = <span class="built_in">half2</span>(half_lambert+_RampLayerOffset3,<span class="number">1</span>-i.VertexColor.b+_RampLayerSoftness3);<span class="comment">//1-i.VertexColor.b可以用_RampLayerSoftness3代替越大越柔和</span></span><br><span class="line">                half toon_diffuse3 = <span class="built_in">tex2D</span>(_DiffuseRamp,uv_ramp3).b;</span><br><span class="line">                half3 tint_color3 = <span class="built_in">lerp</span>(<span class="built_in">half3</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),__TintLayer3,toon_diffuse3*__TintLayer3.a);</span><br><span class="line">                </span><br><span class="line">                half3 final_diffuse = tint_Base_color1 * tint_color1 *tint_color2 *tint_color3  ;</span><br><span class="line">                <span class="comment">//高光</span></span><br><span class="line">                <span class="comment">//half3 half_R = normalize(lightDir+ViewDir);</span></span><br><span class="line">                half3 R = <span class="built_in">normalize</span>(<span class="built_in">reflect</span>(-lightDir,normal_world));</span><br><span class="line">                half specular_term = <span class="built_in">max</span>(<span class="built_in">pow</span>(<span class="built_in">dot</span>(R,ViewDir),_Shineness),<span class="number">0.0001</span>);<span class="comment">//本来要乘上AO因为素材没有算了</span></span><br><span class="line">                specular_term = <span class="built_in">smoothstep</span>(<span class="number">0.5</span>-_SpecularSmooth*<span class="number">0.5</span>,<span class="number">0.5</span>+_SpecularSmooth*<span class="number">0.5</span>,specular_term);<span class="comment">//风格化高光</span></span><br><span class="line">            </span><br><span class="line">                half3 final_specular = base_col  * specular_term *_SpecularColor *atten *_LightColor0.xyz *_SpecularIntensity  ;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//边缘光,环境光</span></span><br><span class="line">                half NDL = NdotL&gt;<span class="number">0</span> ? <span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">                half fresnel = <span class="number">1</span>- <span class="built_in">dot</span>(ViewDir,normal_world);</span><br><span class="line">                half rim = <span class="built_in">smoothstep</span>(_RimMin,_RimMax,fresnel);<span class="comment">//本来要乘上AO因为素材没有算了</span></span><br><span class="line">                rim = rim * NDL;</span><br><span class="line"></span><br><span class="line">                half3 r = <span class="built_in">reflect</span>(-ViewDir,normal_world);</span><br><span class="line">                half roughness = <span class="built_in">lerp</span>(<span class="number">0</span>,<span class="number">0.95</span>,<span class="built_in">saturate</span>(_Roughness));</span><br><span class="line">                roughness = roughness * (<span class="number">1.7</span><span class="number">-0.7</span>*roughness );</span><br><span class="line">                half mip_level = roughness * <span class="number">6.0</span>;</span><br><span class="line">                half4 color_cubemap = <span class="built_in">texCUBElod</span>(_Envmap,<span class="built_in">half4</span>(r,mip_level));</span><br><span class="line">                half3 color_env = <span class="built_in">DecodeHDR</span>(color_cubemap,_Envmap_HDR);</span><br><span class="line">                half3 final_env =color_env * rim * _EnvIntensity    ;</span><br><span class="line"></span><br><span class="line">                half3 final_col = final_diffuse+final_specular + final_env;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">half4</span>(final_col,<span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">        Name <span class="string">&quot;OUTLINE&quot;</span></span><br><span class="line">        Cull Front</span><br><span class="line">    ZWrite On</span><br><span class="line">    ColorMask RGB</span><br><span class="line">    Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">appdata</span> &#123;</span><br><span class="line">            float4 vertex : POSITION;</span><br><span class="line">            float3 normal : NORMAL;</span><br><span class="line">            float4 texCoord : TEXCOORD0;</span><br><span class="line">            float4 vertexColor : COLOR;</span><br><span class="line">          &#125;;</span><br><span class="line">          <span class="keyword">struct</span> <span class="title class_">v2f</span> &#123;</span><br><span class="line">          	float4 pos : POSITION;</span><br><span class="line">          	float4 color : COLOR;</span><br><span class="line">          	float4 tex : TEXCOORD0;</span><br><span class="line">          &#125;;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            <span class="type">float</span> _Outline;</span><br><span class="line">            float4 _OutlineColor;</span><br><span class="line">            <span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// just make a copy of incoming vertex data but scaled according to normal direction</span></span><br><span class="line">          	v2f o;</span><br><span class="line">          	o.pos = <span class="built_in">UnityObjectToClipPos</span>(v.vertex);</span><br><span class="line">            float3 norm = <span class="built_in">mul</span>((float3x3)UNITY_MATRIX_IT_MV, v.normal);</span><br><span class="line">            float2 offset = <span class="built_in">TransformViewToProjection</span>(norm.xy);</span><br><span class="line">           <span class="comment">// float2 offset = (norm.xy);</span></span><br><span class="line">          	o.pos.xy += offset * _Outline*<span class="number">0.0001</span>;</span><br><span class="line">          	o.tex = v.texCoord;</span><br><span class="line">          	o.color = v.vertexColor;</span><br><span class="line">          	<span class="keyword">return</span> o;</span><br><span class="line">          &#125;</span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span> <span class="params">(v2f i)</span> : SV_Target</span></span><br><span class="line"><span class="function">            &#123;</span></span><br><span class="line">                half4 base_col = <span class="built_in">tex2D</span>(_MainTex,i.tex);</span><br><span class="line">                <span class="keyword">return</span> _OutlineColor*base_col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="眼睛"><a href="#眼睛" class="headerlink" title="眼睛"></a>眼睛</h2><p>眼睛折射效果，我的模型不需要进行眼球移动，也不适合做这个，所以没弄<br>其中uworld和vworld是指UV线在世界空间下在方向。<br><img src="https://img-blog.csdnimg.cn/4a670d4f998c4f1c9be3cec05961a865.png" alt="在这里插入图片描述"><br>以下也没搞清除<br><img src="https://img-blog.csdnimg.cn/2554930d4bee4ad0b36a2746d1f7a8e5.png" alt="在这里插入图片描述"></p>
<h3 id="关于头发遮挡眼睛，解决办法"><a href="#关于头发遮挡眼睛，解决办法" class="headerlink" title="关于头发遮挡眼睛，解决办法"></a>关于头发遮挡眼睛，解决办法</h3><h4 id="模板测试"><a href="#模板测试" class="headerlink" title="模板测试"></a>模板测试</h4><p>在进行眼睛渲染的Pass时，将模板值设置为某一固定值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Stencil &#123;</span><br><span class="line">   Ref <span class="number">1</span></span><br><span class="line">   Comp Always</span><br><span class="line">   Pass Replace</span><br><span class="line">   Fail Replace</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>头发等遮挡部分</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Stencil &#123;</span><br><span class="line">     Ref <span class="number">1</span></span><br><span class="line">     Comp NotEqual</span><br><span class="line">     Pass Keep</span><br><span class="line">     Fail Keep</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/cf076006cd9746778c51ebf8c4bae008.png" alt="在这里插入图片描述"></p>
<h4 id="将遮挡脸部透明部分写入顶点色A通道"><a href="#将遮挡脸部透明部分写入顶点色A通道" class="headerlink" title="将遮挡脸部透明部分写入顶点色A通道"></a>将遮挡脸部透明部分写入顶点色A通道</h4><p>将头发渲染队列改为Transparent<br>让最后输出的颜色的A等于顶点色A</p>
<h3 id="Eye-shader"><a href="#Eye-shader" class="headerlink" title="Eye.shader"></a>Eye.shader</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Character/Eye&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">       _MainTex (<span class="string">&quot;MainTex&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">       _Normal(<span class="string">&quot;Normal&quot;</span>,<span class="number">2</span>D) = <span class="string">&quot;bump&quot;</span> &#123;&#125;</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line">        </span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">          Stencil &#123;</span><br><span class="line">             Ref <span class="number">1</span></span><br><span class="line">             Comp Always</span><br><span class="line">             Pass Replace</span><br><span class="line">             Fail Replace</span><br><span class="line">          &#125;</span><br><span class="line">           Name <span class="string">&quot;Eye&quot;</span></span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span> &#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdbase</span></span><br><span class="line">            <span class="comment">// make fog work</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fog</span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AutoLight.cginc&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 texcoord0 : TEXCOORD0;</span><br><span class="line">                float4 normal :NORMAL;</span><br><span class="line">                float4 tangent:TANGENT;</span><br><span class="line">                float4 VertexColor:COLOR;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">v2f</span></span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line"></span><br><span class="line">                float3 normalDir: TEXCOORD1;</span><br><span class="line">                float3 tangentDir: TEXCOORD2;</span><br><span class="line">                float3 binormalDir: TEXCOORD3;</span><br><span class="line">                float4 VertexColor: TEXCOORD4;</span><br><span class="line">                float3 pos_world: TEXCOORD5;</span><br><span class="line">                <span class="built_in">LIGHTING_COORDS</span>(<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            sampler2D _Normal;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span> <span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = <span class="built_in">UnityObjectToClipPos</span>(v.vertex);</span><br><span class="line">                o.uv = v.texcoord0;</span><br><span class="line">                o.normalDir=<span class="built_in">normalize</span>( <span class="built_in">mul</span>(unity_ObjectToWorld,v.normal).xyz);</span><br><span class="line">                o.tangentDir=<span class="built_in">normalize</span>( <span class="built_in">mul</span>(unity_ObjectToWorld,v.tangent).xyz);</span><br><span class="line">                o.pos_world=<span class="built_in">normalize</span>( <span class="built_in">mul</span>(unity_ObjectToWorld,v.vertex).xyz);</span><br><span class="line">                o.binormalDir=<span class="built_in">normalize</span>( <span class="built_in">cross</span>(o.normalDir,o.tangentDir)*v.tangent.w);</span><br><span class="line">                o.VertexColor = v.VertexColor;</span><br><span class="line">                <span class="built_in">TRANSFER_VERTEX_TO_FRAGMENT</span>(o);</span><br><span class="line">                <span class="keyword">return</span> o;   </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span> <span class="params">(v2f i)</span> : SV_Target</span></span><br><span class="line"><span class="function">            &#123;</span></span><br><span class="line">                <span class="comment">// sample the texture</span></span><br><span class="line">                fixed4 base_col = <span class="built_in">tex2D</span>(_MainTex, i.uv);</span><br><span class="line">                half3 normal_world= <span class="built_in">normalize</span>(i.normalDir);</span><br><span class="line">                half3 tangent_world= <span class="built_in">normalize</span>(i.tangentDir);</span><br><span class="line">                half3 binormal_world= <span class="built_in">normalize</span>(i.binormalDir);</span><br><span class="line">                half3 normal_data = <span class="built_in">UnpackNormal</span>(<span class="built_in">tex2D</span>(_Normal,i.uv));</span><br><span class="line">                half3x3 TBN = <span class="built_in">half3x3</span> (tangent_world,binormal_world,normal_world);</span><br><span class="line">                normal_world = <span class="built_in">mul</span>(TBN,normal_world);</span><br><span class="line">                half3 ViewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz-i.pos_world);</span><br><span class="line">                half3 lightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                half fresnel = <span class="number">1</span>- <span class="built_in">saturate</span>(<span class="built_in">dot</span>(normal_world ,ViewDir ));</span><br><span class="line">                <span class="keyword">return</span> base_col;</span><br><span class="line">               <span class="comment">// return half4(normal_world,1);</span></span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="头发"><a href="#头发" class="headerlink" title="头发"></a>头发</h2><p>各项异性高光<br><a href="https://mrchenlreanspace.github.io/2022/04/14/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BA%BA%E7%89%A9%E6%B8%B2%E6%9F%93/">原理见移动人物渲染</a></p>
<h3 id="使用shiftmap增强质感"><a href="#使用shiftmap增强质感" class="headerlink" title="使用shiftmap增强质感"></a>使用shiftmap增强质感</h3><p><img src="https://img-blog.csdnimg.cn/dca88625635742ddbd47a85080ab8244.png" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">half2 uv_shift = i.uv * _ShiftRamp_ST.xy + _ShiftRamp_ST.zw;</span><br><span class="line">half3 shift_col = <span class="built_in">tex2D</span>(_ShiftRamp,uv_shift);</span><br><span class="line">binormal_world = <span class="built_in">normalize</span>( binormal_world + (shift_col+_ShiftOffset)* normal_world);</span><br></pre></td></tr></table></figure>
<p>_ShiftRamp_ST.x调节质感，_ShiftOffset调节头发的上下偏移</p>
<h3 id="初版"><a href="#初版" class="headerlink" title="初版"></a>初版</h3><p>通过shininess调节柔和度<br>调大shininess让过度变硬</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">half <span class="title">StrandSpecular</span><span class="params">(half3 T, half3 V, half3 L, half exponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     half3 H = <span class="built_in">normalize</span>(L + V);</span><br><span class="line">     half dotTH = <span class="built_in">dot</span>(T, H);</span><br><span class="line">     half sinTH = <span class="built_in">sqrt</span>(<span class="number">1</span> - dotTH * dotTH);</span><br><span class="line">     half dirAtten = <span class="built_in">smoothstep</span>(<span class="number">-1.0</span>, <span class="number">0.0</span>, dotTH);</span><br><span class="line">     <span class="keyword">return</span> dirAtten * <span class="built_in">pow</span>(sinTH, exponent);</span><br><span class="line">&#125;</span><br><span class="line">half3 final_specular =    <span class="built_in">StrandSpecular</span>(binormal_world,lightDir,ViewDir,_Shineness)*_SpecularColor;</span><br></pre></td></tr></table></figure>
<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>把柔和度调整到0，1中通过shininess值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">half NdotV = <span class="built_in">max</span>(<span class="number">0.0</span> ,<span class="built_in">dot</span>(normal_world , ViewDir));</span><br><span class="line">half3 H = <span class="built_in">normalize</span>(lightDir+ViewDir);</span><br><span class="line">half NdotH = <span class="built_in">dot</span>(normal_world ,H );</span><br><span class="line">half TdotH = <span class="built_in">dot</span>(tangent_world ,H);</span><br><span class="line">half BdotH = <span class="built_in">dot</span>(binormal_world ,H);</span><br><span class="line"></span><br><span class="line">BdotH /=_Shineness;</span><br><span class="line">half spec_term =<span class="built_in">exp</span>(-(TdotH*TdotH+BdotH*BdotH)/(<span class="number">1.0</span>+NdotH));</span><br><span class="line">half spec_atten = <span class="built_in">saturate</span>(<span class="built_in">sqrt</span>(<span class="built_in">max</span>(<span class="number">0.0</span>,half_lambert/NdotV)));</span><br><span class="line">half3 final_specular =    spec_term*spec_atten*_SpecularColor;</span><br></pre></td></tr></table></figure>
<h3 id="在第二层高光叠加的时候"><a href="#在第二层高光叠加的时候" class="headerlink" title="在第二层高光叠加的时候"></a>在第二层高光叠加的时候</h3><p>再乘上一层shift_col当噪声</p>
<p><img src="https://img-blog.csdnimg.cn/f04cd43ef2c1432c8f369753e9d45ff8.png" alt="在这里插入图片描述"></p>
<h3 id="Hair-shader"><a href="#Hair-shader" class="headerlink" title="Hair.shader"></a>Hair.shader</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;</span></span><br><span class="line"></span><br><span class="line">Shader <span class="string">&quot;Character/Hair&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;MainTex&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Normal(<span class="string">&quot;Normal&quot;</span>,<span class="number">2</span>D) = <span class="string">&quot;bump&quot;</span> &#123;&#125;</span><br><span class="line">        _DiffuseRamp (<span class="string">&quot;DiffuseRamp&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;Black&quot;</span> &#123;&#125;</span><br><span class="line">        _Envmap (<span class="string">&quot;Envmap&quot;</span>, Cube) = <span class="string">&quot;Black&quot;</span> &#123;&#125;</span><br><span class="line">        _ShiftRamp(<span class="string">&quot;ShiftRamp&quot;</span>,<span class="number">2</span>D)=<span class="string">&quot;Black&quot;</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        [<span class="built_in">Header</span>(Tint Base)]</span><br><span class="line">        _TintBase (<span class="string">&quot;Tint Base&quot;</span>, COLOR) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        [<span class="built_in">Header</span>(RampLayer1)]</span><br><span class="line">        _RampLayerOffset1 (<span class="string">&quot;RampLayerOffset1&quot;</span>, <span class="built_in">Range</span>(<span class="number">-0.5</span>,<span class="number">0.5</span>)) = <span class="number">0.5</span></span><br><span class="line">        _TintLayer1 (<span class="string">&quot;Tint_Layer1&quot;</span>, COLOR) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        [<span class="built_in">Header</span>(RampLayer2)]</span><br><span class="line">        _RampLayerOffset2 (<span class="string">&quot;RampLayerOffset2&quot;</span>, <span class="built_in">Range</span>(<span class="number">-0.5</span>,<span class="number">0.5</span>)) = <span class="number">0.5</span></span><br><span class="line">        _RampLayerSoftness2 (<span class="string">&quot;RampLayerSoftness2&quot;</span>, <span class="built_in">Range</span>(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">        __TintLayer2 (<span class="string">&quot;Tint Layer2&quot;</span>, COLOR) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        [<span class="built_in">Header</span>(RampLayer3)]</span><br><span class="line">        _RampLayerOffset3 (<span class="string">&quot;RampLayerOffset3&quot;</span>, <span class="built_in">Range</span>(<span class="number">-0.5</span>,<span class="number">0.5</span>)) = <span class="number">0.5</span></span><br><span class="line">        _RampLayerSoftness3 (<span class="string">&quot;RampLayerSoftness3&quot;</span>, <span class="built_in">Range</span>(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">        __TintLayer3 (<span class="string">&quot;Tint Layer3&quot;</span>, COLOR) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        [<span class="built_in">Header</span>(Specular1)]</span><br><span class="line">         _SpecularColor1 (<span class="string">&quot;Specular Color1&quot;</span>, COLOR) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">         _SpecularIntensity1 (<span class="string">&quot;SpecularIntensity1&quot;</span>, Float) = <span class="number">1</span></span><br><span class="line">         _SpecularSmooth1 (<span class="string">&quot;Specular Smooth1&quot;</span>,  <span class="built_in">Range</span>(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">         _ShiftOffset1 (<span class="string">&quot;Shift Offset1&quot;</span>, Float) = <span class="number">0</span></span><br><span class="line">         [<span class="built_in">Header</span>(Specular2)]</span><br><span class="line">         _SpecularColor2 (<span class="string">&quot;Specular Color2&quot;</span>, COLOR) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">         _SpecularIntensity2 (<span class="string">&quot;SpecularIntensity2&quot;</span>, Float) = <span class="number">1</span></span><br><span class="line">         _SpecularSmooth2 (<span class="string">&quot;Specular Smooth2&quot;</span>, <span class="built_in">Range</span>(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">         _ShiftOffset2 (<span class="string">&quot;Shift Offset2&quot;</span>, Float) = <span class="number">0</span> </span><br><span class="line">         </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        [<span class="built_in">Header</span>(Rim)]</span><br><span class="line">        _RimMin(<span class="string">&quot;RimMin&quot;</span>, <span class="built_in">Range</span>(<span class="number">-2</span>,<span class="number">2</span>)) = <span class="number">0.5</span></span><br><span class="line">        _RimMax(<span class="string">&quot;RimMax&quot;</span>, <span class="built_in">Range</span>(<span class="number">-2</span>,<span class="number">2</span>)) = <span class="number">0.5</span></span><br><span class="line">        _Roughness(<span class="string">&quot;Roughness&quot;</span>, Float) = <span class="number">0</span></span><br><span class="line">        _EnvIntensity(<span class="string">&quot;Env Intensity&quot;</span>, Float) = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        [<span class="built_in">Header</span>(Outline)]</span><br><span class="line">        _Outline (<span class="string">&quot;Outline&quot;</span>, Float) = <span class="number">0.6</span></span><br><span class="line">        _OutlineColor (<span class="string">&quot;OutlineColor&quot;</span>, COLOR) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line">        </span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Name <span class="string">&quot;Skin&quot;</span></span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span> &#125;</span><br><span class="line">            </span><br><span class="line">            Stencil &#123;</span><br><span class="line">                 Ref <span class="number">1</span></span><br><span class="line">                 Comp NotEqual</span><br><span class="line">                 Pass Keep</span><br><span class="line">                 Fail Keep</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdbase</span></span><br><span class="line">            <span class="comment">// make fog work</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fog</span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AutoLight.cginc&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 texcoord0 : TEXCOORD0;</span><br><span class="line">                float4 normal :NORMAL;</span><br><span class="line">                float4 tangent:TANGENT;</span><br><span class="line">                float4 VertexColor:COLOR;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">v2f</span></span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line"></span><br><span class="line">                float3 normalDir: TEXCOORD1;</span><br><span class="line">                float3 tangentDir: TEXCOORD2;</span><br><span class="line">                float3 binormalDir: TEXCOORD3;</span><br><span class="line">                float4 VertexColor: TEXCOORD4;</span><br><span class="line">                float3 pos_world: TEXCOORD5;</span><br><span class="line">                <span class="built_in">LIGHTING_COORDS</span>(<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            sampler2D _Normal;</span><br><span class="line">            sampler2D _DiffuseRamp;</span><br><span class="line">            samplerCUBE _Envmap;</span><br><span class="line">            sampler2D _ShiftRamp;</span><br><span class="line">            float4 _ShiftRamp_ST;</span><br><span class="line"></span><br><span class="line">            float4 _LightColor0;</span><br><span class="line"></span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            float4 _TintBase;</span><br><span class="line">            float4 __TintLayer1;</span><br><span class="line">            <span class="type">float</span> _RampLayerOffset1;</span><br><span class="line"></span><br><span class="line">            float4 __TintLayer2;</span><br><span class="line">            <span class="type">float</span> _RampLayerOffset2;</span><br><span class="line">            <span class="type">float</span> _RampLayerSoftness2;</span><br><span class="line">            </span><br><span class="line">            float4 __TintLayer3;</span><br><span class="line">            <span class="type">float</span> _RampLayerOffset3;</span><br><span class="line">            <span class="type">float</span> _RampLayerSoftness3;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            <span class="type">float</span> _ShiftOffset1;</span><br><span class="line">            <span class="type">float</span> _SpecularIntensity1;</span><br><span class="line">            float4 _SpecularColor1;</span><br><span class="line">            <span class="type">float</span> _SpecularSmooth1;</span><br><span class="line">            </span><br><span class="line">            <span class="type">float</span> _ShiftOffset2;</span><br><span class="line">            <span class="type">float</span> _SpecularIntensity2;</span><br><span class="line">            float4 _SpecularColor2;</span><br><span class="line">            <span class="type">float</span> _SpecularSmooth2;</span><br><span class="line"></span><br><span class="line">            <span class="type">float</span> _RimMax;</span><br><span class="line">            <span class="type">float</span> _RimMin;</span><br><span class="line">            <span class="type">float</span> _Roughness;</span><br><span class="line">            <span class="type">float</span> _EnvIntensity;</span><br><span class="line">            float4 _Envmap_HDR;</span><br><span class="line"></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span> <span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = <span class="built_in">UnityObjectToClipPos</span>(v.vertex);</span><br><span class="line">                o.uv = v.texcoord0;</span><br><span class="line">                o.normalDir=<span class="built_in">normalize</span>( <span class="built_in">mul</span>(unity_ObjectToWorld,v.normal).xyz);</span><br><span class="line">                o.tangentDir=<span class="built_in">normalize</span>( <span class="built_in">mul</span>(unity_ObjectToWorld,v.tangent).xyz);</span><br><span class="line">                o.pos_world=<span class="built_in">normalize</span>( <span class="built_in">mul</span>(unity_ObjectToWorld,v.vertex).xyz);</span><br><span class="line">                o.binormalDir=<span class="built_in">normalize</span>( <span class="built_in">cross</span>(o.normalDir,o.tangentDir)*v.tangent.w);</span><br><span class="line">                o.VertexColor = v.VertexColor;</span><br><span class="line">                <span class="built_in">TRANSFER_VERTEX_TO_FRAGMENT</span>(o);</span><br><span class="line">                <span class="keyword">return</span> o;   </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            <span class="function">half <span class="title">StrandSpecular</span><span class="params">(half3 T, half3 V, half3 L, half exponent)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                 half3 H = <span class="built_in">normalize</span>(L + V);</span><br><span class="line">                 half dotTH = <span class="built_in">dot</span>(T, H);</span><br><span class="line">                 half sinTH = <span class="built_in">sqrt</span>(<span class="number">1</span> - dotTH * dotTH);</span><br><span class="line">                 half dirAtten = <span class="built_in">smoothstep</span>(<span class="number">-1.0</span>, <span class="number">0.0</span>, dotTH);</span><br><span class="line">                 <span class="keyword">return</span> dirAtten * <span class="built_in">pow</span>(sinTH, exponent);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">half4 <span class="title">frag</span> <span class="params">(v2f i)</span> : SV_Target</span></span><br><span class="line"><span class="function">            &#123;</span></span><br><span class="line">                <span class="comment">// sample the texture</span></span><br><span class="line">                half atten = <span class="built_in">LIGHT_ATTENUATION</span> (i);</span><br><span class="line">                half3 base_col = <span class="built_in">tex2D</span>(_MainTex, i.uv).xyz;</span><br><span class="line">                half3 normal_world = <span class="built_in">normalize</span>(i.normalDir);</span><br><span class="line">                half3 tangent_world= <span class="built_in">normalize</span>(i.tangentDir);</span><br><span class="line">                half3 binormal_world= <span class="built_in">normalize</span>(i.binormalDir);</span><br><span class="line">               </span><br><span class="line">                half3 normal_data = <span class="built_in">UnpackNormal</span>(<span class="built_in">tex2D</span>(_Normal,i.uv));</span><br><span class="line">                half3x3 TBN = <span class="built_in">half3x3</span> (tangent_world,binormal_world,normal_world);</span><br><span class="line">                </span><br><span class="line">                normal_world = <span class="built_in">mul</span>(normal_data,TBN);</span><br><span class="line">                half3 ViewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz-i.pos_world);</span><br><span class="line">                half3 lightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                <span class="comment">//漫反射</span></span><br><span class="line">                half NdotL =  <span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">dot</span>(normal_world,lightDir));</span><br><span class="line">                half half_lambert = (NdotL+<span class="number">1.0</span>)*<span class="number">0.5</span>;</span><br><span class="line">                <span class="comment">//half half_lambert = half_lambert*ao //本来要乘上AO因为素材没有算了</span></span><br><span class="line"></span><br><span class="line">                half3 tint_Base_color1 = base_col;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//第一层ramp</span></span><br><span class="line">                half2 uv_ramp1 = <span class="built_in">half2</span>(half_lambert+_RampLayerOffset1,<span class="number">0.5</span>);</span><br><span class="line">                half toon_diffuse1 = <span class="built_in">tex2D</span>(_DiffuseRamp,uv_ramp1).r;</span><br><span class="line">                half3 tint_color1 = <span class="built_in">lerp</span>(<span class="built_in">half3</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),__TintLayer1,toon_diffuse1*__TintLayer1.a);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//第二层ramp</span></span><br><span class="line">                half2 uv_ramp2 = <span class="built_in">half2</span>(half_lambert+_RampLayerOffset2,<span class="number">1</span>-i.VertexColor.g+_RampLayerSoftness2);<span class="comment">//1-i.VertexColor.g可以用_RampLayerSoftness2代替越大越柔和</span></span><br><span class="line">                half toon_diffuse2 = <span class="built_in">tex2D</span>(_DiffuseRamp,uv_ramp2).g;</span><br><span class="line">                half3 tint_color2 = <span class="built_in">lerp</span>(<span class="built_in">half3</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),__TintLayer2,toon_diffuse2*__TintLayer2.a);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//第三层ramp</span></span><br><span class="line">                half2 uv_ramp3 = <span class="built_in">half2</span>(half_lambert+_RampLayerOffset3,<span class="number">1</span>-i.VertexColor.b+_RampLayerSoftness3);<span class="comment">//1-i.VertexColor.b可以用_RampLayerSoftness3代替越大越柔和</span></span><br><span class="line">                half toon_diffuse3 = <span class="built_in">tex2D</span>(_DiffuseRamp,uv_ramp3).b;</span><br><span class="line">                half3 tint_color3 = <span class="built_in">lerp</span>(<span class="built_in">half3</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),__TintLayer3,toon_diffuse3*__TintLayer3.a);</span><br><span class="line">                </span><br><span class="line">                half3 final_diffuse = tint_Base_color1 * tint_color1 *tint_color2 *tint_color3  ;</span><br><span class="line">                <span class="comment">//各向异性高光</span></span><br><span class="line">                half2 uv_shift = i.uv * _ShiftRamp_ST.xy + _ShiftRamp_ST.zw;</span><br><span class="line">                half3 shift_col = <span class="built_in">tex2D</span>(_ShiftRamp,uv_shift);</span><br><span class="line">                half3 binormal_world1 = <span class="built_in">normalize</span>( binormal_world + (shift_col+_ShiftOffset1)* normal_world);</span><br><span class="line">                half3 binormal_world2 = <span class="built_in">normalize</span>( binormal_world + (shift_col+_ShiftOffset2)* normal_world);</span><br><span class="line">                half NdotV = <span class="built_in">max</span>(<span class="number">0.00001</span> ,<span class="built_in">dot</span>(normal_world , ViewDir));</span><br><span class="line">                half3 H = <span class="built_in">normalize</span>(lightDir+ViewDir);</span><br><span class="line">                half NdotH = <span class="built_in">dot</span>(normal_world ,H );</span><br><span class="line">                half TdotH = <span class="built_in">dot</span>(tangent_world ,H);</span><br><span class="line">               </span><br><span class="line">              </span><br><span class="line">                half BdotH1 =<span class="built_in">dot</span>(binormal_world1 ,H)/_SpecularSmooth1;</span><br><span class="line">                half spec_term1 =<span class="built_in">exp</span>(-(TdotH*TdotH+BdotH1*BdotH1)/(<span class="number">1.0</span>+NdotH));</span><br><span class="line">                half spec_atten1 = <span class="built_in">saturate</span>(<span class="built_in">sqrt</span>(<span class="built_in">max</span>(<span class="number">0.0</span>,half_lambert/NdotV)));</span><br><span class="line">                half3 specular_col1 = spec_term1* spec_atten1 * _LightColor0.xyz * _SpecularIntensity1 * atten * _SpecularColor1.xyz;</span><br><span class="line">                </span><br><span class="line">                half BdotH2 =<span class="built_in">dot</span>(binormal_world2 ,H)/_SpecularSmooth2;</span><br><span class="line">                half spec_term2 =<span class="built_in">exp</span>(-(TdotH*TdotH+BdotH2*BdotH2)/(<span class="number">1.0</span>+NdotH));</span><br><span class="line">                half spec_atten2 = <span class="built_in">saturate</span>(<span class="built_in">sqrt</span>(<span class="built_in">max</span>(<span class="number">0.0</span>,half_lambert/NdotV)));</span><br><span class="line">                half3 specular_col2 = spec_term2* spec_atten2 * _LightColor0.xyz * _SpecularIntensity2 * atten *_SpecularColor1.xyz*shift_col;</span><br><span class="line"></span><br><span class="line">                 half3 final_specular =   specular_col1 + specular_col2 ;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//half3 half_R = normalize(lightDir+ViewDir);</span></span><br><span class="line">                <span class="comment">//half3 R = normalize(reflect(-lightDir,normal_world));</span></span><br><span class="line">                <span class="comment">//half specular_term = max(pow(dot(R,ViewDir),_Shineness),0.0001);//本来要乘上AO因为素材没有算了</span></span><br><span class="line">                <span class="comment">//specular_term = smoothstep(0.5-_SpecularSmooth*0.5,0.5+_SpecularSmooth*0.5,specular_term);//风格化高光</span></span><br><span class="line">            </span><br><span class="line">                <span class="comment">//half3 final_specular = base_col  * specular_term *_SpecularColor *atten *_LightColor0.xyz *_SpecularIntensity  ;</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//边缘光,环境光</span></span><br><span class="line">                half NDL = NdotL&gt;<span class="number">0</span> ? <span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">                half fresnel = <span class="number">1</span>- <span class="built_in">dot</span>(ViewDir,normal_world);</span><br><span class="line">                half rim = <span class="built_in">smoothstep</span>(_RimMin,_RimMax,fresnel);<span class="comment">//本来要乘上AO因为素材没有算了</span></span><br><span class="line">                rim = rim * NDL;</span><br><span class="line"></span><br><span class="line">                half3 r = <span class="built_in">reflect</span>(-ViewDir,normal_world);</span><br><span class="line">                half roughness = <span class="built_in">lerp</span>(<span class="number">0</span>,<span class="number">0.95</span>,<span class="built_in">saturate</span>(_Roughness));</span><br><span class="line">                roughness = roughness * (<span class="number">1.7</span><span class="number">-0.7</span>*roughness );</span><br><span class="line">                half mip_level = roughness * <span class="number">6.0</span>;</span><br><span class="line">                half4 color_cubemap = <span class="built_in">texCUBElod</span>(_Envmap,<span class="built_in">half4</span>(r,mip_level));</span><br><span class="line">                half3 color_env = <span class="built_in">DecodeHDR</span>(color_cubemap,_Envmap_HDR);</span><br><span class="line">                half3 final_env =color_env * rim * _EnvIntensity    ;</span><br><span class="line"></span><br><span class="line">                half3 final_col = final_diffuse +final_specular +final_env;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">half4</span>(final_col,<span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">        Name <span class="string">&quot;OUTLINE&quot;</span></span><br><span class="line">        Cull Front</span><br><span class="line">    ZWrite On</span><br><span class="line">    ColorMask RGB</span><br><span class="line">    Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">appdata</span> &#123;</span><br><span class="line">            float4 vertex : POSITION;</span><br><span class="line">            float3 normal : NORMAL;</span><br><span class="line">            float4 texCoord : TEXCOORD0;</span><br><span class="line">            float4 vertexColor : COLOR;</span><br><span class="line">          &#125;;</span><br><span class="line">          <span class="keyword">struct</span> <span class="title class_">v2f</span> &#123;</span><br><span class="line">          	float4 pos : POSITION;</span><br><span class="line">          	float4 color : COLOR;</span><br><span class="line">          	float4 tex : TEXCOORD0;</span><br><span class="line">          &#125;;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            <span class="type">float</span> _Outline;</span><br><span class="line">            float4 _OutlineColor;</span><br><span class="line">            <span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// just make a copy of incoming vertex data but scaled according to normal direction</span></span><br><span class="line">          	v2f o;</span><br><span class="line">          	o.pos = <span class="built_in">UnityObjectToClipPos</span>(v.vertex);</span><br><span class="line">            float3 norm = <span class="built_in">mul</span>((float3x3)UNITY_MATRIX_IT_MV, v.normal);</span><br><span class="line">            float2 offset = <span class="built_in">TransformViewToProjection</span>(norm.xy);</span><br><span class="line">           <span class="comment">// float2 offset = (norm.xy);</span></span><br><span class="line">          	o.pos.xy += offset * _Outline*<span class="number">0.0001</span>;</span><br><span class="line">          	o.tex = v.texCoord;</span><br><span class="line">          	o.color = v.vertexColor;</span><br><span class="line">          	<span class="keyword">return</span> o;</span><br><span class="line">          &#125;</span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span> <span class="params">(v2f i)</span> : SV_Target</span></span><br><span class="line"><span class="function">            &#123;</span></span><br><span class="line">                half4 base_col = <span class="built_in">tex2D</span>(_MainTex,i.tex);</span><br><span class="line">                <span class="keyword">return</span> _OutlineColor*base_col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="脸部"><a href="#脸部" class="headerlink" title="脸部"></a>脸部</h2><p>在皮肤的基础上提亮一点。</p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>大话设计模式观后感之结构型设计模式</title>
    <url>/2022/06/02/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%82%E5%90%8E%E6%84%9F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><p><strong>外观模式(Facade)，为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</strong></p>
<p>在原子系统加一层封装，提供系统相关功能完成分层。</p>
<p><img src="https://img-blog.csdnimg.cn/49b062f2726c41299f755c6146eb5dfc.png" alt="在这里插入图片描述"></p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><img src="https://img-blog.csdnimg.cn/a4e1c24dad9c41b3a91512756995ad08.png" alt="在这里插入图片描述"></p>
<p>修改后</p>
<p><img src="https://img-blog.csdnimg.cn/496ea3029356465aa5535ec74882a6e2.png" alt="在这里插入图片描述"></p>
<p>将子系统功能聚合起来</p>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ol>
<li><p><strong>在设计初期阶段，应该要有意识的将不同的两个层分离</strong></p>
</li>
<li><p><strong>在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，大多数的模式使用时也都会产生很多很小的类，这本是好事，但也给外部调用它们的用户程序带来了使用上的困难，增加外观 Facade可以提供一个简单的接口，减少它们之间的依赖。</strong></p>
</li>
<li><p><strong>在维护一个遗留的大型系统时，可能这个系统已经非常难以维护和扩展了，但因为它包含非常重要的功能，新的需求开发必须要依赖于它。此时用外观模式Facade也是非常合适的。你可以为新系统开发一个外观 Facade类，来提供设计粗糙或高度复杂的遗留代码的比较清晰简单的接口，让新系统与Facade对象交互，Facade 与遗留代码交互所有复杂的工作。</strong></p>
</li>
</ol>
<h2 id="信息的隐藏促进了软件的复用"><a href="#信息的隐藏促进了软件的复用" class="headerlink" title="信息的隐藏促进了软件的复用"></a>信息的隐藏促进了软件的复用</h2><p>迪米特原则</p>
<p><strong>应该让一个软件中的子系统间的通信和相互依赖关系达到最小，而具体办法就是引入一个外观对象，它为子系统间提供了一个单一而简单的屏障。</strong></p>
<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p><strong>适配器模式(Adapter)，将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/24654bb8164041048248c68fbf1da7e4.png" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/b2d25f72586e4076ad069f8bfc306286.png" alt="在这里插入图片描述"></p>
<p>个人理解：这只是一个亡羊补牢的办法，到项目后期时，因为无法修改整个系统，才使用这个方法来统一接口。</p>
<h2 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h2><p><img src="https://img-blog.csdnimg.cn/74cfe84194594f3285c40d5c1618e019.png" alt="在这里插入图片描述"></p>
<p>把中文的进攻方法修改成英文。</p>
<h2 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h2><p>此方法适合用于开发后期，前期更应统一接口，切记。</p>
<ol>
<li>使用一个已经存在的类，但如果它的接口，也就是它的方法和你的要求不相同时，就应该考虑用适配器模式。</li>
<li>两个类所做的事情相同或相似，但是具有不同的接口时要使用它。</li>
<li>在双方都不太容易修改的时候再使用适配器模式适配。</li>
</ol>
<h2 id="适配器模式与-NET应用"><a href="#适配器模式与-NET应用" class="headerlink" title="适配器模式与.NET应用"></a>适配器模式与.NET应用</h2><p>在.NET 中有一个类库已经实现的、非常重要的适配器,那就是<strong>DataAdapter</strong>. <strong>DataAdapter</strong> 用作<strong>DataSet</strong>和数据源之间的适配器以便检索和保存数据。<strong>DataAdapter</strong>通过映射<strong>FilI</strong>(这更改了<strong>DataSet</strong>中的数据以便与数据源中的数据相匹配）和<strong>Update</strong>(这更改了数据源中的数据以便与<strong>DataSet</strong>中的数据相匹配）来提供这一适配器[MSDN]。由于数据源可能是来自<strong>SQL Server</strong>，可能来自<strong>Oracle</strong>，也可能来自<strong>Access、DB2</strong>，这些数据在组织上可能有不同之处，但我们希望得到统一的<strong>DataSet</strong>(实质是XML 数据)，此时用<strong>DataAdapter</strong>就是非常好的手段，我们不必关注不同数据库的数据细节，就可以灵活的使用数据。</p>
<h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><p><strong>桥接模式(Bridge)，将抽象部分与它的实现部分分离，使它们都可以独立地变化。</strong></p>
<p>常用于项目设计初期。我觉得桥接模式所说的<strong>‘将抽象部分与它的实现部分分离</strong>，还是不好理解，我的理解就是<strong>实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这种多角度分离出来让它们独立变化，减少它们之间的耦合</strong>。</p>
<p><strong>解耦这些不同方向的变化，通过对象组合的方式，把两个角色之间的继承关系改为了组合的关系，从而使这两者可以应对各自独立的变化</strong>。</p>
<p>面对变化，<strong>找出变化并封装之</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/023c6d3b0cb4484799498f8f317118b4.png" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/59f31a88a2024aefaa235b53bbbd74e8.png" alt="在这里插入图片描述"></p>
<h2 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h2><p> <img src="https://img-blog.csdnimg.cn/3be43faf7e274255a2eb65fe122466ed.png" alt="在这里插入图片描述"></p>
<p>修改后<br><img src="https://img-blog.csdnimg.cn/9c7c7a865a5b4efcb6609deb1104334a.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h2><p>适用于项目开发前期设计好</p>
<h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><p><strong>组合模式(Composite)，将对象组合成树形结构以表示‘部分-整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</strong><br>做一个抽象的类，叶子节点主要是对于本节点的处理，composite更多的是对于之下的节点的管理。</p>
<p><img src="https://img-blog.csdnimg.cn/6cb1f782e2d04e71b80ebf93ab2105ab.png" alt="在这里插入图片描述"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h3><p><img src="https://img-blog.csdnimg.cn/a60eddbfea8049be9bdf3d204a58bf9d.png" alt="在这里插入图片描述"></p>
<h3 id="Leaf"><a href="#Leaf" class="headerlink" title="Leaf"></a>Leaf</h3><p><img src="https://img-blog.csdnimg.cn/1e6a5a7194024ce2b0e677df68064a7e.png" alt="在这里插入图片描述"></p>
<h3 id="Composite"><a href="#Composite" class="headerlink" title="Composite"></a>Composite</h3><p><img src="https://img-blog.csdnimg.cn/3e8b79ed0d5b47049275c7f80fa5f15f.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/cb76b2b10f2f4976abde5ed84e715096.png" alt="在这里插入图片描述"></p>
<h2 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h2><p><img src="https://img-blog.csdnimg.cn/9413106950fe4d188fe33fdb6ad7578d.png" alt="在这里插入图片描述"></p>
<h2 id="透明方式与安全模式"><a href="#透明方式与安全模式" class="headerlink" title="透明方式与安全模式"></a>透明方式与安全模式</h2><p><strong>Component中声明所有用来管理子对象的方法，其中包括Add、Remove等。这样实现Component 接口的所有子类都具备了Add和Remove。这样做的好处就是叶节点和枝节点对于外界没有区别，它们具备完全一致的行为接口</strong>叫做透明方式。<strong>但问题也很明显</strong>，因为 Leaf类本身不具备Add(、Remove0方法的功能，<strong>所以实现它是没有意义的</strong><br><strong>Leaf类当中不用Add和Remove方法是安全方式，也就是在Component 接口中不去声明Add和Remove方法，那么子类的Leaf也就不需要去实现它，而是在Composite声明所有用来管理子类对象的方法</strong>，这样做就不会出现刚才提到的<strong>问题</strong>，不过由于不够透明，所以树叶和树枝类将不具有相同的接口，<strong>客户端的调用需要做相应的判断,带来了不便</strong>。”</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>当你发现<strong>需求中是体现部分与整体层次的结构时</strong>，以及<strong>你希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时</strong>，就应该考虑用组合模式了。</p>
<h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p><strong>组合模式</strong>这样就<strong>定义了</strong>包含人力资源部和财务部这些基本对象和分公司、办事处<strong>等组合对象的类层次结构。基本对象可以被组合成更复杂的组合对象，而这个组合对象又可以被组合，这样不断地递归下去，客户代码中，任何用到基本对象的地方都可以使用组合对象了。</strong><br><strong>用户是不用关心到底是处理一个叶节点还是处理一个组合组件，也就用不着为定义组合而写一些选择判断语句了。</strong><br><strong>组合模式让客户可以一致地使用组合结构和单个对象。任何用到基本对象的地方都可以使用组合对象。</strong></p>
<h1 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h1><p><strong>装饰模式（Decorator)，动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。</strong><br>装饰模式顺序很重要。<strong>装饰模式是为已有功能动态地添加更多功能的一种方式。</strong><br><img src="https://img-blog.csdnimg.cn/43e8108ef8614eae9823d69dda48bed0.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/d59751ef71d543ceb79505c32806db30.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/d52f6ce5b70649b2b319f02947adf9ad.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/0b7a90ad8b494cf59916df2cfb947ef5.png" alt="在这里插入图片描述"></p>
<h2 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h2><p><img src="https://img-blog.csdnimg.cn/1dc383a7722140c19bb2adfcfc1b5084.png" alt="在这里插入图片描述"><br>实现过程有点套娃<br><img src="https://img-blog.csdnimg.cn/cda1b9e9d2004901a33302e5269d3f6a.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/5b98fc19587247c793aefffbd0d7a806.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/f6bd7fac85eb4469a5302efeb48740f4.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/c3604e5e0d29459990db982bf1a67ccb.png" alt="在这里插入图片描述"></p>
<h2 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h2><p><strong>当系统需要新功能的时候，是向旧的类中添加新的代码。这些新加的代码通常装饰了原有类的核心职责或主要行为</strong>。<br><strong>在主类中加入了新的字段，新的方法和新的逻辑，从而增加了主类的复杂度，就像你起初的那个‘人’类，而这些新加入的东西仅仅是为了满足一些只在某种特定情况下才会执行的特殊行为的需要。而装饰模式却提供了一个非常好的解决方案，它把每个要装饰的功能放在单独的类中，并让这个类包装它所要装饰的对象，因此，当需要执行特殊行为时，客户代码就可以在运行时根据需要有选择地、按顺序地使用装饰功能包装对象了</strong></p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>装饰模式的优点，<strong>把类中的装饰功能从类中搬移去除，这样可以简化原有的类</strong><br><strong>这样做更大的好处就是有效地把类的核心职责和装饰功能区分开了。而且可以去除相关类中重复的装饰逻辑。</strong></p>
<h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><h2 id="外观模式，适配器模式和桥接模式"><a href="#外观模式，适配器模式和桥接模式" class="headerlink" title="外观模式，适配器模式和桥接模式"></a>外观模式，适配器模式和桥接模式</h2><p><strong>外观模式和适配器</strong></p>
<p><strong>都是对现存系统的封装，有人说外观模式其实就是另外一组对象的适配器，这种说法是不准确的，因为外观定义的是一个新的接口，而适配器则是复用一个原有的接口，适配器是使两个已有的接口协同工作，而外观则是为现存系统提供一个更为方便的访问接口。如果硬要说外观模式是适配，那么适配器是用来适配对象的，而外观模式则是用来适配整个子系统的。也就是说，外观模式所针对的对象的粒度更大。</strong></p>
<p>个人理解：外观模式是新建一个类对原有的类进行封装功能，提供统一的接口，而适配器模式是对于原来的类进行继承，对相关类进行重写，并统一接口。</p>
<h2 id="代理模式和外观模式"><a href="#代理模式和外观模式" class="headerlink" title="代理模式和外观模式"></a>代理模式和外观模式</h2><h2 id="代理模式和适配器模式"><a href="#代理模式和适配器模式" class="headerlink" title="代理模式和适配器模式"></a>代理模式和适配器模式</h2>]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>大话设计模式观后感之行为型设计模式</title>
    <url>/2022/06/02/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%82%E5%90%8E%E6%84%9F%E4%B9%8B%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p><strong>观察者模式定义了一种一对多的依赖关系，让多个观察者对象<br>同时监听某一个主题对象。这个主题对象在状态发生变化时，<br>会通知所有观察者对象，使它们能够自动更新自己。</strong><br><img src="https://img-blog.csdnimg.cn/a08843640baf483fa713240efd659f61.png" alt="在这里插入图片描述"></p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><img src="https://img-blog.csdnimg.cn/62404e611632437897269a8ff0d5fc87.png" alt="在这里插入图片描述"></p>
<h3 id="抽象通知接口"><a href="#抽象通知接口" class="headerlink" title="抽象通知接口"></a>抽象通知接口</h3><p><img src="https://img-blog.csdnimg.cn/2c0d5364de8d4218aed872c8aa633979.png" alt="在这里插入图片描述"></p>
<h3 id="Boss实例"><a href="#Boss实例" class="headerlink" title="Boss实例"></a>Boss实例</h3><p><img src="https://img-blog.csdnimg.cn/8168378ed6a341ae80919a8d78a96bf6.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/a1ffd7d32ed24b79bbf86b55b5761113.png" alt="在这里插入图片描述"></p>
<h3 id="抽象观察者"><a href="#抽象观察者" class="headerlink" title="抽象观察者"></a>抽象观察者</h3><p><img src="https://img-blog.csdnimg.cn/f8919fb5f3a249edb87faaac5ed1b77d.png" alt="在这里插入图片描述"></p>
<h3 id="具体观察者的实现"><a href="#具体观察者的实现" class="headerlink" title="具体观察者的实现"></a>具体观察者的实现</h3><p><img src="https://img-blog.csdnimg.cn/1fc07910893c4749889b6cf8282b16dc.png" alt="在这里插入图片描述"></p>
<h2 id="观察者缺点"><a href="#观察者缺点" class="headerlink" title="观察者缺点"></a>观察者缺点</h2><p>尽管已经用了依赖倒转原则，但是. 抽象通知者’还是依赖. 抽象观察<br>者’，也就是说，万一没有了抽象观察者这样的接口，我这通知的功能就完不成了。另外就是每个具体观察者，它不-定是‘更新’的方法要调用呀，就像刚才说的，我希望的是‘工具箱’是隐藏，. 自动窗口’<br>是打开，这根本就不是同名的方法。这应该就是不足的地方吧。</p>
<h2 id="解决方案–事件委托"><a href="#解决方案–事件委托" class="headerlink" title="解决方案–事件委托"></a>解决方案–事件委托</h2><p><strong>委托就是一种引用方法的类型。-旦为委托分配了方法，.委托将与该方法具有完全相同的行为。委托方法的使用可以像其他任何方法一样，具有参数和返回值。</strong><br><strong>委托可以看作是对函数的抽象，是函数的‘类’， 委托的实例将代表一个具体的函数。</strong><br><strong>一个委托可以搭载多个方法，所有方法被依次唤起</strong> 更重要的是，<strong>它可以使得委托对象所搭载的方法并不需要属于同一个类。</strong><br><strong>但委托也是有前提的，那就是委托对象所搭载的所有方法必须具有相同的原形和形式，也就是拥有相同的参数列表和返回值类型。</strong><br>消除了观察者抽象类，在客户端进行灵活的调用不同类的相关具有相同参数和返回值的不同名函数，实现解耦。</p>
<h3 id="观察者的具体实现"><a href="#观察者的具体实现" class="headerlink" title="观察者的具体实现"></a>观察者的具体实现</h3><p><img src="https://img-blog.csdnimg.cn/3e28d4304a5b4db59a23f99d4f138c8c.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2f48bda779094c69a410a41b5bec5f5e.png" alt="在这里插入图片描述"></p>
<h3 id="通知者接口"><a href="#通知者接口" class="headerlink" title="通知者接口"></a>通知者接口</h3><p><img src="https://img-blog.csdnimg.cn/537e07e3304940d5ae39efaf39d61d8e.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/26ae09418f234920825fb4a95f094a64.png" alt="在这里插入图片描述"></p>
<h3 id="声明委托"><a href="#声明委托" class="headerlink" title="声明委托"></a>声明委托</h3><p>委托可以定义在类里面，类外面，也可以在命名空间下，根据不同的需要来确定委托方法的使用范围。<br><img src="https://img-blog.csdnimg.cn/fe7fc9acff79421b82a609e43f0b40e1.png" alt="在这里插入图片描述"></p>
<h3 id="通知者的实现"><a href="#通知者的实现" class="headerlink" title="通知者的实现"></a>通知者的实现</h3><p><img src="https://img-blog.csdnimg.cn/0033e37a5de641fb9be786e407a6d73a.png" alt="在这里插入图片描述"></p>
<h3 id="客户端灵活调用"><a href="#客户端灵活调用" class="headerlink" title="客户端灵活调用"></a>客户端灵活调用</h3><p><img src="https://img-blog.csdnimg.cn/c6b00b85c55c4ea2aa6d511ae54c0592.png" alt="在这里插入图片描述"></p>
<h3 id="事件关键字的使用"><a href="#事件关键字的使用" class="headerlink" title="事件关键字的使用"></a>事件关键字的使用</h3><p>在委托类型前加上event 代表声明事件。否则是声明委托。<br>事件只能对委托进行加减不能进行赋值</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">EventHandle</span>()</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">event</span> EventHandle MyEvent</span>;<span class="comment">//事件</span></span><br><span class="line"><span class="keyword">public</span> EventHandle MyDelegate ;<span class="comment">//委托</span></span><br></pre></td></tr></table></figure>
<h3 id="对于接口和抽象类"><a href="#对于接口和抽象类" class="headerlink" title="对于接口和抽象类"></a>对于接口和抽象类</h3><p>接口成员<br><strong>属性、方法、索引指示器和事件</strong>，但不能包含常量、域、操作符、构造函数和析构函数，而且也不能包含任何静态成员<br>C# 接口的成员不能有 public、protected、internal、private 等修饰符。原因很简单，接口里面的方法都需要由外面接口实现去实现方法体，那么其修饰符必然是 public。<strong>C# 接口中的成员默认是 public 的</strong>，java 中是可以加 public 的。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>UI背包系统</title>
    <url>/2022/06/04/UI%E8%83%8C%E5%8C%85%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p><a href="https://github.com/MrChenLreanSpace/InventroyTutorial">项目练习链接</a></p>
<h1 id="关闭打开菜单栏"><a href="#关闭打开菜单栏" class="headerlink" title="关闭打开菜单栏"></a>关闭打开菜单栏</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OpenMyBag</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.O)) &#123;</span><br><span class="line">        isOpen = !bag.activeSelf;</span><br><span class="line">        bag.SetActive(isOpen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Grid-Layerout-Group"><a href="#Grid-Layerout-Group" class="headerlink" title="Grid Layerout Group"></a>Grid Layerout Group</h1><p>他的子节点将会被填充到格子中<br><img src="https://img-blog.csdnimg.cn/e227c959129845a683ee99e438c7c781.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/5a272dde12874ca2a4bed287c0ae725d.png" alt="在这里插入图片描述"></p>
<h1 id="UI栏-的初始化"><a href="#UI栏-的初始化" class="headerlink" title="UI栏 的初始化"></a>UI栏 的初始化</h1><p>如果游戏默认开始物品栏是关闭的一定要记住先要初始化。</p>
<h1 id="ScriptableObject"><a href="#ScriptableObject" class="headerlink" title="ScriptableObject"></a>ScriptableObject</h1><p>经常配合CreateAssetMenu使用</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line">[<span class="meta">CreateAssetMenu(fileName = <span class="string">&quot;New Bag&quot;</span>,menuName = <span class="string">&quot;Inventory/New Bag&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CreateBag</span> : <span class="title">ScriptableObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;CreateItem&gt; items = <span class="keyword">new</span> List&lt;CreateItem&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="显示物品栏物体"><a href="#显示物品栏物体" class="headerlink" title="显示物品栏物体"></a>显示物品栏物体</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InventoryManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> InventoryManager instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CreateBag myBag;</span><br><span class="line">    <span class="keyword">public</span> GameObject slotGrid;</span><br><span class="line">    <span class="comment">// public Slot slotPrefab;</span></span><br><span class="line">    <span class="keyword">public</span> GameObject emptySlot;</span><br><span class="line">    <span class="keyword">public</span> Text itemInfromation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;GameObject&gt; slots = <span class="keyword">new</span> List&lt;GameObject&gt;();<span class="comment">//管理生成的18个slots</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="literal">null</span>)</span><br><span class="line">            Destroy(<span class="keyword">this</span>);</span><br><span class="line">        instance = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        RefreshItem();</span><br><span class="line">        instance.itemInfromation.text = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UpdateItemInfo</span>(<span class="params"><span class="built_in">string</span> itemDescription</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        instance.itemInfromation.text = itemDescription;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*public static void CreateNewItem(Item item)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        Slot newItem = Instantiate(instance.slotPrefab, instance.slotGrid.transform.position, Quaternion.identity);</span></span><br><span class="line"><span class="comment">        newItem.gameObject.transform.SetParent(instance.slotGrid.transform);</span></span><br><span class="line"><span class="comment">        newItem.slotItem = item;</span></span><br><span class="line"><span class="comment">        newItem.slotImage.sprite = item.itemImage;</span></span><br><span class="line"><span class="comment">        newItem.slotNum.text = item.itemHeld.ToString();</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RefreshItem</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//循环删除slotGrid下的子集物体</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; instance.slotGrid.transform.childCount; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance.slotGrid.transform.childCount == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            Destroy(instance.slotGrid.transform.GetChild(i).gameObject);</span><br><span class="line">            instance.slots.Clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重新生成对应myBag里面的物品的slot</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; instance.myBag.items.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// CreateNewItem(instance.myBag.itemList[i]);</span></span><br><span class="line">            instance.slots.Add(Instantiate(instance.emptySlot));</span><br><span class="line">            instance.slots[i].transform.SetParent(instance.slotGrid.transform);</span><br><span class="line">            instance.slots[i].GetComponent&lt;Slot&gt;().slotID = i;</span><br><span class="line">            instance.slots[i].GetComponent&lt;Slot&gt;().SetupSlot(instance.myBag.items[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="拖拽物品"><a href="#拖拽物品" class="headerlink" title="拖拽物品"></a>拖拽物品</h1><h2 id="CanvasGroup"><a href="#CanvasGroup" class="headerlink" title="CanvasGroup"></a>CanvasGroup</h2><p><img src="https://img-blog.csdnimg.cn/bb302968f8ff488cb7a63fd22eb3cb28.png" alt="在这里插入图片描述"></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">GetComponent&lt;CanvasGroup&gt;().blocksRaycasts = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>射线阻挡关闭，开启对ui面板的碰撞</p>
<h2 id="事件系统的接口"><a href="#事件系统的接口" class="headerlink" title="事件系统的接口"></a>事件系统的接口</h2><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">IBeginDragHandler, IDragHandler, IEndDragHandler<span class="comment">//接口</span></span><br><span class="line"><span class="comment">//接口提供的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnBeginDrag</span>(<span class="params">PointerEventData eventData</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDrag</span>(<span class="params">PointerEventData eventData</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEndDrag</span>(<span class="params">PointerEventData eventData</span>)</span>;</span><br></pre></td></tr></table></figure>
<p> 在OnEndDrag方法最后一定要射线阻挡开启，不然无法再次选中移动的物品<br>ItemOnDrag的代码</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.EventSystems;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ItemOnDrag</span> : <span class="title">MonoBehaviour</span>, <span class="title">IBeginDragHandler</span>, <span class="title">IDragHandler</span>, <span class="title">IEndDragHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform originalParent;</span><br><span class="line">    <span class="keyword">public</span> CreateBag myBag;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> currentItemID;<span class="comment">//当前物品ID</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnBeginDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        originalParent = transform.parent;</span><br><span class="line">        currentItemID = originalParent.GetComponent&lt;Slot&gt;().slotID;</span><br><span class="line">        transform.SetParent(transform.parent.parent);</span><br><span class="line">        transform.position = eventData.position;</span><br><span class="line">        GetComponent&lt;CanvasGroup&gt;().blocksRaycasts = <span class="literal">false</span>;<span class="comment">//射线阻挡关闭</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        transform.position = eventData.position;</span><br><span class="line">        <span class="comment">//Debug.Log(eventData.pointerCurrentRaycast.gameObject.name);//输出鼠标当前位置下到第一个碰到到物体名字</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEndDrag</span>(<span class="params">PointerEventData eventData</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(eventData.pointerCurrentRaycast.gameObject==<span class="literal">null</span>) &#123;</span><br><span class="line">            transform.SetParent(originalParent.transform);</span><br><span class="line">            transform.position = originalParent.transform.position;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (eventData.pointerCurrentRaycast.gameObject.name == <span class="string">&quot;Item Image&quot;</span>)<span class="comment">//判断下面物体名字是：Item Image 那么互换位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            transform.SetParent(eventData.pointerCurrentRaycast.gameObject.transform.parent.parent);</span><br><span class="line">            transform.position = eventData.pointerCurrentRaycast.gameObject.transform.parent.parent.position;</span><br><span class="line">            <span class="comment">//itemList的物品存储位置改变</span></span><br><span class="line">            <span class="keyword">var</span> temp = myBag.items[currentItemID];</span><br><span class="line">            myBag.items[currentItemID] = myBag.items[eventData.pointerCurrentRaycast.gameObject.GetComponentInParent&lt;Slot&gt;().slotID];</span><br><span class="line">            myBag.items[eventData.pointerCurrentRaycast.gameObject.GetComponentInParent&lt;Slot&gt;().slotID] = temp;</span><br><span class="line"></span><br><span class="line">            eventData.pointerCurrentRaycast.gameObject.transform.parent.position = originalParent.position;</span><br><span class="line">            eventData.pointerCurrentRaycast.gameObject.transform.parent.SetParent(originalParent);     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eventData.pointerCurrentRaycast.gameObject.name == <span class="string">&quot;slot(Clone)&quot;</span>) &#123;</span><br><span class="line">            <span class="comment">//否则直接挂在检测到到Slot下面</span></span><br><span class="line">            transform.SetParent(eventData.pointerCurrentRaycast.gameObject.transform);</span><br><span class="line">            transform.position = eventData.pointerCurrentRaycast.gameObject.transform.position;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//itemList的物品存储位置改变</span></span><br><span class="line">            myBag.items[eventData.pointerCurrentRaycast.gameObject.GetComponentInParent&lt;Slot&gt;().slotID] = myBag.items[currentItemID];</span><br><span class="line">            myBag.items[currentItemID] = <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            transform.SetParent(originalParent.transform);</span><br><span class="line">            transform.position = originalParent.transform.position;</span><br><span class="line">        &#125;</span><br><span class="line">        GetComponent&lt;CanvasGroup&gt;().blocksRaycasts = <span class="literal">true</span>;<span class="comment">//射线阻挡开启，不然无法再次选中移动的物品</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>详情见项目</p>
<h1 id="敌方血条显示"><a href="#敌方血条显示" class="headerlink" title="敌方血条显示"></a>敌方血条显示</h1><h2 id="血条在空间显示"><a href="#血条在空间显示" class="headerlink" title="血条在空间显示"></a>血条在空间显示</h2><p>血条显示在角色的正上方，将Canvas的渲染模式修改为世界空间坐标下，在角色正上方建立一个空物件，标识血条出现的位置用代码实现同步。</p>
<h2 id="图标始终面向摄像头"><a href="#图标始终面向摄像头" class="headerlink" title="图标始终面向摄像头"></a>图标始终面向摄像头</h2><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Target.transform.forward = - Camera.main.transform.forward;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
</search>
